import { __decorate, __metadata } from "tslib";
import { Component, Input, ChangeDetectorRef, ContentChild, ContentChildren, QueryList, HostBinding, Output, EventEmitter, AfterContentInit, OnDestroy } from '@angular/core';
import { NglDatatableColumn } from './column';
import { NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay } from './overlays';
let NglDatatable = class NglDatatable {
    constructor(detector) {
        this.detector = detector;
        this.data = [];
        this.sortChange = new EventEmitter();
        this.loading = false;
        this.rowClick = new EventEmitter();
        this.dataTrackBy = (index, data) => {
            return this.trackByKey ? data[this.trackByKey] : index;
        };
    }
    get showLoading() {
        return this.loading && this.loadingOverlay;
    }
    columnTrackBy(index, column) {
        return column.key || index;
    }
    onColumnSort(column, order) {
        const key = column.key;
        if (!key) {
            throw new Error(`ng-lightning: No "key" property is set for sortable column "${column.heading}"`);
        }
        this.sortChange.emit({ key, order });
    }
    getColumnSortOrder(column) {
        return this.sort && column.key === this.sort.key ? this.sort.order : null;
    }
    onRowClick(event, data) {
        this.rowClick.emit({ event, data });
    }
    ngAfterContentInit() {
        this._columnsSubscription = this.columns.changes.subscribe(() => this.detector.markForCheck());
    }
    ngOnDestroy() {
        if (this._columnsSubscription) {
            this._columnsSubscription.unsubscribe();
            this._columnsSubscription = null;
        }
    }
};
NglDatatable.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatatable.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatable.prototype, "trackByKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sort", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sortChange", void 0);
__decorate([
    HostBinding('class.slds-is-relative'),
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "loading", void 0);
__decorate([
    ContentChild(NglDatatableLoadingOverlay),
    __metadata("design:type", NglDatatableLoadingOverlay)
], NglDatatable.prototype, "loadingOverlay", void 0);
__decorate([
    ContentChild(NglDatatableNoRowsOverlay),
    __metadata("design:type", NglDatatableNoRowsOverlay)
], NglDatatable.prototype, "noRowsOverlay", void 0);
__decorate([
    ContentChildren(NglDatatableColumn),
    __metadata("design:type", QueryList)
], NglDatatable.prototype, "columns", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "rowClick", void 0);
NglDatatable = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'table[ngl-datatable]',
        template: "\n<thead>\n  <tr class=\"slds-line-height_reset\">\n    <th *ngFor=\"let col of columns; trackBy:columnTrackBy\" nglDatatableHead scope=\"col\" [heading]=\"col.heading\" [headingTpl]=\"col.headingTpl?.templateRef\" [sortable]=\"col.sortable\" [sortOrder]=\"getColumnSortOrder(col)\" (sort)=\"onColumnSort(col, $event)\" [ngClass]=\"col.headClass\"></th>\n  </tr>\n</thead>\n<tbody>\n  <ng-template #noData>\n    <tr>\n      <td [attr.colspan]=\"columns.length\">\n        <ng-template [ngTemplateOutlet]=\"noRowsOverlay?.templateRef\"></ng-template>\n      </td>\n    </tr>\n  </ng-template>\n  <ng-container *ngIf=\"data &amp;&amp; data.length &gt; 0; else noData\">\n    <tr *ngFor=\"let d of data; let i = index; trackBy:dataTrackBy\" (click)=\"onRowClick($event, d)\">\n      <td *ngFor=\"let col of columns; trackBy:columnTrackBy\" [ngClass]=\"col.cellClass\" nglDatatatableCell_ [row]=\"d\" [column]=\"col\" [index]=\"i\"></td>\n    </tr>\n  </ng-container>\n</tbody>\n<div class=\"ngl-datatable-loading slds-align_absolute-center\" *ngIf=\"showLoading\">\n  <ng-template [ngTemplateOutlet]=\"loadingOverlay.templateRef\"></ng-template>\n</div>",
        host: {
            '[class.slds-table]': 'true',
        },
        styles: [`
    .ngl-datatable-loading {
      position: absolute;
      z-index: 1;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.5)
    }
  `]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglDatatable);
export { NglDatatable };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRhYmxlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctbGlnaHRuaW5nLyIsInNvdXJjZXMiOlsibGliL2RhdGF0YWJsZXMvZGF0YXRhYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLFNBQVMsRUFDN0UsV0FBVyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUMvRCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDOUMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBNEJuRixJQUFhLFlBQVksR0FBekIsTUFBYSxZQUFZO0lBeUJ2QixZQUFvQixRQUEyQjtRQUEzQixhQUFRLEdBQVIsUUFBUSxDQUFtQjtRQXZCdEMsU0FBSSxHQUFVLEVBQUUsQ0FBQztRQUloQixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQXFCLENBQUM7UUFHcEQsWUFBTyxHQUFHLEtBQUssQ0FBQztRQVlmLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBeUIsQ0FBQztRQVUvRCxnQkFBVyxHQUFHLENBQUMsS0FBYSxFQUFFLElBQVMsRUFBRSxFQUFFO1lBQ3pDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ3pELENBQUMsQ0FBQTtJQVJpRCxDQUFDO0lBWm5ELElBQUksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdDLENBQUM7SUFZRCxhQUFhLENBQUMsS0FBYSxFQUFFLE1BQTBCO1FBQ3JELE9BQU8sTUFBTSxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUM7SUFDN0IsQ0FBQztJQU1ELFlBQVksQ0FBQyxNQUEwQixFQUFFLEtBQXFCO1FBQzVELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsK0RBQStELE1BQU0sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBQ25HO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsa0JBQWtCLENBQUMsTUFBMEI7UUFDM0MsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDNUUsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFZLEVBQUUsSUFBUztRQUNoQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDakcsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUM3QixJQUFJLENBQUMsb0JBQW9CLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDeEMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQztTQUNsQztJQUNILENBQUM7Q0FDRixDQUFBOztZQXBDK0IsaUJBQWlCOztBQXZCdEM7SUFBUixLQUFLLEVBQUU7OzBDQUFrQjtBQUNqQjtJQUFSLEtBQUssRUFBRTs7Z0RBQW9CO0FBRW5CO0lBQVIsS0FBSyxFQUFFOzswQ0FBeUI7QUFDdkI7SUFBVCxNQUFNLEVBQUU7O2dEQUFvRDtBQUdwRDtJQURSLFdBQVcsQ0FBQyx3QkFBd0IsQ0FBQztJQUNyQyxLQUFLLEVBQUU7OzZDQUFpQjtBQUVpQjtJQUF6QyxZQUFZLENBQUMsMEJBQTBCLENBQUM7OEJBQWlCLDBCQUEwQjtvREFBQztBQU01QztJQUF4QyxZQUFZLENBQUMseUJBQXlCLENBQUM7OEJBQWdCLHlCQUF5QjttREFBQztBQUU3QztJQUFwQyxlQUFlLENBQUMsa0JBQWtCLENBQUM7OEJBQVUsU0FBUzs2Q0FBcUI7QUFFbEU7SUFBVCxNQUFNLEVBQUU7OzhDQUFzRDtBQXJCcEQsWUFBWTtJQWhCeEIsU0FBUyxDQUFDO1FBQ1QsOENBQThDO1FBQzlDLFFBQVEsRUFBRSxzQkFBc0I7UUFDaEMsMG9DQUErQjtRQUMvQixJQUFJLEVBQUU7WUFDSixvQkFBb0IsRUFBRSxNQUFNO1NBQzdCO2lCQUNROzs7Ozs7O0dBT1I7S0FDRixDQUFDO3FDQTBCOEIsaUJBQWlCO0dBekJwQyxZQUFZLENBNkR4QjtTQTdEWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LCBJbnB1dCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3QsXG4gIEhvc3RCaW5kaW5nLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ2xEYXRhdGFibGVDb2x1bW4gfSBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgeyBOZ2xEYXRhdGFibGVMb2FkaW5nT3ZlcmxheSwgTmdsRGF0YXRhYmxlTm9Sb3dzT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElOZ2xEYXRhdGFibGVTb3J0IHtcbiAga2V5OiBzdHJpbmc7XG4gIG9yZGVyOiAnYXNjJyB8ICdkZXNjJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTmdsRGF0YXRhYmxlUm93Q2xpY2sge1xuICBldmVudDogRXZlbnQ7XG4gIGRhdGE6IGFueTtcbn1cblxuQENvbXBvbmVudCh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICd0YWJsZVtuZ2wtZGF0YXRhYmxlXScsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRhdGFibGUuaHRtbCcsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnNsZHMtdGFibGVdJzogJ3RydWUnLFxuICB9LFxuICBzdHlsZXM6IFtgXG4gICAgLm5nbC1kYXRhdGFibGUtbG9hZGluZyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB6LWluZGV4OiAxO1xuICAgICAgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwO1xuICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpXG4gICAgfVxuICBgXSxcbn0pXG5leHBvcnQgY2xhc3MgTmdsRGF0YXRhYmxlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBkYXRhOiBhbnlbXSA9IFtdO1xuICBASW5wdXQoKSB0cmFja0J5S2V5OiBzdHJpbmc7XG5cbiAgQElucHV0KCkgc29ydDogSU5nbERhdGF0YWJsZVNvcnQ7XG4gIEBPdXRwdXQoKSBzb3J0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJTmdsRGF0YXRhYmxlU29ydD4oKTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnNsZHMtaXMtcmVsYXRpdmUnKVxuICBASW5wdXQoKSBsb2FkaW5nID0gZmFsc2U7XG5cbiAgQENvbnRlbnRDaGlsZChOZ2xEYXRhdGFibGVMb2FkaW5nT3ZlcmxheSkgbG9hZGluZ092ZXJsYXk6IE5nbERhdGF0YWJsZUxvYWRpbmdPdmVybGF5O1xuXG4gIGdldCBzaG93TG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nICYmIHRoaXMubG9hZGluZ092ZXJsYXk7XG4gIH1cblxuICBAQ29udGVudENoaWxkKE5nbERhdGF0YWJsZU5vUm93c092ZXJsYXkpIG5vUm93c092ZXJsYXk6IE5nbERhdGF0YWJsZU5vUm93c092ZXJsYXk7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2xEYXRhdGFibGVDb2x1bW4pIGNvbHVtbnM6IFF1ZXJ5TGlzdDxOZ2xEYXRhdGFibGVDb2x1bW4+O1xuXG4gIEBPdXRwdXQoKSByb3dDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8SU5nbERhdGF0YWJsZVJvd0NsaWNrPigpO1xuXG4gIHByaXZhdGUgX2NvbHVtbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICBjb2x1bW5UcmFja0J5KGluZGV4OiBudW1iZXIsIGNvbHVtbjogTmdsRGF0YXRhYmxlQ29sdW1uKSB7XG4gICAgcmV0dXJuIGNvbHVtbi5rZXkgfHwgaW5kZXg7XG4gIH1cblxuICBkYXRhVHJhY2tCeSA9IChpbmRleDogbnVtYmVyLCBkYXRhOiBhbnkpID0+IHtcbiAgICByZXR1cm4gdGhpcy50cmFja0J5S2V5ID8gZGF0YVt0aGlzLnRyYWNrQnlLZXldIDogaW5kZXg7XG4gIH1cblxuICBvbkNvbHVtblNvcnQoY29sdW1uOiBOZ2xEYXRhdGFibGVDb2x1bW4sIG9yZGVyOiAnYXNjJyB8ICdkZXNjJykge1xuICAgIGNvbnN0IGtleSA9IGNvbHVtbi5rZXk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmctbGlnaHRuaW5nOiBObyBcImtleVwiIHByb3BlcnR5IGlzIHNldCBmb3Igc29ydGFibGUgY29sdW1uIFwiJHtjb2x1bW4uaGVhZGluZ31cImApO1xuICAgIH1cbiAgICB0aGlzLnNvcnRDaGFuZ2UuZW1pdCh7a2V5LCBvcmRlcn0pO1xuICB9XG5cbiAgZ2V0Q29sdW1uU29ydE9yZGVyKGNvbHVtbjogTmdsRGF0YXRhYmxlQ29sdW1uKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydCAmJiBjb2x1bW4ua2V5ID09PSB0aGlzLnNvcnQua2V5ID8gdGhpcy5zb3J0Lm9yZGVyIDogbnVsbDtcbiAgfVxuXG4gIG9uUm93Q2xpY2soZXZlbnQ6IEV2ZW50LCBkYXRhOiBhbnkpIHtcbiAgICB0aGlzLnJvd0NsaWNrLmVtaXQoeyBldmVudCwgZGF0YSB9KTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9jb2x1bW5zU3Vic2NyaXB0aW9uID0gdGhpcy5jb2x1bW5zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuZGV0ZWN0b3IubWFya0ZvckNoZWNrKCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbHVtbnNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX2NvbHVtbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuX2NvbHVtbnNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuIl19