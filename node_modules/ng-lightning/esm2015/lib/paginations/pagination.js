import { __decorate, __metadata } from "tslib";
import { Component, EventEmitter, Input, Output, ChangeDetectionStrategy } from '@angular/core';
import { InputBoolean } from '../util/convert';
let NglPagination = class NglPagination {
    constructor() {
        this.pages = [];
        this.pageChange = new EventEmitter();
        this.perPage = 10;
        this.limit = 0;
        this.boundaryNumbers = 0;
        this.firstText = 'First';
        this.previousText = 'Previous';
        this.nextText = 'Next';
        this.lastText = 'Last';
        this.boundaryLinks = false;
    }
    set page(page) {
        this.current = +page;
    }
    hasPrevious() {
        return this.current > 1;
    }
    hasNext() {
        return this.current < this.totalPages;
    }
    goto(page) {
        if (page === this.current) {
            return;
        }
        this.pageChange.emit(+page);
    }
    ngOnChanges() {
        this.totalPages = Math.ceil(+this.total / +this.perPage);
        const { start, end } = this.limits();
        this.pages = this.getPageArray(start, end);
        if (this.boundaryNumbers > 0) {
            if (start > 1) {
                const preGap = this.getPageArray(1, Math.min(start - 1, this.boundaryNumbers));
                const lastGapNumber = +preGap[preGap.length - 1].number;
                if (lastGapNumber < start - 1) {
                    this.pages.unshift(this.getGapPage(lastGapNumber, start));
                }
                this.pages.unshift(...preGap);
            }
            if (end < this.totalPages) {
                const postGap = this.getPageArray(Math.max(this.totalPages - this.boundaryNumbers + 1, end + 1), this.totalPages);
                const firstGapNumber = +postGap[0].number;
                if (firstGapNumber > end + 1) {
                    this.pages.push(this.getGapPage(end, firstGapNumber));
                }
                this.pages.push(...postGap);
            }
        }
        if (this.current > this.totalPages) {
            setTimeout(() => this.goto(this.totalPages));
        }
        else if (!this.current && this.totalPages > 0) {
            setTimeout(() => this.goto(1));
        }
    }
    pageTrackBy(index, page) {
        return page.number;
    }
    get start() {
        return Math.min(Math.max(1 + (+this.current - 1) * +this.perPage, 0), +this.total);
    }
    get end() {
        return Math.min(this.start + (+this.perPage - 1), +this.total);
    }
    getPageArray(start, end) {
        return Array.apply(null, { length: end - start + 1 }).map((value, index) => this.getPage(start + index));
    }
    getPage(number, disabled = false) {
        return { number, disabled };
    }
    getGapPage(before, after) {
        const isConsecutive = before + 1 === after - 1;
        return this.getPage(isConsecutive ? before + 1 : '...', !isConsecutive);
    }
    /**
     * Calculate first and last visible page numbers
     */
    limits() {
        let start = 1, end = this.totalPages;
        if (this.limit < 1) {
            return { start, end };
        }
        // Current page is displayed in the middle of the visible ones
        start = Math.max(+this.current - Math.floor(+this.limit / 2), 1);
        end = start + +this.limit - 1;
        // Adjust if limit is exceeded
        if (end > this.totalPages) {
            end = this.totalPages;
            start = Math.max(end - +this.limit + 1, 1);
        }
        return { start, end };
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPagination.prototype, "page", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPagination.prototype, "pageChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "perPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "limit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryNumbers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "firstText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "previousText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "nextText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "lastText", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryLinks", void 0);
NglPagination = __decorate([
    Component({
        selector: 'ngl-pagination',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<div class=\"slds-button-group\" role=\"group\">\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasPrevious()\" (click)=\"goto(1)\">{{firstText}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasPrevious()\" (click)=\"goto(current - 1)\">{{previousText}}</button>\n  <button class=\"slds-button\" *ngFor=\"let page of pages; trackBy:pageTrackBy\" [ngClass]=\"'slds-button_' + (page.number === current ? 'brand' : 'neutral')\" (click)=\"goto(page.number)\" [disabled]=\"page.disabled\">{{page.number}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasNext()\" (click)=\"goto(current + 1)\">{{nextText}}</button>\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasNext()\" (click)=\"goto(totalPages)\">{{lastText}}</button>\n</div>",
        exportAs: 'nglPagination'
    })
], NglPagination);
export { NglPagination };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi9wYWdpbmF0aW9ucy9wYWdpbmF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFhLHVCQUF1QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVUvQyxJQUFhLGFBQWEsR0FBMUIsTUFBYSxhQUFhO0lBQTFCO1FBRUUsVUFBSyxHQUFjLEVBQUUsQ0FBQztRQU1aLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBR3pDLFlBQU8sR0FBb0IsRUFBRSxDQUFDO1FBQzlCLFVBQUssR0FBb0IsQ0FBQyxDQUFDO1FBQzNCLG9CQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLGNBQVMsR0FBRyxPQUFPLENBQUM7UUFDcEIsaUJBQVksR0FBRyxVQUFVLENBQUM7UUFDMUIsYUFBUSxHQUFHLE1BQU0sQ0FBQztRQUNsQixhQUFRLEdBQUcsTUFBTSxDQUFDO1FBQ0Ysa0JBQWEsR0FBRyxLQUFLLENBQUM7SUFpR2pELENBQUM7SUE5R1UsSUFBSSxJQUFJLENBQUMsSUFBcUI7UUFDckMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQztJQUN2QixDQUFDO0lBZUQsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBSSxDQUFDLElBQVk7UUFDZixJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBQ3RDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpELE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXJDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFM0MsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsRUFBRTtZQUM1QixJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7Z0JBQ2IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO2dCQUMvRSxNQUFNLGFBQWEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztnQkFDeEQsSUFBSSxhQUFhLEdBQUcsS0FBSyxHQUFHLENBQUMsRUFBRTtvQkFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDM0Q7Z0JBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQzthQUMvQjtZQUVELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ2xILE1BQU0sY0FBYyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztnQkFDMUMsSUFBSSxjQUFjLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztpQkFDdkQ7Z0JBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQzthQUM3QjtTQUNGO1FBRUQsSUFBSSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbEMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDOUM7YUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRTtZQUMvQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVELFdBQVcsQ0FBQyxLQUFhLEVBQUUsSUFBYTtRQUN0QyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQUVELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVELElBQUksR0FBRztRQUNMLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFTyxZQUFZLENBQUMsS0FBYSxFQUFFLEdBQVc7UUFDN0MsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN0SCxDQUFDO0lBRU8sT0FBTyxDQUFDLE1BQXVCLEVBQUUsUUFBUSxHQUFHLEtBQUs7UUFDdkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRU8sVUFBVSxDQUFDLE1BQWMsRUFBRSxLQUFhO1FBQzlDLE1BQU0sYUFBYSxHQUFHLE1BQU0sR0FBRyxDQUFDLEtBQUssS0FBSyxHQUFHLENBQUMsQ0FBQztRQUMvQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBRUQ7O09BRUc7SUFDSyxNQUFNO1FBQ1osSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBRXJDLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUU7WUFBRSxPQUFPLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxDQUFDO1NBQUU7UUFFNUMsOERBQThEO1FBQzlELEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNqRSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7UUFFOUIsOEJBQThCO1FBQzlCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDekIsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7WUFDdEIsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDNUM7UUFFRCxPQUFPLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxDQUFDO0lBQ3RCLENBQUM7Q0FFRixDQUFBO0FBOUdVO0lBQVIsS0FBSyxFQUFFOzs7eUNBRVA7QUFDUztJQUFULE1BQU0sRUFBRTs7aURBQXlDO0FBRXpDO0lBQVIsS0FBSyxFQUFFOzs0Q0FBd0I7QUFDdkI7SUFBUixLQUFLLEVBQUU7OzhDQUErQjtBQUM5QjtJQUFSLEtBQUssRUFBRTs7NENBQTRCO0FBQzNCO0lBQVIsS0FBSyxFQUFFOztzREFBcUI7QUFDcEI7SUFBUixLQUFLLEVBQUU7O2dEQUFxQjtBQUNwQjtJQUFSLEtBQUssRUFBRTs7bURBQTJCO0FBQzFCO0lBQVIsS0FBSyxFQUFFOzsrQ0FBbUI7QUFDbEI7SUFBUixLQUFLLEVBQUU7OytDQUFtQjtBQUNGO0lBQXhCLEtBQUssRUFBRSxFQUFFLFlBQVksRUFBRTs7b0RBQXVCO0FBbEJwQyxhQUFhO0lBTnpCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxnQkFBZ0I7UUFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07UUFDL0MsMDNCQUFnQztRQUNoQyxRQUFRLEVBQUUsZUFBZTtLQUMxQixDQUFDO0dBQ1csYUFBYSxDQW1IekI7U0FuSFksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBPbkNoYW5nZXMsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4gfSBmcm9tICcuLi91dGlsL2NvbnZlcnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5nbFBhZ2UgeyBudW1iZXI6IG51bWJlciB8IHN0cmluZzsgZGlzYWJsZWQ/OiBib29sZWFuOyB9XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nbC1wYWdpbmF0aW9uJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlVXJsOiAnLi9wYWdpbmF0aW9uLmh0bWwnLFxuICBleHBvcnRBczogJ25nbFBhZ2luYXRpb24nLFxufSlcbmV4cG9ydCBjbGFzcyBOZ2xQYWdpbmF0aW9uIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICBwYWdlczogTmdsUGFnZVtdID0gW107XG5cbiAgY3VycmVudDogbnVtYmVyO1xuICBASW5wdXQoKSBzZXQgcGFnZShwYWdlOiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSArcGFnZTtcbiAgfVxuICBAT3V0cHV0KCkgcGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIEBJbnB1dCgpIHRvdGFsOiBudW1iZXIgfCBzdHJpbmc7XG4gIEBJbnB1dCgpIHBlclBhZ2U6IG51bWJlciB8IHN0cmluZyA9IDEwO1xuICBASW5wdXQoKSBsaW1pdDogbnVtYmVyIHwgc3RyaW5nID0gMDtcbiAgQElucHV0KCkgYm91bmRhcnlOdW1iZXJzID0gMDtcbiAgQElucHV0KCkgZmlyc3RUZXh0ID0gJ0ZpcnN0JztcbiAgQElucHV0KCkgcHJldmlvdXNUZXh0ID0gJ1ByZXZpb3VzJztcbiAgQElucHV0KCkgbmV4dFRleHQgPSAnTmV4dCc7XG4gIEBJbnB1dCgpIGxhc3RUZXh0ID0gJ0xhc3QnO1xuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgYm91bmRhcnlMaW5rcyA9IGZhbHNlO1xuXG4gIHRvdGFsUGFnZXM6IG51bWJlcjtcblxuICBoYXNQcmV2aW91cygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID4gMTtcbiAgfVxuXG4gIGhhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA8IHRoaXMudG90YWxQYWdlcztcbiAgfVxuXG4gIGdvdG8ocGFnZTogbnVtYmVyKSB7XG4gICAgaWYgKHBhZ2UgPT09IHRoaXMuY3VycmVudCkgeyByZXR1cm47IH1cbiAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCgrcGFnZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLnRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoK3RoaXMudG90YWwgLyArdGhpcy5wZXJQYWdlKTtcblxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5saW1pdHMoKTtcblxuICAgIHRoaXMucGFnZXMgPSB0aGlzLmdldFBhZ2VBcnJheShzdGFydCwgZW5kKTtcblxuICAgIGlmICh0aGlzLmJvdW5kYXJ5TnVtYmVycyA+IDApIHtcbiAgICAgIGlmIChzdGFydCA+IDEpIHtcbiAgICAgICAgY29uc3QgcHJlR2FwID0gdGhpcy5nZXRQYWdlQXJyYXkoMSwgTWF0aC5taW4oc3RhcnQgLSAxLCB0aGlzLmJvdW5kYXJ5TnVtYmVycykpO1xuICAgICAgICBjb25zdCBsYXN0R2FwTnVtYmVyID0gK3ByZUdhcFtwcmVHYXAubGVuZ3RoIC0gMV0ubnVtYmVyO1xuICAgICAgICBpZiAobGFzdEdhcE51bWJlciA8IHN0YXJ0IC0gMSkge1xuICAgICAgICAgIHRoaXMucGFnZXMudW5zaGlmdCh0aGlzLmdldEdhcFBhZ2UobGFzdEdhcE51bWJlciwgc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZ2VzLnVuc2hpZnQoLi4ucHJlR2FwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA8IHRoaXMudG90YWxQYWdlcykge1xuICAgICAgICBjb25zdCBwb3N0R2FwID0gdGhpcy5nZXRQYWdlQXJyYXkoTWF0aC5tYXgodGhpcy50b3RhbFBhZ2VzIC0gdGhpcy5ib3VuZGFyeU51bWJlcnMgKyAxLCBlbmQgKyAxKSwgdGhpcy50b3RhbFBhZ2VzKTtcbiAgICAgICAgY29uc3QgZmlyc3RHYXBOdW1iZXIgPSArcG9zdEdhcFswXS5udW1iZXI7XG4gICAgICAgIGlmIChmaXJzdEdhcE51bWJlciA+IGVuZCArIDEpIHtcbiAgICAgICAgICB0aGlzLnBhZ2VzLnB1c2godGhpcy5nZXRHYXBQYWdlKGVuZCwgZmlyc3RHYXBOdW1iZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZ2VzLnB1c2goLi4ucG9zdEdhcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudCA+IHRoaXMudG90YWxQYWdlcykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmdvdG8odGhpcy50b3RhbFBhZ2VzKSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50ICYmIHRoaXMudG90YWxQYWdlcyA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5nb3RvKDEpKTtcbiAgICB9XG4gIH1cblxuICBwYWdlVHJhY2tCeShpbmRleDogbnVtYmVyLCBwYWdlOiBOZ2xQYWdlKSB7XG4gICAgcmV0dXJuIHBhZ2UubnVtYmVyO1xuICB9XG5cbiAgZ2V0IHN0YXJ0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KDEgKyAoK3RoaXMuY3VycmVudCAtIDEpICogK3RoaXMucGVyUGFnZSwgMCksICt0aGlzLnRvdGFsKTtcbiAgfVxuXG4gIGdldCBlbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zdGFydCArICgrdGhpcy5wZXJQYWdlIC0gMSksICt0aGlzLnRvdGFsKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGFnZUFycmF5KHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIHtsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMX0pLm1hcCgodmFsdWU6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gdGhpcy5nZXRQYWdlKHN0YXJ0ICsgaW5kZXgpKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGFnZShudW1iZXI6IHN0cmluZyB8IG51bWJlciwgZGlzYWJsZWQgPSBmYWxzZSk6IE5nbFBhZ2Uge1xuICAgIHJldHVybiB7IG51bWJlciwgZGlzYWJsZWQgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0R2FwUGFnZShiZWZvcmU6IG51bWJlciwgYWZ0ZXI6IG51bWJlcikge1xuICAgIGNvbnN0IGlzQ29uc2VjdXRpdmUgPSBiZWZvcmUgKyAxID09PSBhZnRlciAtIDE7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZShpc0NvbnNlY3V0aXZlID8gYmVmb3JlICsgMSA6ICcuLi4nLCAhaXNDb25zZWN1dGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGZpcnN0IGFuZCBsYXN0IHZpc2libGUgcGFnZSBudW1iZXJzXG4gICAqL1xuICBwcml2YXRlIGxpbWl0cygpIHtcbiAgICBsZXQgc3RhcnQgPSAxLCBlbmQgPSB0aGlzLnRvdGFsUGFnZXM7XG5cbiAgICBpZiAodGhpcy5saW1pdCA8IDEpIHsgcmV0dXJuIHtzdGFydCwgZW5kfTsgfVxuXG4gICAgLy8gQ3VycmVudCBwYWdlIGlzIGRpc3BsYXllZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSB2aXNpYmxlIG9uZXNcbiAgICBzdGFydCA9IE1hdGgubWF4KCt0aGlzLmN1cnJlbnQgLSBNYXRoLmZsb29yKCt0aGlzLmxpbWl0IC8gMiksIDEpO1xuICAgIGVuZCA9IHN0YXJ0ICsgK3RoaXMubGltaXQgLSAxO1xuXG4gICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgaWYgKGVuZCA+IHRoaXMudG90YWxQYWdlcykge1xuICAgICAgZW5kID0gdGhpcy50b3RhbFBhZ2VzO1xuICAgICAgc3RhcnQgPSBNYXRoLm1heChlbmQgLSArdGhpcy5saW1pdCArIDEsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB7c3RhcnQsIGVuZH07XG4gIH1cblxufVxuIl19