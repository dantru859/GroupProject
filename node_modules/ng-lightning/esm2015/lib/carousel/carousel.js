import { __decorate, __metadata, __param } from "tslib";
import { Component, Input, ChangeDetectionStrategy, ContentChildren, QueryList, Output, EventEmitter, ViewChildren, ViewChild, ElementRef, Optional, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { InputBoolean, InputNumber } from '../util/convert';
import { NglCarouselImage } from './carousel-image';
import { NglCarouselIndicator } from './carousel-indicator';
let NglCarousel = class NglCarousel {
    constructor(document) {
        this.document = document;
        this.activeChange = new EventEmitter();
        /**
         * The auto scroll duration in seconds. After that the next image is displayed.
         */
        this.scrollDuration = 5;
        /**
         * Whether auto scroll is enabled.
         */
        this.autoScroll = true;
        /**
         * Whether the carousel should continue looping from the beginning after the last item is displayed.
         */
        this.autoRefresh = true;
        this.labels = {
            startAutoPlay: 'Start auto-play',
            stopAutoPlay: 'Stop auto-play',
        };
        this.playing = true;
        this.nextTimer = null;
    }
    isActive(index) {
        return index === this.active;
    }
    getImage(index) {
        return this.images.toArray()[index];
    }
    ngOnChanges(changes) {
        if (changes.active) {
            // Focus correct indicator if one is already focused
            if (this.document && this.indicatorsEl.nativeElement.contains(document.activeElement)) {
                this.indicators.toArray()[this.active].focus();
            }
        }
        if (changes.active || changes.autoScroll || changes.scrollDuration) {
            // Reset timer when active changes
            this.setTimer();
        }
    }
    onIndicatorClick(index) {
        this.setActive(index, true);
    }
    onKeyboard(evt) {
        if (evt.keyCode === LEFT_ARROW || evt.keyCode === RIGHT_ARROW) {
            this.activateNext(evt.keyCode === LEFT_ARROW);
        }
    }
    setActive(index, stopPlaying = false) {
        if (stopPlaying) {
            this.playing = false;
        }
        if (this.active !== index) {
            this.activeChange.emit(index);
        }
    }
    togglePlay() {
        this.playing = !this.playing;
        this.setTimer();
    }
    playLabel() {
        return this.labels[this.playing ? 'stopAutoPlay' : 'startAutoPlay'];
    }
    activateNext(reverse = false) {
        const active = this.active + (reverse ? -1 : 1);
        if ((active < 0 || active > this.images.length - 1) && !this.autoRefresh) {
            return;
        }
        this.setActive((this.images.length + active) % this.images.length);
    }
    setTimer() {
        clearTimeout(this.nextTimer);
        if (this.autoScroll && this.playing) {
            this.nextTimer = setTimeout(() => {
                this.activateNext();
            }, this.scrollDuration * 1000);
        }
    }
};
NglCarousel.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "active", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "activeChange", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "scrollDuration", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoScroll", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoRefresh", void 0);
__decorate([
    ContentChildren(NglCarouselImage),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "images", void 0);
__decorate([
    ViewChildren(NglCarouselIndicator),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "indicators", void 0);
__decorate([
    ViewChild('indicatorsEl', { static: true }),
    __metadata("design:type", ElementRef)
], NglCarousel.prototype, "indicatorsEl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "labels", void 0);
NglCarousel = __decorate([
    Component({
        selector: 'ngl-carousel',
        template: "\n<div class=\"slds-carousel__stage\"><span class=\"slds-carousel__autoplay\" *ngIf=\"autoScroll\">\n    <button class=\"slds-button slds-button_icon slds-button_icon-border-filled slds-button_icon-x-small\" [attr.aria-pressed]=\"!playing\" [title]=\"playLabel()\" (click)=\"togglePlay()\">\n      <svg class=\"slds-button__icon\" [nglIconName]=\"playing ? 'utility:pause' : 'utility:right'\"></svg><span class=\"slds-assistive-text\">{{ playLabel() }}</span>\n    </button></span>\n  <div class=\"slds-carousel__panels\" [style.transform]=\"'translateX(' + (-active * 100) + '%)'\">\n    <ng-content></ng-content>\n  </div>\n  <ul class=\"slds-carousel__indicators\" #indicatorsEl role=\"tablist\" (keydown)=\"onKeyboard($event)\">\n    <li class=\"slds-carousel__indicator\" *ngFor=\"let image of images; let i = index\" role=\"presentation\"><a class=\"slds-carousel__indicator-action\" nglCarouselIndicator href=\"javascript:void(0);\" role=\"tab\" [isActive]=\"isActive(i)\" [image]=\"getImage(i)\" [attr.aria-controls]=\"image.uid\" [title]=\"image.header\" (click)=\"onIndicatorClick(i)\"><span class=\"slds-assistive-text\">{{ image.header }}</span></a></li>\n  </ul>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-carousel]': 'true',
        }
    }),
    __param(0, Optional()), __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglCarousel);
export { NglCarousel };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1saWdodG5pbmcvIiwic291cmNlcyI6WyJsaWIvY2Fyb3VzZWwvY2Fyb3VzZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQzVFLE1BQU0sRUFBRSxZQUFZLEVBQWEsWUFBWSxFQUFpQixTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0gsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQVU1RCxJQUFhLFdBQVcsR0FBeEIsTUFBYSxXQUFXO0lBb0N0QixZQUFrRCxRQUFhO1FBQWIsYUFBUSxHQUFSLFFBQVEsQ0FBSztRQWhDckQsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBRXBEOztXQUVHO1FBQ3FCLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBRTNDOztXQUVHO1FBQ3NCLGVBQVUsR0FBRyxJQUFJLENBQUM7UUFFM0M7O1dBRUc7UUFDc0IsZ0JBQVcsR0FBRyxJQUFJLENBQUM7UUFRMUIsV0FBTSxHQUFHO1lBQ3pCLGFBQWEsRUFBRSxpQkFBaUI7WUFDaEMsWUFBWSxFQUFFLGdCQUFnQjtTQUMvQixDQUFDO1FBRUYsWUFBTyxHQUFHLElBQUksQ0FBQztRQUVQLGNBQVMsR0FBRyxJQUFJLENBQUM7SUFFeUMsQ0FBQztJQUVuRSxRQUFRLENB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SUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUNoQztJQUNILENBQUM7Q0FDRixDQUFBOzs0Q0F4RWMsUUFBUSxZQUFJLE1BQU0sU0FBQyxRQUFROztBQWxDaEI7SUFBdkIsS0FBSyxFQUFFLEVBQUUsV0FBVyxFQUFFOzsyQ0FBaUI7QUFFOUI7SUFBVCxNQUFNLEVBQUU7O2lEQUEyQztBQUs1QjtJQUF2QixLQUFLLEVBQUUsRUFBRSxXQUFXLEVBQUU7O21EQUFvQjtBQUtsQjtJQUF4QixLQUFLLEVBQUUsRUFBRSxZQUFZLEVBQUU7OytDQUFtQjtBQUtsQjtJQUF4QixLQUFLLEVBQUUsRUFBRSxZQUFZLEVBQUU7O2dEQUFvQjtBQUVUO0lBQWxDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQzs4QkFBUyxTQUFTOzJDQUFtQjtBQUVuQztJQUFuQyxZQUFZLENBQUMsb0JBQW9CLENBQUM7OEJBQWEsU0FBUzsrQ0FBdUI7QUFFbkM7SUFBNUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQzs4QkFBZSxVQUFVO2lEQUFjO0FBRTFFO0lBQVIsS0FBSyxFQUFFOzsyQ0FHTjtBQTlCUyxXQUFXO0lBUnZCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxjQUFjO1FBQ3hCLDJxQ0FBOEI7UUFDOUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07UUFDL0MsSUFBSSxFQUFFO1lBQ0osdUJBQXVCLEVBQUUsTUFBTTtTQUNoQztLQUNGLENBQUM7SUFxQ2EsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBOztHQXBDOUIsV0FBVyxDQTRHdkI7U0E1R1ksV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCxcbiAgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgVmlld0NoaWxkcmVuLCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IExFRlRfQVJST1csIFJJR0hUX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IElucHV0Qm9vbGVhbiwgSW5wdXROdW1iZXIgfSBmcm9tICcuLi91dGlsL2NvbnZlcnQnO1xuaW1wb3J0IHsgTmdsQ2Fyb3VzZWxJbWFnZSB9IGZyb20gJy4vY2Fyb3VzZWwtaW1hZ2UnO1xuaW1wb3J0IHsgTmdsQ2Fyb3VzZWxJbmRpY2F0b3IgfSBmcm9tICcuL2Nhcm91c2VsLWluZGljYXRvcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nbC1jYXJvdXNlbCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jYXJvdXNlbC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnNsZHMtY2Fyb3VzZWxdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ2xDYXJvdXNlbCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgQElucHV0KCkgQElucHV0TnVtYmVyKCkgcmVhZG9ubHkgYWN0aXZlO1xuXG4gIEBPdXRwdXQoKSBhY3RpdmVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKipcbiAgICogVGhlIGF1dG8gc2Nyb2xsIGR1cmF0aW9uIGluIHNlY29uZHMuIEFmdGVyIHRoYXQgdGhlIG5leHQgaW1hZ2UgaXMgZGlzcGxheWVkLlxuICAgKi9cbiAgQElucHV0KCkgQElucHV0TnVtYmVyKCkgc2Nyb2xsRHVyYXRpb24gPSA1O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuXG4gICAqL1xuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgYXV0b1Njcm9sbCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNhcm91c2VsIHNob3VsZCBjb250aW51ZSBsb29waW5nIGZyb20gdGhlIGJlZ2lubmluZyBhZnRlciB0aGUgbGFzdCBpdGVtIGlzIGRpc3BsYXllZC5cbiAgICovXG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBhdXRvUmVmcmVzaCA9IHRydWU7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2xDYXJvdXNlbEltYWdlKSBpbWFnZXM6IFF1ZXJ5TGlzdDxOZ2xDYXJvdXNlbEltYWdlPjtcblxuICBAVmlld0NoaWxkcmVuKE5nbENhcm91c2VsSW5kaWNhdG9yKSBpbmRpY2F0b3JzOiBRdWVyeUxpc3Q8TmdsQ2Fyb3VzZWxJbmRpY2F0b3I+O1xuXG4gIEBWaWV3Q2hpbGQoJ2luZGljYXRvcnNFbCcsIHsgc3RhdGljOiB0cnVlIH0pIGluZGljYXRvcnNFbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgQElucHV0KCkgcmVhZG9ubHkgbGFiZWxzID0ge1xuICAgIHN0YXJ0QXV0b1BsYXk6ICdTdGFydCBhdXRvLXBsYXknLFxuICAgIHN0b3BBdXRvUGxheTogJ1N0b3AgYXV0by1wbGF5JyxcbiAgfTtcblxuICBwbGF5aW5nID0gdHJ1ZTtcblxuICBwcml2YXRlIG5leHRUaW1lciA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogYW55KSB7fVxuXG4gIGlzQWN0aXZlKGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IHRoaXMuYWN0aXZlO1xuICB9XG5cbiAgZ2V0SW1hZ2UoaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLmltYWdlcy50b0FycmF5KClbaW5kZXhdO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLmFjdGl2ZSkge1xuICAgICAgLy8gRm9jdXMgY29ycmVjdCBpbmRpY2F0b3IgaWYgb25lIGlzIGFscmVhZHkgZm9jdXNlZFxuICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgJiYgdGhpcy5pbmRpY2F0b3JzRWwubmF0aXZlRWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLmluZGljYXRvcnMudG9BcnJheSgpW3RoaXMuYWN0aXZlXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmFjdGl2ZSB8fCBjaGFuZ2VzLmF1dG9TY3JvbGwgfHwgY2hhbmdlcy5zY3JvbGxEdXJhdGlvbikge1xuICAgICAgLy8gUmVzZXQgdGltZXIgd2hlbiBhY3RpdmUgY2hhbmdlc1xuICAgICAgdGhpcy5zZXRUaW1lcigpO1xuICAgIH1cbiAgfVxuXG4gIG9uSW5kaWNhdG9yQ2xpY2soaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuc2V0QWN0aXZlKGluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIG9uS2V5Ym9hcmQoZXZ0OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGV2dC5rZXlDb2RlID09PSBMRUZUX0FSUk9XIHx8IGV2dC5rZXlDb2RlID09PSBSSUdIVF9BUlJPVykge1xuICAgICAgdGhpcy5hY3RpdmF0ZU5leHQoZXZ0LmtleUNvZGUgPT09IExFRlRfQVJST1cpO1xuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZShpbmRleDogbnVtYmVyLCBzdG9wUGxheWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHN0b3BQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hY3RpdmUgIT09IGluZGV4KSB7XG4gICAgICB0aGlzLmFjdGl2ZUNoYW5nZS5lbWl0KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVQbGF5KCkge1xuICAgIHRoaXMucGxheWluZyA9ICF0aGlzLnBsYXlpbmc7XG4gICAgdGhpcy5zZXRUaW1lcigpO1xuICB9XG5cbiAgcGxheUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsc1t0aGlzLnBsYXlpbmcgPyAnc3RvcEF1dG9QbGF5JyA6ICdzdGFydEF1dG9QbGF5J107XG4gIH1cblxuICBwcml2YXRlIGFjdGl2YXRlTmV4dChyZXZlcnNlID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZSArIChyZXZlcnNlID8gLTEgOiAxKTtcblxuICAgIGlmICgoYWN0aXZlIDwgMCB8fCBhY3RpdmUgPiB0aGlzLmltYWdlcy5sZW5ndGggLSAxKSAmJiAhdGhpcy5hdXRvUmVmcmVzaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QWN0aXZlKCh0aGlzLmltYWdlcy5sZW5ndGggKyBhY3RpdmUpICUgdGhpcy5pbWFnZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0VGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFRpbWVyKTtcblxuICAgIGlmICh0aGlzLmF1dG9TY3JvbGwgJiYgdGhpcy5wbGF5aW5nKSB7XG4gICAgICB0aGlzLm5leHRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2YXRlTmV4dCgpO1xuICAgICAgfSwgdGhpcy5zY3JvbGxEdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cbiAgfVxufVxuIl19