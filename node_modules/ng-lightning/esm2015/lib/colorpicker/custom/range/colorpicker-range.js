import { __decorate, __metadata, __param } from "tslib";
import { Component, ElementRef, ChangeDetectionStrategy, Input, ViewChild, Output, EventEmitter, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { LEFT_ARROW, DOWN_ARROW, UP_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { flatMap, map, takeUntil, startWith } from 'rxjs/operators';
import { merge, fromEvent } from 'rxjs';
import { getHexFromHsv } from '../../util';
import { trapEvent, uniqueId } from '../../../util/util';
let NglColorpickerRange = class NglColorpickerRange {
    constructor(document) {
        this.document = document;
        this.hsvChange = new EventEmitter();
        this.uid = uniqueId('colorpicker-range');
        this._hsv = { hue: 0, saturation: 0, value: 0 };
    }
    set hsv(hsv) {
        if (hsv) {
            this._hsv = hsv;
        }
    }
    get hsv() {
        return this._hsv;
    }
    get hex() {
        return getHexFromHsv(this.hsv);
    }
    ngAfterViewInit() {
        this.dragSubscription = this.setupDrag().subscribe((mm) => this.emitChange(mm));
    }
    hueSliderChange(value) {
        this.emitChange({ hue: value });
    }
    rangeIndicatorKeyboard(evt) {
        let saturation = this.hsv.saturation;
        let value = this.hsv.value;
        switch (evt.keyCode) {
            case LEFT_ARROW:
                saturation = this.limit(saturation - 1);
                break;
            case RIGHT_ARROW:
                saturation = this.limit(saturation + 1);
                break;
            case UP_ARROW:
                value = this.limit(value + 1);
                break;
            case DOWN_ARROW:
                value = this.limit(value - 1);
                break;
            default:
                return;
        }
        trapEvent(evt);
        this.emitChange({ saturation, value });
    }
    indicatorStyle() {
        return {
            'bottom.%': this.hsv.value,
            'left.%': this.hsv.saturation,
            'background': this.hex,
        };
    }
    ngOnDestroy() {
        if (this.dragSubscription) {
            this.dragSubscription.unsubscribe();
            this.dragSubscription = null;
        }
    }
    emitChange(hsv) {
        this.hsvChange.emit(Object.assign(Object.assign({}, this.hsv), hsv));
    }
    limit(value) {
        return Math.min(Math.max(value, 0), 100);
    }
    setupDrag() {
        const dragTarget = this.rangeIndicatorContainer.nativeElement;
        const pressEnd = merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend'));
        const pressMove = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));
        const pressStart = merge(fromEvent(dragTarget, 'mousedown'), fromEvent(dragTarget, 'touchstart'));
        return pressStart.pipe(flatMap((md) => {
            this.rangeIndicator.nativeElement.focus();
            const rect = dragTarget.getBoundingClientRect();
            return pressMove.pipe(startWith(md), map((mm) => {
                mm.preventDefault();
                const saturation = Math.round((mm.clientX - rect.left) / rect.width * 100);
                const value = Math.round((rect.bottom - mm.clientY) / rect.height * 100);
                return { saturation: this.limit(saturation), value: this.limit(value) };
            }), takeUntil(pressEnd));
        }));
    }
};
NglColorpickerRange.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange.prototype, "hsv", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerRange.prototype, "hsvChange", void 0);
__decorate([
    ViewChild('rangeIndicator'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicator", void 0);
__decorate([
    ViewChild('rangeIndicatorContainer'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicatorContainer", void 0);
NglColorpickerRange = __decorate([
    Component({
        selector: 'ngl-colorpicker-range',
        template: "\n<p class=\"slds-assistive-text\" [attr.id]=\"uid + '-instructions'\">Use arrow keys to select a saturation and brightness, on an x and y axis.</p>\n<div class=\"slds-color-picker__custom-range\" #rangeIndicatorContainer [style.background]=\"'hsl(' + hsv.hue + ', 100%, 50%)'\"><a class=\"slds-color-picker__range-indicator\" #rangeIndicator href=\"javascript:void(0);\" aria-live=\"assertive\" aria-atomic=\"true\" [attr.aria-describedby]=\"uid + '-instructions'\" [ngStyle]=\"indicatorStyle()\" (keydown)=\"rangeIndicatorKeyboard($event)\"><span class=\"slds-assistive-text\">Saturation: {{hsv.saturation}}%. Brightness: {{hsv.value}}%.</span></a></div>\n<div class=\"slds-color-picker__hue-and-preview\">\n  <label class=\"slds-assistive-text\" [attr.for]=\"uid + '-hue'\">Select Hue</label>\n  <input class=\"slds-color-picker__hue-slider\" #hueSlider type=\"range\" min=\"0\" max=\"360\" [id]=\"uid + '-hue'\" [value]=\"hsv.hue\" (input)=\"hueSliderChange($event.target.value)\"><span nglColorpickerSwatch [color]=\"hex\"></span>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange);
export { NglColorpickerRange };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3JwaWNrZXItcmFuZ2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1saWdodG5pbmcvIiwic291cmNlcyI6WyJsaWIvY29sb3JwaWNrZXIvY3VzdG9tL3JhbmdlL2NvbG9ycGlja2VyLXJhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSx1QkFBdUIsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQTRCLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6SixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLGFBQWEsRUFBUSxNQUFNLFlBQVksQ0FBQztBQUNqRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBT3pELElBQWEsbUJBQW1CLEdBQWhDLE1BQWEsbUJBQW1CO0lBMEI5QixZQUFzQyxRQUFhO1FBQWIsYUFBUSxHQUFSLFFBQVEsQ0FBSztRQWZ6QyxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUsvQyxRQUFHLEdBQUcsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFNNUIsU0FBSSxHQUFTLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUlGLENBQUM7SUF4Qi9DLElBQUksR0FBRyxDQUFDLEdBQVM7UUFDeEIs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QUFDO1FBQ0osQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Q0FDRixDQUFBOzs0Q0E3RmMsTUFBTSxTQUFDLFFBQVE7O0FBeEJuQjtJQUFSLEtBQUssRUFBRTs7OzhDQUlQO0FBS1M7SUFBVCxNQUFNLEVBQUU7O3NEQUFzQztBQUVsQjtJQUE1QixTQUFTLENBQUMsZ0JBQWdCLENBQUM7OEJBQWlCLFVBQVU7MkRBQUM7QUFDbEI7SUFBckMsU0FBUyxDQUFDLHlCQUF5QixDQUFDOzhCQUEwQixVQUFVO29FQUFDO0FBZC9ELG1CQUFtQjtJQUwvQixTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsdUJBQXVCO1FBQ2pDLCtoQ0FBdUM7UUFDdkMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07S0FDaEQsQ0FBQztJQTJCYSxXQUFBLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTs7R0ExQmxCLG1CQUFtQixDQXVIL0I7U0F2SFksbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgSW5wdXQsIFZpZXdDaGlsZCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBMRUZUX0FSUk9XLCBET1dOX0FSUk9XLCBVUF9BUlJPVywgUklHSFRfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgZmxhdE1hcCwgbWFwLCB0YWtlVW50aWwsIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IG1lcmdlLCBmcm9tRXZlbnQsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZ2V0SGV4RnJvbUhzdiwgSUhTViB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgdHJhcEV2ZW50LCB1bmlxdWVJZCB9IGZyb20gJy4uLy4uLy4uL3V0aWwvdXRpbCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nbC1jb2xvcnBpY2tlci1yYW5nZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9jb2xvcnBpY2tlci1yYW5nZS5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE5nbENvbG9ycGlja2VyUmFuZ2UgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpIHNldCBoc3YoaHN2OiBJSFNWKSB7XG4gICAgaWYgKGhzdikge1xuICAgICAgdGhpcy5faHN2ID0gaHN2O1xuICAgIH1cbiAgfVxuICBnZXQgaHN2KCkge1xuICAgIHJldHVybiB0aGlzLl9oc3Y7XG4gIH1cblxuICBAT3V0cHV0KCkgaHN2Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJSFNWPigpO1xuXG4gIEBWaWV3Q2hpbGQoJ3JhbmdlSW5kaWNhdG9yJykgcmFuZ2VJbmRpY2F0b3I6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ3JhbmdlSW5kaWNhdG9yQ29udGFpbmVyJykgcmFuZ2VJbmRpY2F0b3JDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgdWlkID0gdW5pcXVlSWQoJ2NvbG9ycGlja2VyLXJhbmdlJyk7XG5cbiAgZ2V0IGhleCgpIHtcbiAgICByZXR1cm4gZ2V0SGV4RnJvbUhzdih0aGlzLmhzdik7XG4gIH1cblxuICBwcml2YXRlIF9oc3Y6IElIU1YgPSB7IGh1ZTogMCwgc2F0dXJhdGlvbjogMCwgdmFsdWU6IDAgfTtcblxuICBwcml2YXRlIGRyYWdTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnkpIHsgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmRyYWdTdWJzY3JpcHRpb24gPSB0aGlzLnNldHVwRHJhZygpLnN1YnNjcmliZSgobW06IGFueSkgPT4gdGhpcy5lbWl0Q2hhbmdlKG1tKSk7XG4gIH1cblxuICBodWVTbGlkZXJDaGFuZ2UodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW1pdENoYW5nZSh7IGh1ZTogdmFsdWUgfSk7XG4gIH1cblxuICByYW5nZUluZGljYXRvcktleWJvYXJkKGV2dDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBzYXR1cmF0aW9uID0gdGhpcy5oc3Yuc2F0dXJhdGlvbjtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmhzdi52YWx1ZTtcblxuICAgIHN3aXRjaCAoZXZ0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgc2F0dXJhdGlvbiA9IHRoaXMubGltaXQoc2F0dXJhdGlvbiAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIHNhdHVyYXRpb24gPSB0aGlzLmxpbWl0KHNhdHVyYXRpb24gKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICB2YWx1ZSA9IHRoaXMubGltaXQodmFsdWUgKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIHZhbHVlID0gdGhpcy5saW1pdCh2YWx1ZSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFwRXZlbnQoZXZ0KTtcbiAgICB0aGlzLmVtaXRDaGFuZ2UoeyBzYXR1cmF0aW9uLCB2YWx1ZSB9KTtcbiAgfVxuXG4gIGluZGljYXRvclN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnYm90dG9tLiUnOiB0aGlzLmhzdi52YWx1ZSxcbiAgICAgICdsZWZ0LiUnOiB0aGlzLmhzdi5zYXR1cmF0aW9uLFxuICAgICAgJ2JhY2tncm91bmQnOiB0aGlzLmhleCxcbiAgICB9O1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZHJhZ1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5kcmFnU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLmRyYWdTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdENoYW5nZShoc3Y6IFBhcnRpYWw8SUhTVj4pIHtcbiAgICB0aGlzLmhzdkNoYW5nZS5lbWl0KHsgLi4udGhpcy5oc3YsIC4uLmhzdiB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbGltaXQodmFsdWUpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEwMCk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRHJhZygpIHtcbiAgICBjb25zdCBkcmFnVGFyZ2V0ID0gdGhpcy5yYW5nZUluZGljYXRvckNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuXG4gICAgY29uc3QgcHJlc3NFbmQgPSBtZXJnZShcbiAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnbW91c2V1cCcpLFxuICAgICAgZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICd0b3VjaGVuZCcpXG4gICAgKTtcblxuICAgIGNvbnN0IHByZXNzTW92ZSA9IG1lcmdlKFxuICAgICAgZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdtb3VzZW1vdmUnKSxcbiAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAndG91Y2htb3ZlJylcbiAgICApO1xuXG4gICAgY29uc3QgcHJlc3NTdGFydCA9IG1lcmdlKFxuICAgICAgZnJvbUV2ZW50KGRyYWdUYXJnZXQsICdtb3VzZWRvd24nKSxcbiAgICAgIGZyb21FdmVudChkcmFnVGFyZ2V0LCAndG91Y2hzdGFydCcpXG4gICAgKTtcblxuICAgIHJldHVybiBwcmVzc1N0YXJ0LnBpcGUoZmxhdE1hcCgobWQpID0+IHtcbiAgICAgIHRoaXMucmFuZ2VJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgY29uc3QgcmVjdCA9IGRyYWdUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgcmV0dXJuIHByZXNzTW92ZS5waXBlKFxuICAgICAgICBzdGFydFdpdGgobWQpLFxuICAgICAgICBtYXAoKG1tOiBhbnkpID0+IHtcbiAgICAgICAgICBtbS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgY29uc3Qgc2F0dXJhdGlvbiA9IE1hdGgucm91bmQoKG1tLmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCAqIDEwMCk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKChyZWN0LmJvdHRvbSAtIG1tLmNsaWVudFkpIC8gcmVjdC5oZWlnaHQgKiAxMDApO1xuICAgICAgICAgIHJldHVybiB7IHNhdHVyYXRpb246IHRoaXMubGltaXQoc2F0dXJhdGlvbiksIHZhbHVlOiB0aGlzLmxpbWl0KHZhbHVlKSB9O1xuICAgICAgICB9KSxcbiAgICAgICAgdGFrZVVudGlsKHByZXNzRW5kKSxcbiAgICAgICk7XG4gICAgfSkpO1xuICB9XG59XG4iXX0=