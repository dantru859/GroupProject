import { __decorate, __metadata, __param } from "tslib";
import { Component, Input, ChangeDetectionStrategy, Output, EventEmitter, HostListener, HostBinding, ContentChild, ViewChild, TemplateRef, Optional, Inject } from '@angular/core';
import { NglRatingIconTemplate } from './icons';
import { InputBoolean } from '../util/convert';
import { NGL_RATING_CONFIG, NglRatingConfig } from './config';
let NglRating = class NglRating {
    constructor(defaultConfig) {
        this.range = [];
        this.icon = 'favorite';
        this.readonly = false;
        this.rateChange = new EventEmitter();
        this.hover = new EventEmitter();
        this._max = 5;
        const config = Object.assign(Object.assign({}, new NglRatingConfig()), defaultConfig);
        this.colorOn = config.colorOn;
        this.colorOff = config.colorOff;
    }
    set rate(rate) {
        this.inputRate = rate;
        this.currentRate = rate;
    }
    set max(max) {
        this._max = +max;
        this.setRange();
    }
    get max() {
        return this._max;
    }
    ngOnInit() {
        this.setRange();
    }
    ngAfterContentInit() {
        this._template = this.iconTemplate ? this.iconTemplate.templateRef : this.defaultTemplate;
    }
    update(value) {
        if (value < 1 || value > this.max || this.readonly || value === this.inputRate) {
            return;
        }
        this.rateChange.emit(value);
    }
    enter(value) {
        if (this.readonly) {
            return;
        }
        this.currentRate = value;
        this.hover.emit(value);
    }
    getFill(value) {
        if (value <= this.currentRate) {
            return 100;
        }
        if (Math.ceil(this.currentRate) < value) {
            return 0;
        }
        return Math.round(100 * (this.currentRate % 1));
    }
    reset() {
        this.currentRate = this.inputRate;
    }
    // Keyboard interactions
    keyboardIncrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate + 1);
    }
    keyboardDecrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate - 1);
    }
    // ARIA
    get ariaValuenow() {
        return this.inputRate;
    }
    setRange() {
        this.range = Array.apply(null, { length: this.max }).map((value, index) => index + 1);
    }
};
NglRating.ctorParameters = () => [
    { type: NglRatingConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_RATING_CONFIG,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRating.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "size", void 0);
__decorate([
    Input('isReadonly'), InputBoolean(),
    __metadata("design:type", Object)
], NglRating.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglRating.prototype, "rate", null);
__decorate([
    ViewChild('t', { static: true }),
    __metadata("design:type", TemplateRef)
], NglRating.prototype, "defaultTemplate", void 0);
__decorate([
    ContentChild(NglRatingIconTemplate),
    __metadata("design:type", NglRatingIconTemplate)
], NglRating.prototype, "iconTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglRating.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOff", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "rateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "hover", void 0);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "reset", null);
__decorate([
    HostListener('keydown.ArrowUp', ['$event']),
    HostListener('keydown.ArrowRight', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardIncrease", null);
__decorate([
    HostListener('keydown.ArrowDown', ['$event']),
    HostListener('keydown.ArrowLeft', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardDecrease", null);
__decorate([
    HostBinding('attr.aria-valuenow'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRating.prototype, "ariaValuenow", null);
NglRating = __decorate([
    Component({
        selector: 'ngl-rating',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<ng-template #t let-fill=\"fill\">\n  <svg class=\"slds-icon\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"fill === 100 ? colorOn : colorOff\"></svg>\n  <svg class=\"slds-icon\" *ngIf=\"fill &gt; 0 &amp;&amp; fill &lt; 100\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"colorOn\" style=\"position:absolute; bottom:0;\" [style.left.%]=\"fill - 100\" [xPos]=\"(100 - fill) + '%'\"></svg>\n</ng-template>\n<div class=\"slds-show_inline-block\" *ngFor=\"let r of range; let i = index\" (click)=\"update(r)\" (mouseenter)=\"enter(r)\" style=\"position: relative;\">\n  <ng-template [ngTemplateOutlet]=\"_template\" [ngTemplateOutletContext]=\"{$implicit: r &lt;= currentRate, index: i, fill: getFill(r)}\"></ng-template>\n</div>",
        host: {
            'style': 'white-space: nowrap;',
            'tabindex': '0',
            'aria-valuemin': '0',
            '[attr.aria-valuemax]': 'max',
        }
    }),
    __param(0, Optional()), __param(0, Inject(NGL_RATING_CONFIG)),
    __metadata("design:paramtypes", [NglRatingConfig])
], NglRating);
export { NglRating };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF0aW5nLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctbGlnaHRuaW5nLyIsInNvdXJjZXMiOlsibGliL3JhdGluZ3MvcmF0aW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSx1QkFBdUIsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFDOUUsV0FBVyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUE0QixRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdILE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNoRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQWE5RCxJQUFhLFNBQVMsR0FBdEIsTUFBYSxTQUFTO0lBcUNwQixZQUFtRCxhQUE4QjtRQW5DakYsVUFBSyxHQUFhLEVBQUUsQ0FBQztRQUdaLFNBQUksR0FBRyxVQUFVLENBQUM7UUFJVSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBcUI1QyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUN4QyxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUdyQyxTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBSWYsTUFBTSxNQUFNLG1DQUFRLElBQUksZUFBZSxFQUFFLEdBQUssYUFBYSxDQUFFLENBQUM7UUFDOUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQzlCLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUNsQyxDQUFDO0lBOUJRLElBQUksSUFBSSxDQUFDLElBQVk7UUFDNUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENB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R0FyQ3RFLFNBQVMsQ0FxR3JCO1NBckdZLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lcixcbiAgICAgICAgSG9zdEJpbmRpbmcsIENvbnRlbnRDaGlsZCwgVmlld0NoaWxkLCBUZW1wbGF0ZVJlZiwgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPcHRpb25hbCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ2xSYXRpbmdJY29uVGVtcGxhdGUgfSBmcm9tICcuL2ljb25zJztcbmltcG9ydCB7IElucHV0Qm9vbGVhbiB9IGZyb20gJy4uL3V0aWwvY29udmVydCc7XG5pbXBvcnQgeyBOR0xfUkFUSU5HX0NPTkZJRywgTmdsUmF0aW5nQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ2wtcmF0aW5nJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlVXJsOiAnLi9yYXRpbmcuaHRtbCcsXG4gIGhvc3Q6IHtcbiAgICAnc3R5bGUnOiAnd2hpdGUtc3BhY2U6IG5vd3JhcDsnLFxuICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAnYXJpYS12YWx1ZW1pbic6ICcwJyxcbiAgICAnW2F0dHIuYXJpYS12YWx1ZW1heF0nOiAnbWF4JyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTmdsUmF0aW5nIGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0IHtcblxuICByYW5nZTogbnVtYmVyW10gPSBbXTtcbiAgY3VycmVudFJhdGU6IG51bWJlcjtcblxuICBASW5wdXQoKSBpY29uID0gJ2Zhdm9yaXRlJztcblxuICBASW5wdXQoKSBzaXplOiAneC1zbWFsbCcgfCAnc21hbGwnIHwgJ2xhcmdlJztcblxuICBASW5wdXQoJ2lzUmVhZG9ubHknKSBASW5wdXRCb29sZWFuKCkgcmVhZG9ubHkgPSBmYWxzZTtcblxuICBASW5wdXQoKSBzZXQgcmF0ZShyYXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLmlucHV0UmF0ZSA9IHJhdGU7XG4gICAgdGhpcy5jdXJyZW50UmF0ZSA9IHJhdGU7XG4gIH1cblxuICBAVmlld0NoaWxkKCd0JywgeyBzdGF0aWM6IHRydWUgfSkgZGVmYXVsdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBAQ29udGVudENoaWxkKE5nbFJhdGluZ0ljb25UZW1wbGF0ZSkgaWNvblRlbXBsYXRlOiBOZ2xSYXRpbmdJY29uVGVtcGxhdGU7XG5cbiAgQElucHV0KCkgc2V0IG1heChtYXg6IG51bWJlciB8IHN0cmluZykge1xuICAgIHRoaXMuX21heCA9ICttYXg7XG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuICB9XG4gIGdldCBtYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heDtcbiAgfVxuXG4gIEBJbnB1dCgpIGNvbG9yT246IHN0cmluZztcbiAgQElucHV0KCkgY29sb3JPZmY6IHN0cmluZztcblxuICBAT3V0cHV0KCkgcmF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICBAT3V0cHV0KCkgaG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gIHByaXZhdGUgX21heCA9IDU7XG4gIHByaXZhdGUgaW5wdXRSYXRlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChOR0xfUkFUSU5HX0NPTkZJRykgZGVmYXVsdENvbmZpZzogTmdsUmF0aW5nQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0geyAuLi5uZXcgTmdsUmF0aW5nQ29uZmlnKCksIC4uLmRlZmF1bHRDb25maWcgfTtcbiAgICB0aGlzLmNvbG9yT24gPSBjb25maWcuY29sb3JPbjtcbiAgICB0aGlzLmNvbG9yT2ZmID0gY29uZmlnLmNvbG9yT2ZmO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdGhpcy5pY29uVGVtcGxhdGUgPyB0aGlzLmljb25UZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHRoaXMuZGVmYXVsdFRlbXBsYXRlO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodmFsdWUgPCAxIHx8IHZhbHVlID4gdGhpcy5tYXggfHwgdGhpcy5yZWFkb25seSB8fCB2YWx1ZSA9PT0gdGhpcy5pbnB1dFJhdGUpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5yYXRlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICB9XG5cbiAgZW50ZXIodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5jdXJyZW50UmF0ZSA9IHZhbHVlO1xuICAgIHRoaXMuaG92ZXIuZW1pdCh2YWx1ZSk7XG4gIH1cblxuICBnZXRGaWxsKHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodmFsdWUgPD0gdGhpcy5jdXJyZW50UmF0ZSkge1xuICAgICAgcmV0dXJuIDEwMDtcbiAgICB9XG4gICAgaWYgKE1hdGguY2VpbCh0aGlzLmN1cnJlbnRSYXRlKSA8IHZhbHVlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgxMDAgKiAodGhpcy5jdXJyZW50UmF0ZSAlIDEpKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSYXRlID0gdGhpcy5pbnB1dFJhdGU7XG4gIH1cblxuICAvLyBLZXlib2FyZCBpbnRlcmFjdGlvbnNcbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd1VwJywgWyckZXZlbnQnXSlcbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd1JpZ2h0JywgWyckZXZlbnQnXSlcbiAga2V5Ym9hcmRJbmNyZWFzZShldnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmlucHV0UmF0ZSArIDEpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd0Rvd24nLCBbJyRldmVudCddKVxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93TGVmdCcsIFsnJGV2ZW50J10pXG4gIGtleWJvYXJkRGVjcmVhc2UoZXZ0OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy51cGRhdGUodGhpcy5pbnB1dFJhdGUgLSAxKTtcbiAgfVxuXG4gIC8vIEFSSUFcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKSBnZXQgYXJpYVZhbHVlbm93KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0UmF0ZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UmFuZ2UoKSB7XG4gICAgdGhpcy5yYW5nZSA9IEFycmF5LmFwcGx5KG51bGwsIHtsZW5ndGg6IHRoaXMubWF4fSkubWFwKCh2YWx1ZTogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCArIDEpO1xuICB9XG59XG4iXX0=