import { __decorate, __metadata, __param } from "tslib";
import { Component, Input, ChangeDetectionStrategy, ElementRef, Renderer2, Inject, Optional } from '@angular/core';
import { normalizeIconName } from './util';
import { NglIconConfig, NGL_ICON_CONFIG } from './config';
let NglIconSvg = class NglIconSvg {
    constructor(defaultConfig, el, renderer) {
        this.xPos = '0';
        renderer.setAttribute(el.nativeElement, 'aria-hidden', 'true');
        const config = Object.assign(Object.assign({}, new NglIconConfig()), defaultConfig);
        this.path = config.svgPath;
    }
    set iconName(iconName) {
        const [category, icon] = normalizeIconName(iconName).split(':');
        this.iconPath = `${this.path}/${category}-sprite/svg/symbols.svg#${icon}`;
    }
};
NglIconSvg.ctorParameters = () => [
    { type: NglIconConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_ICON_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('nglIconName'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglIconSvg.prototype, "iconName", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglIconSvg.prototype, "xPos", void 0);
NglIconSvg = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'svg[nglIconName]',
        template: "\n<svg:use [attr.xlink:href]=\"iconPath\" [attr.x]=\"xPos\"></svg:use>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Optional()), __param(0, Inject(NGL_ICON_CONFIG)),
    __metadata("design:paramtypes", [NglIconConfig,
        ElementRef,
        Renderer2])
], NglIconSvg);
export { NglIconSvg };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctbGlnaHRuaW5nLyIsInNvdXJjZXMiOlsibGliL2ljb25zL3N2Zy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ILE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQVExRCxJQUFhLFVBQVUsR0FBdkIsTUFBYSxVQUFVO0lBYXJCLFlBQWlELGFBQTRCLEVBQ2pFLEVBQWMsRUFDZCxRQUFtQjtRQU50QixTQUFJLEdBQUcsR0FBRyxDQUFDO1FBT2xCLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFL0QsTUFBTSxNQUFNLG1DQUFRLElBQUksYUFBYSxFQUFFLEdBQUssYUFBYSxDQUFFLENBQUM7UUFDNUQsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO0lBQzdCLENBQUM7SUFoQnFCLElBQUksUUFBUSxDQUFDLFFBQWdCO1FBQ2pELE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hFLElBQUksQ0FBQyxRQUFRLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLFFBQVEsMkJBQTJCLElBQUksRUFBRSxDQUFDO0lBQzVFLENBQUM7Q0FjRixDQUFBOztZQVJpRSxhQUFhLHVCQUFoRSxRQUFRLFlBQUksTUFBTSxTQUFDLGVBQWU7WUFDL0IsVUFBVTtZQUNKLFNBQVM7O0FBWFQ7SUFBckIsS0FBSyxDQUFDLGFBQWEsQ0FBQzs7OzBDQUdwQjtBQUVRO0lBQVIsS0FBSyxFQUFFOzt3Q0FBWTtBQVRULFVBQVU7SUFOdEIsU0FBUyxDQUFDO1FBQ1QsOENBQThDO1FBQzlDLFFBQVEsRUFBRSxrQkFBa0I7UUFDNUIsa0ZBQXlCO1FBQ3pCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO0tBQ2hELENBQUM7SUFjYSxXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUE7cUNBQWdCLGFBQWE7UUFDN0QsVUFBVTtRQUNKLFNBQVM7R0FmcEIsVUFBVSxDQXFCdEI7U0FyQlksVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBFbGVtZW50UmVmLCBSZW5kZXJlcjIsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG5vcm1hbGl6ZUljb25OYW1lIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IE5nbEljb25Db25maWcsIE5HTF9JQ09OX0NPTkZJRyB9IGZyb20gJy4vY29uZmlnJztcblxuQENvbXBvbmVudCh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdzdmdbbmdsSWNvbk5hbWVdJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3N2Zy5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE5nbEljb25Tdmcge1xuXG4gIHBhdGg6IHN0cmluZztcblxuICBASW5wdXQoJ25nbEljb25OYW1lJykgc2V0IGljb25OYW1lKGljb25OYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBbY2F0ZWdvcnksIGljb25dID0gbm9ybWFsaXplSWNvbk5hbWUoaWNvbk5hbWUpLnNwbGl0KCc6Jyk7XG4gICAgdGhpcy5pY29uUGF0aCA9IGAke3RoaXMucGF0aH0vJHtjYXRlZ29yeX0tc3ByaXRlL3N2Zy9zeW1ib2xzLnN2ZyMke2ljb259YDtcbiAgfVxuXG4gIEBJbnB1dCgpIHhQb3MgPSAnMCc7XG5cbiAgaWNvblBhdGg6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KE5HTF9JQ09OX0NPTkZJRykgZGVmYXVsdENvbmZpZzogTmdsSWNvbkNvbmZpZyxcbiAgICAgICAgICAgICAgZWw6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICByZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWwubmF0aXZlRWxlbWVudCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4ubmV3IE5nbEljb25Db25maWcoKSwgLi4uZGVmYXVsdENvbmZpZyB9O1xuICAgIHRoaXMucGF0aCA9IGNvbmZpZy5zdmdQYXRoO1xuICB9XG59XG4iXX0=