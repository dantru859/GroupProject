import { __decorate, __metadata, __param } from 'tslib';
import { RendererFactory2, Injectable, ElementRef, Input, Component, ChangeDetectionStrategy, InjectionToken, Optional, Inject, Renderer2, NgModule, TemplateRef, Directive, EventEmitter, Output, ContentChildren, QueryList, ChangeDetectorRef, HostBinding, HostListener, ViewChildren, ViewChild, ContentChild, ViewContainerRef, forwardRef, Self, NgZone, LOCALE_ID } from '@angular/core';
import { CommonModule, DOCUMENT, getLocaleMonthNames, FormStyle, TranslationWidth, getLocaleDayNames, getLocaleFirstDayOfWeek } from '@angular/common';
import { coerceBooleanProperty, _isNumberValue, coerceNumberProperty } from '@angular/cdk/coercion';
import { LEFT_ARROW, RIGHT_ARROW, ESCAPE, DOWN_ARROW, UP_ARROW, ENTER, PAGE_UP, PAGE_DOWN, HOME, END } from '@angular/cdk/keycodes';
import { BehaviorSubject, Subject, merge, fromEvent } from 'rxjs';
import { ConnectionPositionPair, Overlay, OverlayModule, CdkConnectedOverlay, ScrollDispatcher, CdkOverlayOrigin } from '@angular/cdk/overlay';
import { FocusTrapFactory, A11yModule, ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { ComponentPortal } from '@angular/cdk/portal';
import { map, distinctUntilChanged, mapTo, filter, flatMap, startWith, takeUntil, buffer, debounceTime, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { parse, format } from 'date-fns';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/a11y';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/forms';
import * as ɵngcc5 from '@angular/cdk/scrolling';

function NglIcon_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r83 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r83.alternativeText);
} }
const _c0 = ["*"];
const _c1 = ["nglIconName", ""];
const _c2 = ["nglInternalOutlet", ""];
function NglInternalOutlet_ng_template_0_ng_template_0_Template(rf, ctx) { }
function NglInternalOutlet_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglInternalOutlet_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 2);
} if (rf & 2) {
    const ctx_r84 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r84.nglInternalOutlet)("ngTemplateOutletContext", ctx_r84.nglInternalOutletContext);
} }
function NglInternalOutlet_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r86 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r86.nglInternalOutlet);
} }
function NglAccordion_li_0_Template(rf, ctx) { if (rf & 1) {
    const _r91 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵlistener("toggle", function NglAccordion_li_0_Template_li_toggle_0_listener() { ɵngcc0.ɵɵrestoreView(_r91); const section_r89 = ctx.$implicit; const ctx_r90 = ɵngcc0.ɵɵnextContext(); return ctx_r90.toggle(section_r89); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const section_r89 = ctx.$implicit;
    const ctx_r88 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", ctx_r88.isActive(section_r89))("section", section_r89);
} }
const _c3 = ["nglAccordionItem", ""];
function NglAccordionItem_ng_container_7_ng_template_1_Template(rf, ctx) { }
function NglAccordionItem_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglAccordionItem_ng_container_7_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r92 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r92.section.templateRef);
} }
const _c4 = function (a0) { return { $implicit: a0 }; };
function NglAlert_ngl_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 4);
} if (rf & 2) {
    const ctx_r94 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("iconName", ctx_r94.iconName);
} }
function NglAlert_button_5_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r96 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r96.closeButtonAssistiveText);
} }
function NglAlert_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r98 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function NglAlert_button_5_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r98); const ctx_r97 = ɵngcc0.ɵɵnextContext(); return ctx_r97.close("button", $event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 6);
    ɵngcc0.ɵɵtemplate(2, NglAlert_button_5_span_2_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r95 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r95.closeButtonAssistiveText);
} }
function NglAvatar_img_0_Template(rf, ctx) { if (rf & 1) {
    const _r103 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "img", 2);
    ɵngcc0.ɵɵlistener("error", function NglAvatar_img_0_Template_img_error_0_listener() { ɵngcc0.ɵɵrestoreView(_r103); const ctx_r102 = ɵngcc0.ɵɵnextContext(); return ctx_r102.onImgError(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r99 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("src", ctx_r99.src, ɵngcc0.ɵɵsanitizeUrl)("alt", ctx_r99.alternativeText);
} }
function NglAvatar_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r101 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r101.fallbackIconClass());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r101.initials);
} }
function NglBreadcrumbs_li_2_ng_template_1_Template(rf, ctx) { }
function NglBreadcrumbs_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵtemplate(1, NglBreadcrumbs_li_2_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const b_r105 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", b_r105.templateRef);
} }
const _c5 = ["nglButtonIcon", ""];
function NglButtonIcon__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r107 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r107.iconName)("ngClass", ctx_r107.iconClass());
} }
function NglButtonIcon_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const text_r109 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(text_r109);
} }
const _c6 = ["nglButtonIconStateful", ""];
function NglButtonIconStateful__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r110 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r110.iconName);
} }
function NglButtonIconStateful_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const text_r112 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(text_r112);
} }
const _c7 = ["nglButton", ""];
function NglButton__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
} if (rf & 2) {
    const ctx_r113 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r113.iconName);
} }
function NglButton__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 3);
} if (rf & 2) {
    const ctx_r114 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r114.iconName);
} }
function NglButtonStateOn__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r115 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r115.iconName);
} }
function NglButtonStateOff__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r116 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r116.iconName);
} }
function NglButtonStateHover__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 1);
} if (rf & 2) {
    const ctx_r117 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r117.iconName);
} }
const _c8 = ["indicatorsEl"];
function NglCarousel_span_1_Template(rf, ctx) { if (rf & 1) {
    const _r122 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵelementStart(1, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NglCarousel_span_1_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r122); const ctx_r121 = ɵngcc0.ɵɵnextContext(); return ctx_r121.togglePlay(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(2, "svg", 8);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(3, "span", 9);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r118 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", ctx_r118.playLabel());
    ɵngcc0.ɵɵattribute("aria-pressed", !ctx_r118.playing);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r118.playing ? "utility:pause" : "utility:right");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r118.playLabel());
} }
function NglCarousel_li_6_Template(rf, ctx) { if (rf & 1) {
    const _r126 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 10);
    ɵngcc0.ɵɵelementStart(1, "a", 11);
    ɵngcc0.ɵɵlistener("click", function NglCarousel_li_6_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r126); const i_r124 = ctx.index; const ctx_r125 = ɵngcc0.ɵɵnextContext(); return ctx_r125.onIndicatorClick(i_r124); });
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const image_r123 = ctx.$implicit;
    const i_r124 = ctx.index;
    const ctx_r120 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("isActive", ctx_r120.isActive(i_r124))("image", ctx_r120.getImage(i_r124))("title", image_r123.header);
    ɵngcc0.ɵɵattribute("aria-controls", image_r123.uid);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(image_r123.header);
} }
function NglCheckbox_abbr_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckbox_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 8);
} if (rf & 2) {
    const ctx_r128 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r128.errorId)("nglInternalOutlet", ctx_r128.error);
} }
function NglCheckboxToggle_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 8);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckboxToggle_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r130 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r130.error);
} }
function NglCheckboxOption_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵelement(1, "span", 3);
    ɵngcc0.ɵɵelement(2, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r131 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r131.input.id);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r131.label);
} }
function NglCheckboxOption_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 5);
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r132 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r132.input.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r132.label);
} }
function NglCheckboxGroup_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglCheckboxGroup_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NglCheckboxGroup_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NglCheckboxGroup_div_4_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r136 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r136);
} }
function NglCheckboxGroup_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 10);
} if (rf & 2) {
    const ctx_r135 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r135.errorId)("nglInternalOutlet", ctx_r135.error);
} }
function NglCheckboxGroup_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NglTabs_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r143 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("click", function NglTabs_li_1_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r143); const tab_r141 = ctx.$implicit; const ctx_r142 = ɵngcc0.ɵɵnextContext(); return ctx_r142.select(tab_r141); });
    ɵngcc0.ɵɵelement(1, "a", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r141 = ctx.$implicit;
    const ctx_r139 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("slds-is-active", tab_r141.active);
    ɵngcc0.ɵɵproperty("ngClass", "slds-tabs_" + ctx_r139.variant + "__item")("id", tab_r141.uid + "__item");
    ɵngcc0.ɵɵattribute("aria-controls", tab_r141.uid);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", tab_r141.label)("ngClass", "slds-tabs_" + ctx_r139.variant + "__link");
    ɵngcc0.ɵɵattribute("aria-selected", tab_r141.active)("tabindex", tab_r141.active ? 0 : 0 - 1);
} }
function NglTabs_div_2_ng_container_1_ng_template_1_Template(rf, ctx) { }
function NglTabs_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglTabs_div_2_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r144 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r144 == null ? null : tab_r144.templateRef);
} }
function NglTabs_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtemplate(1, NglTabs_div_2_ng_container_1_Template, 2, 1, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r144 = ctx.$implicit;
    const ctx_r140 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", tab_r144.uid)("ngClass", ctx_r140.tabClass(tab_r144));
    ɵngcc0.ɵɵattribute("aria-labelledby", tab_r144.uid + "__item");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r140.lazy || tab_r144.active);
} }
const _c9 = ["ngl-popover", ""];
function NglPopover_button_0_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r151 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r151.closeTitle);
} }
function NglPopover_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r153 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglPopover_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r153); const ctx_r152 = ɵngcc0.ɵɵnextContext(); return ctx_r152.onClose(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 5);
    ɵngcc0.ɵɵtemplate(2, NglPopover_button_0_span_2_Template, 2, 1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r148 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("slds-button_icon-inverse", ctx_r148.inverseCloseButton);
    ɵngcc0.ɵɵproperty("title", ctx_r148.closeTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r148.closeTitle);
} }
function NglPopover_header_1_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelementContainer(1, 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r154 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r154.labelledby);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r154.header);
} }
function NglPopover_header_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r156 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r156.labelledby);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r156.header);
} }
function NglPopover_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 8);
    ɵngcc0.ɵɵtemplate(1, NglPopover_header_1_div_1_Template, 2, 2, "div", 9);
    ɵngcc0.ɵɵtemplate(2, NglPopover_header_1_ng_template_2_Template, 2, 2, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r155 = ɵngcc0.ɵɵreference(3);
    const ctx_r149 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r149.isTemplateRef(ctx_r149.header))("ngIfElse", _r155);
} }
function NglPopover_footer_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "footer", 14);
} if (rf & 2) {
    const ctx_r150 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r150.footer);
} }
const _c10 = ["ngl-tooltip", ""];
const _c11 = ["nglFormLabel", ""];
function NglFormLabel_abbr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 2);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpicker_ngl_form_help_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 15);
} if (rf & 2) {
    const ctx_r158 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r158.fieldLevelHelpTooltip);
} }
function NglColorpicker__svg_svg_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 16);
} }
function NglColorpicker_p_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "p", 17);
} if (rf & 2) {
    const ctx_r160 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r160.invalidColorLabel);
} }
function NglColorpicker_ng_template_12_ng_container_1_ng_template_1_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 21);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r163 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r163);
} }
function NglColorpicker_ng_template_12_ng_container_2_ng_template_1_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_2_ng_template_1_Template, 0, 0, "ng-template", 21);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r165 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r165);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_ng_template_0_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 21);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r163 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r163);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_ng_template_0_Template(rf, ctx) { }
function NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 21);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r165 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r165);
} }
function NglColorpicker_ng_template_12_ngl_tabset_3_Template(rf, ctx) { if (rf & 1) {
    const _r179 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-tabset", 22);
    ɵngcc0.ɵɵlistener("selectedChange", function NglColorpicker_ng_template_12_ngl_tabset_3_Template_ngl_tabset_selectedChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r179); const ctx_r178 = ɵngcc0.ɵɵnextContext(2); return ctx_r178.defaultSelectedTab = $event.id; });
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_1_Template, 1, 1, "ng-template", 23);
    ɵngcc0.ɵɵtemplate(2, NglColorpicker_ng_template_12_ngl_tabset_3_ng_template_2_Template, 1, 1, "ng-template", 24);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r171 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("selected", ctx_r171.defaultSelectedTab);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", ctx_r171.swatchTabLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", ctx_r171.customTabLabel);
} }
function NglColorpicker_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 18);
    ɵngcc0.ɵɵtemplate(1, NglColorpicker_ng_template_12_ng_container_1_Template, 2, 1, "ng-container", 19);
    ɵngcc0.ɵɵtemplate(2, NglColorpicker_ng_template_12_ng_container_2_Template, 2, 1, "ng-container", 19);
    ɵngcc0.ɵɵtemplate(3, NglColorpicker_ng_template_12_ngl_tabset_3_Template, 3, 3, "ngl-tabset", 20);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r162 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r162.variant);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "swatches");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "custom");
} }
function NglColorpicker_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    const _r181 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-swatches", 25);
    ɵngcc0.ɵɵlistener("hexChange", function NglColorpicker_ng_template_14_Template_ngl_colorpicker_swatches_hexChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r181); const ctx_r180 = ɵngcc0.ɵɵnextContext(); return ctx_r180.onSwatchSelection($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r164 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("hex", ctx_r164.hexCurrent)("swatchColors", ctx_r164.swatchColors);
} }
function NglColorpicker_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r183 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-custom", 26);
    ɵngcc0.ɵɵlistener("hsvChange", function NglColorpicker_ng_template_16_Template_ngl_colorpicker_custom_hsvChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r183); const ctx_r182 = ɵngcc0.ɵɵnextContext(); return ctx_r182.onCustomSelection($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r166 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("hsv", ctx_r166.hsvCurrent);
} }
function NglColorpicker_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    const _r185 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 27);
    ɵngcc0.ɵɵelementStart(1, "button", 28);
    ɵngcc0.ɵɵlistener("click", function NglColorpicker_ng_template_18_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r185); const ctx_r184 = ɵngcc0.ɵɵnextContext(); return ctx_r184.cancel(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 29);
    ɵngcc0.ɵɵlistener("click", function NglColorpicker_ng_template_18_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r185); const ctx_r186 = ɵngcc0.ɵɵnextContext(); return ctx_r186.done(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r168 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r168.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r168.canApply());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r168.submitButtonLabel);
} }
const _c12 = ["nglColorpickerSwatch", ""];
const _c13 = ["rangeIndicator"];
const _c14 = ["rangeIndicatorContainer"];
function NglColorpickerInputs_p_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 13);
    ɵngcc0.ɵɵtext(1, "The color entered is invalid");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpickerInputs_ng_template_26_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 13);
    ɵngcc0.ɵɵtext(1, "The value needs to be an integer from 0-255");
    ɵngcc0.ɵɵelementEnd();
} }
function NglColorpickerInputs_ng_template_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglColorpickerInputs_ng_template_26_p_0_Template, 2, 0, "p", 14);
} if (rf & 2) {
    const ctx_r192 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r192.isRGBValid());
} }
function NglColorpickerSwatches_li_0_Template(rf, ctx) { if (rf & 1) {
    const _r198 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵelementStart(1, "a", 2);
    ɵngcc0.ɵɵlistener("selectedChange", function NglColorpickerSwatches_li_0_Template_a_selectedChange_1_listener() { ɵngcc0.ɵɵrestoreView(_r198); const color_r195 = ctx.$implicit; const ctx_r197 = ɵngcc0.ɵɵnextContext(); return ctx_r197.onSelect(color_r195); });
    ɵngcc0.ɵɵelement(2, "span", 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r195 = ctx.$implicit;
    const i_r196 = ctx.index;
    const ctx_r194 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("selected", ctx_r194.isSelected(color_r195));
    ɵngcc0.ɵɵattribute("tabindex", ctx_r194.activeIndex === i_r196 ? 0 : 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", color_r195);
} }
function NglComboboxOption_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 7);
    ɵngcc0.ɵɵelementEnd();
} }
function NglComboboxOption_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵtext(1, "Current Selection:");
    ɵngcc0.ɵɵelementEnd();
} }
const _c15 = ["overlayOrigin"];
const _c16 = ["cdkOverlay"];
const _c17 = ["dropdown"];
function NglCombobox_div_7_ng_template_6_Template(rf, ctx) { }
function NglCombobox_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelementStart(1, "div", 12);
    ɵngcc0.ɵɵelementStart(2, "span", 13);
    ɵngcc0.ɵɵtext(3, "Loading");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(4, "div", 14);
    ɵngcc0.ɵɵelement(5, "div", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, NglCombobox_div_7_ng_template_6_Template, 0, 0, "ng-template", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r203 = ɵngcc0.ɵɵreference(9);
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r203);
} }
function NglCombobox_ng_template_8_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r212 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 18);
    ɵngcc0.ɵɵlistener("click", function NglCombobox_ng_template_8_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r212); const ctx_r211 = ɵngcc0.ɵɵnextContext(2); return ctx_r211.onClearSelection(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 19);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(2, "span", 13);
    ɵngcc0.ɵɵtext(3, "Remove selected option");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NglCombobox_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglCombobox_ng_template_8_button_0_Template, 4, 0, "button", 17);
} if (rf & 2) {
    const ctx_r204 = ɵngcc0.ɵɵnextContext();
    const _r205 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r204.hasLookupSingleSelection)("ngIfElse", _r205);
} }
function NglCombobox_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 20);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r206 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r206.inputIconRight());
} }
function NglCombobox_ng_template_12_li_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 28);
} if (rf & 2) {
    const d_r217 = ctx.$implicit;
    const ctx_r214 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", d_r217.value)("label", d_r217.label)("disabled", d_r217.disabled)("selected", ctx_r214.isSelected(d_r217.value));
} }
function NglCombobox_ng_template_12_li_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 29);
    ɵngcc0.ɵɵelementStart(1, "div", 30);
    ɵngcc0.ɵɵelementStart(2, "div", 31);
    ɵngcc0.ɵɵelementStart(3, "div", 13);
    ɵngcc0.ɵɵtext(4, "Loading");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(5, "div", 14);
    ɵngcc0.ɵɵelement(6, "div", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NglCombobox_ng_template_12_li_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 32);
    ɵngcc0.ɵɵelementStart(1, "div", 33);
    ɵngcc0.ɵɵelementStart(2, "span", 34);
    ɵngcc0.ɵɵtext(3, "No matches found.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NglCombobox_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    const _r219 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 22, 23);
    ɵngcc0.ɵɵlistener("mousedown", function NglCombobox_ng_template_12_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r219); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(2, "ul", 24);
    ɵngcc0.ɵɵtemplate(3, NglCombobox_ng_template_12_li_3_Template, 1, 4, "li", 25);
    ɵngcc0.ɵɵtemplate(4, NglCombobox_ng_template_12_li_4_Template, 7, 0, "li", 26);
    ɵngcc0.ɵɵtemplate(5, NglCombobox_ng_template_12_li_5_Template, 4, 0, "li", 27);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r208 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r208.dropdownClass());
    ɵngcc0.ɵɵattribute("id", ctx_r208.uid);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r208.data)("ngForTrackBy", ctx_r208.trackByOption);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r208.loadingMore);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r208.hasNoMatches());
} }
const _c18 = [[["input"]]];
const _c19 = ["input"];
const _c20 = ["ngl-datatable", ""];
function NglDatatable_th_2_Template(rf, ctx) { if (rf & 1) {
    const _r227 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 5);
    ɵngcc0.ɵɵlistener("sort", function NglDatatable_th_2_Template_th_sort_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r227); const col_r225 = ctx.$implicit; const ctx_r226 = ɵngcc0.ɵɵnextContext(); return ctx_r226.onColumnSort(col_r225, $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r225 = ctx.$implicit;
    const ctx_r220 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("heading", col_r225.heading)("headingTpl", col_r225.headingTpl == null ? null : col_r225.headingTpl.templateRef)("sortable", col_r225.sortable)("sortOrder", ctx_r220.getColumnSortOrder(col_r225))("ngClass", col_r225.headClass);
} }
function NglDatatable_ng_template_4_ng_template_2_Template(rf, ctx) { }
function NglDatatable_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "td");
    ɵngcc0.ɵɵtemplate(2, NglDatatable_ng_template_4_ng_template_2_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r222 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("colspan", ctx_r222.columns.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r222.noRowsOverlay == null ? null : ctx_r222.noRowsOverlay.templateRef);
} }
function NglDatatable_ng_container_6_tr_1_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 10);
} if (rf & 2) {
    const col_r233 = ctx.$implicit;
    const ctx_r234 = ɵngcc0.ɵɵnextContext();
    const d_r230 = ctx_r234.$implicit;
    const i_r231 = ctx_r234.index;
    ɵngcc0.ɵɵproperty("ngClass", col_r233.cellClass)("row", d_r230)("column", col_r233)("index", i_r231);
} }
function NglDatatable_ng_container_6_tr_1_Template(rf, ctx) { if (rf & 1) {
    const _r236 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 8);
    ɵngcc0.ɵɵlistener("click", function NglDatatable_ng_container_6_tr_1_Template_tr_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r236); const d_r230 = ctx.$implicit; const ctx_r235 = ɵngcc0.ɵɵnextContext(2); return ctx_r235.onRowClick($event, d_r230); });
    ɵngcc0.ɵɵtemplate(1, NglDatatable_ng_container_6_tr_1_td_1_Template, 1, 4, "td", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r229 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r229.columns)("ngForTrackBy", ctx_r229.columnTrackBy);
} }
function NglDatatable_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NglDatatable_ng_container_6_tr_1_Template, 2, 2, "tr", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r223 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r223.data)("ngForTrackBy", ctx_r223.dataTrackBy);
} }
function NglDatatable_div_7_ng_template_1_Template(rf, ctx) { }
function NglDatatable_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, NglDatatable_div_7_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r224 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r224.loadingOverlay.templateRef);
} }
const _c21 = ["nglDatatableHead", ""];
function NglInternalDatatableHeadCell_a_0_Template(rf, ctx) { if (rf & 1) {
    const _r242 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 2);
    ɵngcc0.ɵɵlistener("click", function NglInternalDatatableHeadCell_a_0_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r242); const ctx_r241 = ɵngcc0.ɵɵnextContext(); return ctx_r241.sortChange(); });
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵtext(2, "Sort by:");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵelement(4, "span", 5);
    ɵngcc0.ɵɵelementStart(5, "span", 6);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(6, "svg", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r238 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r238.header);
    ɵngcc0.ɵɵattribute("title", ctx_r238.attrTitle);
} }
function NglInternalDatatableHeadCell_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} if (rf & 2) {
    const ctx_r240 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r240.header);
    ɵngcc0.ɵɵattribute("title", ctx_r240.attrTitle);
} }
const _c22 = ["nglDatatatableCell_", ""];
function NglInternalDatatableCell_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 2);
} if (rf & 2) {
    const ctx_r243 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r243.column.cellTpl.templateRef)("ngTemplateOutletContext", ctx_r243.context);
} }
function NglInternalDatatableCell_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r245 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r245.value);
} }
const _c23 = ["inputEl"];
function NglDatepickerInput_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label", 10);
} if (rf & 2) {
    const ctx_r246 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r246.label);
    ɵngcc0.ɵɵattribute("for", ctx_r246.uid);
} }
function NglDatepickerInput_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    const _r253 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngl-datepicker", 11);
    ɵngcc0.ɵɵlistener("dateChange", function NglDatepickerInput_ng_template_10_Template_ngl_datepicker_dateChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r253); const ctx_r252 = ɵngcc0.ɵɵnextContext(); return ctx_r252.pickerSelection($event); })("nglClickOutside", function NglDatepickerInput_ng_template_10_Template_ngl_datepicker_nglClickOutside_0_listener() { ɵngcc0.ɵɵrestoreView(_r253); const ctx_r254 = ɵngcc0.ɵɵnextContext(); return ctx_r254.closeCalendar(false); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r251 = ɵngcc0.ɵɵnextContext();
    const _r247 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("date", ctx_r251.date)("monthNames", ctx_r251.monthNames)("dayNamesShort", ctx_r251.dayNamesShort)("dayNamesLong", ctx_r251.dayNamesLong)("firstDayOfWeek", ctx_r251.firstDayOfWeek)("showToday", ctx_r251.showToday)("min", ctx_r251.min)("max", ctx_r251.max)("relativeYearFrom", ctx_r251.relativeYearFrom)("relativeYearTo", ctx_r251.relativeYearTo)("todayLabel", ctx_r251.todayLabel)("previousMonthLabel", ctx_r251.previousMonthLabel)("nextMonthLabel", ctx_r251.nextMonthLabel)("dateDisabled", ctx_r251.dateDisabled)("nglClickOutsideIgnore", _r247);
    ɵngcc0.ɵɵattribute("aria-hidden", !ctx_r251.open);
} }
const _c24 = ["nglDatepickerMonth", ""];
function NglDatepickerMonth_tr_0_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r260 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 2);
    ɵngcc0.ɵɵlistener("click", function NglDatepickerMonth_tr_0_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r260); const date_r258 = ctx.$implicit; const ctx_r259 = ɵngcc0.ɵɵnextContext(2); return ctx_r259.onSelect(date_r258); });
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const date_r258 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("slds-is-today", date_r258.today);
    ɵngcc0.ɵɵproperty("isActive", date_r258.active)("nglDay", date_r258)("nglDaySelected", date_r258.selected)("nglDayDisabled", date_r258.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(date_r258.day);
} }
function NglDatepickerMonth_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, NglDatepickerMonth_tr_0_td_1_Template, 3, 7, "td", 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r256 = ctx.$implicit;
    const ctx_r255 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", week_r256)("ngForTrackBy", ctx_r255.dateTrackBy);
} }
function NglDatepicker_tbody_18_Template(rf, ctx) { if (rf & 1) {
    const _r264 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tbody", 13);
    ɵngcc0.ɵɵlistener("selectDate", function NglDatepicker_tbody_18_Template_tbody_selectDate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r264); const ctx_r263 = ɵngcc0.ɵɵnextContext(); return ctx_r263.select($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r261 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("year", ctx_r261.current.year)("month", ctx_r261.current.month)("day", ctx_r261.current.day)("selected", ctx_r261._date)("firstDayOfWeek", ctx_r261.firstDayOfWeek)("minDate", ctx_r261.minDate)("maxDate", ctx_r261.maxDate)("dateDisabled", ctx_r261.dateDisabled);
} }
function NglDatepicker_button_19_Template(rf, ctx) { if (rf & 1) {
    const _r266 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵlistener("click", function NglDatepicker_button_19_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r266); const ctx_r265 = ɵngcc0.ɵɵnextContext(); return ctx_r265.selectToday(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r262 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r262.todayLabel);
} }
const _c25 = ["nglWeekdays", ""];
function NglDatepickerWeekdays_th_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 1);
    ɵngcc0.ɵɵelementStart(1, "abbr", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r268 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("id", day_r268.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", day_r268.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r268.label);
} }
function NglDatepickerYear_option_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const yr_r270 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", yr_r270);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(yr_r270);
} }
function NglDynamicIcon_ngl_dynamic_icon_ellie_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-ellie", 3);
} if (rf & 2) {
    const ctx_r271 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("alternativeText", ctx_r271.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_eq_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-eq", 4);
} if (rf & 2) {
    const ctx_r272 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("option", ctx_r272.option)("alternativeText", ctx_r272.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_score_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-score", 4);
} if (rf & 2) {
    const ctx_r273 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("option", ctx_r273.option)("alternativeText", ctx_r273.alternativeText);
} }
function NglDynamicIcon_ngl_dynamic_icon_waffle_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-dynamic-icon-waffle", 3);
} if (rf & 2) {
    const ctx_r274 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("alternativeText", ctx_r274.alternativeText);
} }
function NglDynamicIconEllie_span_42_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 43);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r275 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r275.alternativeText);
} }
function NglDynamicIconEq_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r276 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r276.alternativeText);
} }
function NglDynamicIconScore_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r277 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r277.alternativeText);
} }
function NglDynamicIconWaffle_span_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r278 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r278.alternativeText);
} }
function NglFile_figcaption_2_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "ngl-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r280 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("iconName", ctx_r280.iconName);
} }
function NglFile_figcaption_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "figcaption", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, NglFile_figcaption_2_div_2_Template, 2, 1, "div", 3);
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵelement(4, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r279 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r279.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r279.text)("nglInternalOutlet", ctx_r279.text);
} }
function NglFileUpload_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} if (rf & 2) {
    const ctx_r281 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r281.uid + "-primary-label")("nglInternalOutlet", ctx_r281.label);
} }
function NglFileUpload_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 11);
} if (rf & 2) {
    const ctx_r282 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r282.uid + "-error")("nglInternalOutlet", ctx_r282.error);
} }
function NglInput_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 4);
} if (rf & 2) {
    const ctx_r283 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r283.fieldLevelHelpTooltip);
} }
function NglInput_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} if (rf & 2) {
    const ctx_r284 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r284.errorId)("nglInternalOutlet", ctx_r284.error);
} }
function NglModal_button_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r291 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r291.closeButtonAssistiveText);
} }
function NglModal_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r293 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function NglModal_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r293); const ctx_r292 = ɵngcc0.ɵɵnextContext(); return ctx_r292.close(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 11);
    ɵngcc0.ɵɵtemplate(2, NglModal_button_3_span_2_Template, 2, 1, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r285 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r285.closeButtonAssistiveText);
} }
function NglModal_ng_template_4_h2_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r294 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r294.headingId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r294.header);
} }
function NglModal_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglModal_ng_template_4_h2_0_Template, 2, 2, "h2", 14);
} if (rf & 2) {
    const ctx_r287 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r287.header);
} }
function NglModal_6_ng_template_0_Template(rf, ctx) { }
const _c26 = function (a0) { return { id: a0 }; };
function NglModal_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglModal_6_ng_template_0_Template, 0, 0, "ng-template", 16);
} if (rf & 2) {
    const ctx_r288 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r288.headerTpl.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c26, ctx_r288.headingId));
} }
function NglModal_p_7_ng_template_1_Template(rf, ctx) { }
function NglModal_p_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 17);
    ɵngcc0.ɵɵtemplate(1, NglModal_p_7_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r289 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r289.taglineTpl.templateRef);
} }
function NglModal_footer_10_ng_template_1_Template(rf, ctx) { }
function NglModal_footer_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "footer", 19);
    ɵngcc0.ɵɵtemplate(1, NglModal_footer_10_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r290 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r290.modalFooterClass());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r290.footer.templateRef);
} }
function NglToast_ngl_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 4);
} if (rf & 2) {
    const ctx_r298 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("iconName", ctx_r298.iconName);
} }
function NglToast_button_5_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r300 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r300.closeButtonAssistiveText);
} }
function NglToast_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r302 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function NglToast_button_5_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); const ctx_r301 = ɵngcc0.ɵɵnextContext(); return ctx_r301.close("button", $event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 6);
    ɵngcc0.ɵɵtemplate(2, NglToast_button_5_span_2_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r299 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r299.closeButtonAssistiveText);
} }
function NglPagination_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r307 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r307); const ctx_r306 = ɵngcc0.ɵɵnextContext(); return ctx_r306.goto(1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r303 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", !ctx_r303.hasPrevious());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r303.firstText);
} }
function NglPagination_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r310 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r310); const page_r308 = ctx.$implicit; const ctx_r309 = ɵngcc0.ɵɵnextContext(); return ctx_r309.goto(page_r308.number); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const page_r308 = ctx.$implicit;
    const ctx_r304 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", "slds-button_" + (page_r308.number === ctx_r304.current ? "brand" : "neutral"))("disabled", page_r308.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(page_r308.number);
} }
function NglPagination_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r312 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NglPagination_button_7_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r312); const ctx_r311 = ɵngcc0.ɵɵnextContext(); return ctx_r311.goto(ctx_r311.totalPages); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r305 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", !ctx_r305.hasNext());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r305.lastText);
} }
function NglPill_span_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 7);
} if (rf & 2) {
    const ctx_r318 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r318.pillIcon);
} }
function NglPill_span_0_ng_template_2_ngl_icon_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-icon", 10);
} if (rf & 2) {
    const ctx_r321 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("iconName", ctx_r321.icon);
} }
function NglPill_span_0_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-avatar", 11);
} if (rf & 2) {
    const ctx_r323 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("src", ctx_r323.avatar);
} }
function NglPill_span_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NglPill_span_0_ng_template_2_ngl_icon_0_Template, 1, 1, "ngl-icon", 8);
    ɵngcc0.ɵɵtemplate(1, NglPill_span_0_ng_template_2_ng_template_1_Template, 1, 1, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const _r322 = ɵngcc0.ɵɵreference(2);
    const ctx_r320 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r320.icon)("ngIfElse", _r322);
} }
function NglPill_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtemplate(1, NglPill_span_0_ng_container_1_Template, 1, 1, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(2, NglPill_span_0_ng_template_2_Template, 3, 2, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r319 = ɵngcc0.ɵɵreference(3);
    const ctx_r313 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r313.isTemplateRef(ctx_r313.pillIcon))("ngIfElse", _r319);
} }
function NglPill_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NglPill_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function NglPill_button_4_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span", 16);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r324 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r324.removeTitle);
} }
function NglPill_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r326 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 13);
    ɵngcc0.ɵɵlistener("click", function NglPill_button_4_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r326); const ctx_r325 = ɵngcc0.ɵɵnextContext(); return ctx_r325.onRemove($event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 14);
    ɵngcc0.ɵɵtemplate(2, NglPill_button_4_span_2_Template, 2, 1, "span", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r317 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r317.removeTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r317.removeTitle);
} }
const _c27 = [[["a"]], "*"];
const _c28 = ["a", "*"];
const _c29 = ["nglPillAction", ""];
function NglRadioGroup_abbr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "abbr", 7);
    ɵngcc0.ɵɵtext(1, "*");
    ɵngcc0.ɵɵelementEnd();
} }
function NglRadioGroup_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NglRadioGroup_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NglRadioGroup_div_4_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r330 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r330);
} }
function NglRadioGroup_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r329 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r329.errorId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r329.error);
} }
function NglRadioGroup_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NglRadioOption_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵelement(1, "span", 3);
    ɵngcc0.ɵɵelement(2, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r333 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r333.input.id);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r333.label);
} }
function NglRadioOption_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 5);
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r334 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("for", ctx_r334.input.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r334.label);
} }
const _c30 = ["t"];
function NglRating_ng_template_0__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 4);
} if (rf & 2) {
    const fill_r338 = ɵngcc0.ɵɵnextContext().fill;
    const ctx_r339 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r339.colorOn)("left", fill_r338 - 100, "%");
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r339.icon)("ngClass", ctx_r339.size ? "slds-icon_" + ctx_r339.size : "")("xPos", 100 - fill_r338 + "%");
} }
function NglRating_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 2);
    ɵngcc0.ɵɵtemplate(1, NglRating_ng_template_0__svg_svg_1_Template, 1, 7, "svg", 3);
} if (rf & 2) {
    const fill_r338 = ctx.fill;
    const ctx_r336 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", fill_r338 === 100 ? ctx_r336.colorOn : ctx_r336.colorOff);
    ɵngcc0.ɵɵproperty("nglIconName", ctx_r336.icon)("ngClass", ctx_r336.size ? "slds-icon_" + ctx_r336.size : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", fill_r338 > 0 && fill_r338 < 100);
} }
function NglRating_div_2_ng_template_1_Template(rf, ctx) { }
const _c31 = function (a0, a1, a2) { return { $implicit: a0, index: a1, fill: a2 }; };
function NglRating_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r345 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵlistener("click", function NglRating_div_2_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r345); const r_r341 = ctx.$implicit; const ctx_r344 = ɵngcc0.ɵɵnextContext(); return ctx_r344.update(r_r341); })("mouseenter", function NglRating_div_2_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r345); const r_r341 = ctx.$implicit; const ctx_r346 = ɵngcc0.ɵɵnextContext(); return ctx_r346.enter(r_r341); });
    ɵngcc0.ɵɵtemplate(1, NglRating_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const r_r341 = ctx.$implicit;
    const i_r342 = ctx.index;
    const ctx_r337 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r337._template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(2, _c31, r_r341 <= ctx_r337.currentRate, i_r342, ctx_r337.getFill(r_r341)));
} }
function NglExpandableSection_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r351 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function NglExpandableSection_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r351); const ctx_r350 = ɵngcc0.ɵɵnextContext(); return ctx_r350.toggle($event); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 5);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(2, "span", 6);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r347 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r347.uid)("aria-expanded", ctx_r347.expanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r347.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r347.title);
} }
function NglExpandableSection_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r349 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r349.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r349.title);
} }
function NglSelect_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 5);
} if (rf & 2) {
    const ctx_r352 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r352.fieldLevelHelpTooltip);
} }
function NglSelect_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 6);
} if (rf & 2) {
    const ctx_r353 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r353.errorId)("nglInternalOutlet", ctx_r353.error);
} }
function NglSlider_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r354 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx_r354.label);
} }
function NglSlider_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 10);
} if (rf & 2) {
    const ctx_r355 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r355.uid + "-error")("nglInternalOutlet", ctx_r355.error);
} }
function NglSpinner_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r356 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r356.alternativeText);
} }
function NglTextarea_ngl_form_help_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngl-form-help", 5);
} if (rf & 2) {
    const ctx_r357 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("content", ctx_r357.fieldLevelHelpTooltip);
} }
function NglTextarea_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r358 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r358.errorId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r358.error);
} }
let HostService = class HostService {
    constructor(rendererFactory2) {
        this.classMap = {};
        this.styleMap = {};
        this.renderer = rendererFactory2.createRenderer(null, null);
    }
    updateClass({ nativeElement }, classMap) {
        const newClassMap = {};
        const remove = Object.assign({}, this.classMap);
        Object.keys(classMap).filter(i => classMap[i]).forEach(i => {
            newClassMap[i] = true;
            if (!this.classMap[i]) {
                this.renderer.addClass(nativeElement, i);
            }
            if (remove[i]) {
                remove[i] = false;
            }
        });
        Object.keys(remove).filter(i => remove[i]).forEach(i => this.renderer.removeClass(nativeElement, i));
        this.classMap = newClassMap;
    }
    updateStyle({ nativeElement }, styleMap) {
        const remove = Object.assign({}, this.styleMap);
        Object.keys(styleMap).filter(i => styleMap[i]).forEach(i => {
            if (styleMap[i] !== false) {
                this.renderer.setStyle(nativeElement, i, styleMap[i]);
            }
            if (remove[i]) {
                delete remove[i];
            }
        });
        Object.keys(remove).forEach(i => this.renderer.removeStyle(nativeElement, i));
        this.styleMap = styleMap;
    }
};
HostService.ɵfac = function HostService_Factory(t) { return new (t || HostService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)); };
HostService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HostService, factory: HostService.ɵfac });
HostService.ctorParameters = () => [
    { type: RendererFactory2 }
];
HostService = __decorate([ __metadata("design:paramtypes", [RendererFactory2])
], HostService);

// Check if given value is integer. Cast strings as potential integers as well.
// See: http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript
function isInt(value) {
    if (isNaN(value)) {
        return false;
    }
    const x = parseFloat(value);
    // tslint:disable-next-line:no-bitwise
    return (x | 0) === x;
}
// Similar to `lodash.isobject`
function isObject(value) {
    const type = typeof value;
    return !!value && (type === 'object' || type === 'function');
}
// Generate a unique id (unique within the entire client session).
// Useful for temporary DOM ids.
let idCounter = 0;
function uniqueId(prefix = 'uid') {
    return `ngl_${prefix}_${++idCounter}`;
}
function replaceClass(instance, oldClass, newClass) {
    if (oldClass && oldClass !== newClass) {
        setClass(instance, oldClass, false);
    }
    if (newClass) {
        setClass(instance, newClass, true);
    }
}
function setClass(instance, klasses, isAdd) {
    if (klasses) {
        (Array.isArray(klasses) ? klasses : [klasses]).forEach(k => {
            instance.renderer[isAdd ? 'addClass' : 'removeClass'](instance.element.nativeElement, k);
        });
    }
}
function ngClassCombine(ngClasses, customClasses) {
    if (!ngClasses) {
        return customClasses;
    }
    // Convert string and Set to array
    if (typeof ngClasses === 'string') {
        ngClasses = ngClasses.split(/\s+/);
    }
    else if (ngClasses instanceof Set) {
        const a = [];
        ngClasses.forEach(v => a.push(v));
        ngClasses = a;
    }
    // Convert array to object
    if (Array.isArray(ngClasses)) {
        ngClasses = ngClasses.reduce((o, klass) => {
            o[klass] = true;
            return o;
        }, {});
    }
    return Object.assign(Object.assign({}, ngClasses), customClasses);
}
/**
   * Check whether value is currently selected.
   *
   * @param selection The value(s) currently selected
   * @param value The value in test, whether is (part of) selection or not
   * @param multiple Whether selections can be have multiple values
   */
function isOptionSelected(value, selection, multiple) {
    // Multiple
    if (multiple) {
        if (!selection) {
            return false;
        }
        return Array.isArray(selection) ? selection.indexOf(value) > -1 : !!selection[value];
    }
    // Single
    return value === selection;
}
function addOptionToSelection(value, selection, multiple) {
    let next;
    if (multiple) {
        if (!selection) {
            selection = [];
        }
        if (Array.isArray(selection)) {
            // Remove if already there or add to selection
            const index = selection.indexOf(value);
            next = index > -1
                ? [...selection.slice(0, index), ...selection.slice(index + 1)]
                : [...selection, value];
        }
        else {
            next = Object.assign({}, selection, { [value]: !selection[value] });
        }
    }
    else {
        next = selection === value ? null : value;
    }
    return next;
}
function menuItemScroll(container, domItem, scrollPadding = 4) {
    if (domItem.offsetHeight - container.scrollTop + domItem.offsetTop >=
        container.offsetHeight) {
        container.scrollTop =
            domItem.offsetHeight +
                domItem.offsetTop -
                container.offsetHeight +
                scrollPadding;
    }
    else if (domItem.offsetTop <= container.scrollTop) {
        container.scrollTop = domItem.offsetTop - scrollPadding;
    }
}
function trapEvent(event) {
    if (!event) {
        return;
    }
    event.preventDefault();
    event.stopPropagation();
}

function normalizeIconName(iconName) {
    return iconName.indexOf(':') > -1 ? iconName : `utility:${iconName}`;
}

let NglIcon = class NglIcon {
    constructor(el, hostService) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The appearance of a `utility` icon.
         */
        this.variant = 'default';
    }
    set iconName(iconName) {
        this._iconName = normalizeIconName(iconName);
    }
    get iconName() {
        return this._iconName;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    svgClasses() {
        const [category] = this.iconName.split(':');
        const isUtility = category === 'utility';
        const isDefaultOrInverse = this.variant === 'default' || this.variant === 'inverse';
        const classes = {
            [`slds-icon_${this.size}`]: !!this.size && this.size !== 'medium',
            [`slds-icon-text-${isDefaultOrInverse ? 'default' : this.variant}`]: isDefaultOrInverse ?
                (this.variant === 'default' ? isUtility : !isUtility)
                : !!this.variant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const [category, icon] = this.iconName.split(':');
        const kebabCaseName = icon.replace(/_/g, '-');
        this.hostService.updateClass(this.el, {
            [`slds-icon_container`]: category !== 'utility',
            [`slds-icon_container_circle`]: category === 'action',
            [`slds-icon-${category}-${kebabCaseName}`]: category !== 'utility' && category !== 'doctype',
        });
    }
};
NglIcon.ɵfac = function NglIcon_Factory(t) { return new (t || NglIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglIcon, selectors: [["ngl-icon"], ["", "ngl-icon", ""]], inputs: { variant: "variant", iconName: "iconName", size: "size", alternativeText: "alternativeText", svgClass: "svgClass" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 3, consts: [[1, "slds-icon", 3, "nglIconName", "ngClass"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglIcon_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglIconName", ctx.iconName)("ngClass", ctx.svgClasses());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: function () { return [NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgIf]; }, encapsulation: 2, changeDetection: 0 });
NglIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglIcon.prototype, "iconName", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglIcon.prototype, "svgClass", void 0);
NglIcon = __decorate([ __metadata("design:paramtypes", [ElementRef, HostService])
], NglIcon);

/** Injection token that can be used to specify default options. */
const NGL_ICON_CONFIG = new InjectionToken('ngl-icon-config');
/**
 * Configuration service for the icons components.
 */
class NglIconConfig {
    constructor() {
        /**
         * The path to LDS assets
         */
        this.svgPath = 'assets/icons';
    }
}

let NglIconSvg = class NglIconSvg {
    constructor(defaultConfig, el, renderer) {
        this.xPos = '0';
        renderer.setAttribute(el.nativeElement, 'aria-hidden', 'true');
        const config = Object.assign(Object.assign({}, new NglIconConfig()), defaultConfig);
        this.path = config.svgPath;
    }
    set iconName(iconName) {
        const [category, icon] = normalizeIconName(iconName).split(':');
        this.iconPath = `${this.path}/${category}-sprite/svg/symbols.svg#${icon}`;
    }
};
NglIconSvg.ɵfac = function NglIconSvg_Factory(t) { return new (t || NglIconSvg)(ɵngcc0.ɵɵdirectiveInject(NGL_ICON_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglIconSvg.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglIconSvg, selectors: [["svg", "nglIconName", ""]], inputs: { xPos: "xPos", iconName: ["nglIconName", "iconName"] }, attrs: _c1, decls: 1, vars: 2, template: function NglIconSvg_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "use");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("href", ctx.iconPath, null, "xlink")("x", ctx.xPos);
    } }, encapsulation: 2, changeDetection: 0 });
NglIconSvg.ctorParameters = () => [
    { type: NglIconConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_ICON_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('nglIconName'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglIconSvg.prototype, "iconName", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglIconSvg.prototype, "xPos", void 0);
NglIconSvg = __decorate([ __param(0, Optional()), __param(0, Inject(NGL_ICON_CONFIG)),
    __metadata("design:paramtypes", [NglIconConfig,
        ElementRef,
        Renderer2])
], NglIconSvg);

const NGL_ICON_DIRECTIVES = [
    NglIcon,
    NglIconSvg,
];
let NglIconsModule = class NglIconsModule {
};
NglIconsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglIconsModule });
NglIconsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglIconsModule_Factory(t) { return new (t || NglIconsModule)(); }, imports: [[CommonModule]] });

let NglInternalOutlet = class NglInternalOutlet {
    isTemplate() {
        return this.nglInternalOutlet instanceof TemplateRef;
    }
};
NglInternalOutlet.ɵfac = function NglInternalOutlet_Factory(t) { return new (t || NglInternalOutlet)(); };
NglInternalOutlet.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglInternalOutlet, selectors: [["", "nglInternalOutlet", ""]], inputs: { nglInternalOutlet: "nglInternalOutlet", nglInternalOutletContext: "nglInternalOutletContext" }, attrs: _c2, decls: 3, vars: 2, consts: [[3, "ngIf", "ngIfElse"], ["str", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglInternalOutlet_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglInternalOutlet_ng_template_0_Template, 1, 2, "ng-template", 0);
        ɵngcc0.ɵɵtemplate(1, NglInternalOutlet_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r85 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTemplate())("ngIfElse", _r85);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalOutlet.prototype, "nglInternalOutlet", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalOutlet.prototype, "nglInternalOutletContext", void 0);

let NglInternalOutletModule = class NglInternalOutletModule {
};
NglInternalOutletModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglInternalOutletModule });
NglInternalOutletModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglInternalOutletModule_Factory(t) { return new (t || NglInternalOutletModule)(); }, imports: [[CommonModule]] });

let NglAccordionSection = class NglAccordionSection {
    constructor(templateRef) {
        this.templateRef = templateRef;
        /**
         * The unique name to use with the `activeName` of the accordion component.
         */
        this.name = uniqueId('accordion-section');
    }
};
NglAccordionSection.ɵfac = function NglAccordionSection_Factory(t) { return new (t || NglAccordionSection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglAccordionSection.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglAccordionSection, selectors: [["", "nglAccordionSection", ""]], inputs: { name: "name", label: "label", labelContext: "labelContext" } });
NglAccordionSection.ctorParameters = () => [
    { type: TemplateRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "labelContext", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "name", void 0);
NglAccordionSection = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglAccordionSection);

function propDecoratorFactory(name, fallback) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${name} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                return this[privatePropName];
            },
            set(value) {
                this[privatePropName] = fallback(value);
            }
        });
    }
    return propDecorator;
}
function toBoolean(value) {
    return coerceBooleanProperty(value);
}
function InputBoolean() {
    return propDecoratorFactory('InputBoolean', toBoolean);
}
function toNumber(value, fallbackValue = 0) {
    return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function InputNumber() {
    return propDecoratorFactory('InputNumber', toNumber);
}

let NglAccordion = class NglAccordion {
    constructor(element, renderer) {
        this.activeNameChange = new EventEmitter();
        /**
         * Whether we allow multiple sections open at a time.
         */
        this.multiple = false;
        renderer.addClass(element.nativeElement, 'slds-accordion');
    }
    toggle(section) {
        const active = addOptionToSelection(section.name, this.activeName, this.multiple);
        this.activeNameChange.emit(active);
    }
    isActive(section) {
        return isOptionSelected(section.name, this.activeName, this.multiple);
    }
};
NglAccordion.ɵfac = function NglAccordion_Factory(t) { return new (t || NglAccordion)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglAccordion.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglAccordion, selectors: [["ngl-accordion"], ["", "ngl-accordion", ""]], contentQueries: function NglAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglAccordionSection, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sections = _t);
    } }, inputs: { multiple: "multiple", activeName: "activeName" }, outputs: { activeNameChange: "activeNameChange" }, decls: 1, vars: 1, consts: [["nglAccordionItem", "", 3, "isActive", "section", "toggle", 4, "ngFor", "ngForOf"], ["nglAccordionItem", "", 3, "isActive", "section", "toggle"]], template: function NglAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglAccordion_li_0_Template, 1, 2, "li", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.sections);
    } }, directives: function () { return [ɵngcc1.NgForOf, NglAccordionItem]; }, encapsulation: 2, changeDetection: 0 });
NglAccordion.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "activeName", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "activeNameChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "multiple", void 0);
__decorate([
    ContentChildren(NglAccordionSection),
    __metadata("design:type", QueryList)
], NglAccordion.prototype, "sections", void 0);
NglAccordion = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglAccordion);

let NglAccordionItem = class NglAccordionItem {
    constructor(element, renderer) {
        this.toggle = new EventEmitter();
        this.uid = uniqueId('accordion-item');
        renderer.addClass(element.nativeElement, 'slds-accordion__list-item');
    }
    onToggle() {
        this.toggle.emit();
    }
};
NglAccordionItem.ɵfac = function NglAccordionItem_Factory(t) { return new (t || NglAccordionItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglAccordionItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglAccordionItem, selectors: [["li", "nglAccordionItem", ""]], inputs: { isActive: "isActive", section: "section" }, outputs: { toggle: "toggle" }, attrs: _c3, decls: 8, vars: 11, consts: [[1, "slds-accordion__section"], [1, "slds-accordion__summary"], [1, "slds-accordion__summary-heading", 3, "click"], [1, "slds-button", "slds-button_reset", "slds-accordion__summary-action"], ["nglIconName", "utility:switch", 1, "slds-accordion__summary-action-icon", "slds-button__icon", "slds-button__icon_left"], [1, "slds-truncate", 3, "nglInternalOutlet", "nglInternalOutletContext"], [1, "slds-accordion__content", 3, "id"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function NglAccordionItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "h3", 2);
        ɵngcc0.ɵɵlistener("click", function NglAccordionItem_Template_h3_click_2_listener() { return ctx.onToggle(); });
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(4, "svg", 4);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 6);
        ɵngcc0.ɵɵtemplate(7, NglAccordionItem_ng_container_7_Template, 2, 1, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-is-open", ctx.isActive);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-controls", ctx.uid)("aria-expanded", ctx.isActive);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.section.label)("nglInternalOutletContext", ɵngcc0.ɵɵpureFunction1(9, _c4, ctx.section.labelContext));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid);
        ɵngcc0.ɵɵattribute("hidden", ctx.isActive ? null : "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isActive);
    } }, directives: [NglIconSvg,
        NglInternalOutlet, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglAccordionItem.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NglAccordionItem.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", NglAccordionSection)
], NglAccordionItem.prototype, "section", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAccordionItem.prototype, "toggle", void 0);
NglAccordionItem = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglAccordionItem);

const DIRECTIVES = [
    NglAccordion,
    NglAccordionSection,
];
let NglAccordionModule = class NglAccordionModule {
};
NglAccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglAccordionModule });
NglAccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglAccordionModule_Factory(t) { return new (t || NglAccordionModule)(); }, imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

class NglCommonNotify {
    constructor(element, renderer, cd, type) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.closeButtonAssistiveText = 'Close';
        /**
         * Triggered by close button or duration timeout.
         */
        // tslint:disable-next-line:no-output-rename
        this.closeEventEmitter = new EventEmitter();
        this.currentTimeout = null;
        this.renderer.addClass(this.element.nativeElement, 'slds-notify');
        this.renderer.addClass(this.element.nativeElement, `slds-notify_${type}`);
        this.toggleThemeClass(true, this.variant);
        this.renderer.setAttribute(this.element.nativeElement, 'role', type === 'toast' ? 'status' : 'alert');
    }
    /**
     * The type of alert.
     */
    set variant(variant) {
        this.toggleThemeClass(false, this.variant);
        this._variant = variant;
        this.toggleThemeClass(true, this.variant);
    }
    get variant() {
        return this._variant || 'info';
    }
    /**
     * The number of milliseconds after which, the close event will be triggered with an emitted reason of `'timeout'`.
     */
    set duration(duration) {
        this.clearTimeout();
        if (isInt(duration) && duration >= 0) {
            this.currentTimeout = setTimeout(() => this.close('timeout'), +duration);
        }
    }
    set dismissible(dismissible) {
        this._dismissible = dismissible;
        this.cd.markForCheck();
    }
    get dismissible() {
        return this._dismissible;
    }
    close(reason, $event) {
        this.clearTimeout();
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        this.closeEventEmitter.emit(reason);
    }
    ngOnDestroy() {
        this.clearTimeout();
    }
    clearTimeout() {
        if (this.currentTimeout !== null) {
            clearTimeout(this.currentTimeout);
            this.currentTimeout = null;
        }
    }
    toggleThemeClass(isAdd, klass) {
        if (!klass) {
            return;
        }
        const el = this.element.nativeElement;
        this.renderer[isAdd ? 'addClass' : 'removeClass'](el, `slds-theme_${klass}`);
    }
}
NglCommonNotify.ɵfac = function NglCommonNotify_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NglCommonNotify.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglCommonNotify, inputs: { closeButtonAssistiveText: "closeButtonAssistiveText", variant: "variant", duration: "duration", iconName: "iconName", assistiveText: "assistiveText" }, outputs: { closeEventEmitter: "close" } });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglCommonNotify.prototype, "variant", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCommonNotify.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "assistiveText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "closeButtonAssistiveText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglCommonNotify.prototype, "duration", null);
__decorate([
    Output('close'),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "closeEventEmitter", void 0);

let NglAlert = class NglAlert extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'alert');
    }
};
NglAlert.ɵfac = function NglAlert_Factory(t) { return new (t || NglAlert)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglAlert.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglAlert, selectors: [["ngl-alert"]], exportAs: ["nglAlert"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 6, vars: 3, consts: [[1, "slds-assistive-text"], ["class", "slds-m-right_x-small", "size", "x-small", "variant", "", 3, "iconName", 4, "ngIf"], [1, "slds-notify__content"], ["class", "slds-button slds-button_icon slds-notify__close slds-button_icon-inverse", "type", "button", 3, "click", 4, "ngIf"], ["size", "x-small", "variant", "", 1, "slds-m-right_x-small", 3, "iconName"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-notify__close", "slds-button_icon-inverse", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"]], template: function NglAlert_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglAlert_ngl_icon_2_Template, 1, 1, "ngl-icon", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglAlert_button_5_Template, 3, 1, "button", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.assistiveText || ctx.variant);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dismissible);
    } }, directives: [ɵngcc1.NgIf, NglIcon,
        NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglAlert.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglAlert = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglAlert);

class NglCommonNotifyClose {
    constructor(host) {
        this.host = host;
        this.host.dismissible = true;
    }
    set dismissible(dismissible) {
        this.host.dismissible = dismissible;
    }
}
NglCommonNotifyClose.ɵfac = function NglCommonNotifyClose_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NglCommonNotifyClose.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglCommonNotifyClose, inputs: { dismissible: "dismissible" } });
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglCommonNotifyClose.prototype, "dismissible", null);

let NglAlertClose = class NglAlertClose extends NglCommonNotifyClose {
    constructor(alert) {
        super(alert);
    }
};
NglAlertClose.ɵfac = function NglAlertClose_Factory(t) { return new (t || NglAlertClose)(ɵngcc0.ɵɵdirectiveInject(NglAlert)); };
NglAlertClose.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglAlertClose, selectors: [["ngl-alert", "close", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NglAlertClose.ctorParameters = () => [
    { type: NglAlert }
];
NglAlertClose = __decorate([ __metadata("design:paramtypes", [NglAlert])
], NglAlertClose);

const NGL_ALERT_DIRECTIVES = [
    NglAlert,
    NglAlertClose,
];
let NglAlertModule = class NglAlertModule {
};
NglAlertModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglAlertModule });
NglAlertModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglAlertModule_Factory(t) { return new (t || NglAlertModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglAvatar = class NglAvatar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.hostService = hostService;
        this.src = '';
        this.alternativeText = '';
        this.fallbackIconName = 'standard:user';
        this.error = new EventEmitter();
        this._imgError = false;
        renderer.addClass(element.nativeElement, 'slds-avatar');
    }
    fallbackIconClass() {
        const [category, icon] = this.fallbackIconName.split(':');
        return `slds-icon-${category}-${icon}`;
    }
    get shouldShowImage() {
        return this.src && !this._imgError;
    }
    onImgError() {
        this._imgError = true;
        this.error.emit();
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-avatar_${this.size || 'medium'}`]: true,
            [`slds-avatar_${this.variant || 'rectangle'}`]: true,
        });
    }
};
NglAvatar.ɵfac = function NglAvatar_Factory(t) { return new (t || NglAvatar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglAvatar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglAvatar, selectors: [["ngl-avatar"]], hostVars: 1, hostBindings: function NglAvatar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("title", ctx.alternativeText);
    } }, inputs: { src: "src", alternativeText: "alternativeText", fallbackIconName: "fallbackIconName", size: "size", variant: "variant", initials: "initials" }, outputs: { error: "error" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 2, consts: [[3, "src", "alt", "error", 4, "ngIf", "ngIfElse"], ["template_initials", ""], [3, "src", "alt", "error"], [1, "slds-avatar__initials", 3, "ngClass"]], template: function NglAvatar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglAvatar_img_0_Template, 1, 2, "img", 0);
        ɵngcc0.ɵɵtemplate(1, NglAvatar_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r100 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowImage)("ngIfElse", _r100);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglAvatar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "src", void 0);
__decorate([
    HostBinding('attr.title'),
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "initials", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "fallbackIconName", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "error", void 0);
NglAvatar = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglAvatar);

let NglAvatarModule = class NglAvatarModule {
};
NglAvatarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglAvatarModule });
NglAvatarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglAvatarModule_Factory(t) { return new (t || NglAvatarModule)(); }, imports: [[CommonModule]] });

let NglBadge = class NglBadge {
};
NglBadge.ɵfac = function NglBadge_Factory(t) { return new (t || NglBadge)(); };
NglBadge.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglBadge, selectors: [["ngl-badge"]], inputs: { theme: "theme" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[1, "slds-badge", 3, "ngClass"]], template: function NglBadge_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.theme ? "slds-theme_" + ctx.theme : "");
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglBadge.prototype, "theme", void 0);

let NglBadgesModule = class NglBadgesModule {
};
NglBadgesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglBadgesModule });
NglBadgesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglBadgesModule_Factory(t) { return new (t || NglBadgesModule)(); }, imports: [[CommonModule]] });

let NglBreadcrumb = class NglBreadcrumb {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglBreadcrumb.ɵfac = function NglBreadcrumb_Factory(t) { return new (t || NglBreadcrumb)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglBreadcrumb.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglBreadcrumb, selectors: [["", "nglBreadcrumb", ""]] });
NglBreadcrumb.ctorParameters = () => [
    { type: TemplateRef }
];
NglBreadcrumb = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglBreadcrumb);

let NglBreadcrumbs = class NglBreadcrumbs {
};
NglBreadcrumbs.ɵfac = function NglBreadcrumbs_Factory(t) { return new (t || NglBreadcrumbs)(); };
NglBreadcrumbs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglBreadcrumbs, selectors: [["ngl-breadcrumbs"]], contentQueries: function NglBreadcrumbs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglBreadcrumb, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.breadcrumbs = _t);
    } }, inputs: { assistiveText: "assistiveText" }, decls: 3, vars: 2, consts: [["role", "navigation"], [1, "slds-breadcrumb", "slds-list_horizontal", "slds-wrap"], ["class", "slds-breadcrumb__item", 4, "ngFor", "ngForOf"], [1, "slds-breadcrumb__item"], [3, "ngTemplateOutlet"]], template: function NglBreadcrumbs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "ol", 1);
        ɵngcc0.ɵɵtemplate(2, NglBreadcrumbs_li_2_Template, 2, 1, "li", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.assistiveText);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.breadcrumbs);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglBreadcrumbs.prototype, "assistiveText", void 0);
__decorate([
    ContentChildren(NglBreadcrumb),
    __metadata("design:type", QueryList)
], NglBreadcrumbs.prototype, "breadcrumbs", void 0);

const NGL_BREADCRUMB_DIRECTIVES = [
    NglBreadcrumbs,
    NglBreadcrumb,
];
let NglBreadcrumbsModule = class NglBreadcrumbsModule {
};
NglBreadcrumbsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglBreadcrumbsModule });
NglBreadcrumbsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglBreadcrumbsModule_Factory(t) { return new (t || NglBreadcrumbsModule)(); }, imports: [[CommonModule]] });

let NglButtonIcon = class NglButtonIcon {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The variant changes the appearance of the button
         */
        this.variant = 'border';
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    iconClass() {
        const hasVariant = this.hasVariant();
        const classes = {
            [`slds-button__icon_${this.size}`]: !hasVariant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const hasVariant = this.hasVariant();
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant}`]: hasVariant,
            [`slds-button_icon-${this.size}`]: this.size && hasVariant,
        });
    }
    hasVariant() {
        return this.variant && this.variant !== 'bare';
    }
};
NglButtonIcon.ɵfac = function NglButtonIcon_Factory(t) { return new (t || NglButtonIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButtonIcon, selectors: [["", "nglButtonIcon", ""]], inputs: { variant: "variant", iconName: "iconName", title: "title", alternativeText: "alternativeText", size: "size", svgClass: "svgClass" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon", 3, "nglIconName", "ngClass", 4, "ngIf"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-button__icon", 3, "nglIconName", "ngClass"], [1, "slds-assistive-text"]], template: function NglButtonIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonIcon__svg_svg_0_Template, 1, 2, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButtonIcon_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.altText);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NglButtonIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIcon.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIcon.prototype, "svgClass", void 0);
NglButtonIcon = __decorate([ __metadata("design:paramtypes", [ElementRef, HostService, Renderer2])
], NglButtonIcon);

const DEFAULT_VARIANT = 'border';
let NglButtonIconStateful = class NglButtonIconStateful {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * Specifies whether button is in selected state or not.
         */
        this.selected = false;
        this.selectedChange = new EventEmitter();
        /**
         * The variant changes the appearance of the button.
         */
        this.variant = DEFAULT_VARIANT;
        /**
         *  The size of the button.
         */
        this.size = null;
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    onclick() {
        this.selectedChange.emit(!this.selected);
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant || DEFAULT_VARIANT}`]: true,
            [`slds-button_icon-${this.size}`]: !!this.size,
        });
    }
};
NglButtonIconStateful.ɵfac = function NglButtonIconStateful_Factory(t) { return new (t || NglButtonIconStateful)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonIconStateful.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButtonIconStateful, selectors: [["", "nglButtonIconStateful", ""]], hostVars: 3, hostBindings: function NglButtonIconStateful_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglButtonIconStateful_click_HostBindingHandler() { return ctx.onclick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.selected);
        ɵngcc0.ɵɵclassProp("slds-is-selected", ctx.selected);
    } }, inputs: { selected: "selected", variant: "variant", size: "size", iconName: "iconName", title: "title", alternativeText: "alternativeText" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon", 3, "nglIconName", 4, "ngIf"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-button__icon", 3, "nglIconName"], [1, "slds-assistive-text"]], template: function NglButtonIconStateful_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonIconStateful__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButtonIconStateful_span_2_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.altText);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButtonIconStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.slds-is-selected'),
    HostBinding('attr.aria-pressed'),
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "selected", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "selectedChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "size", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglButtonIconStateful.prototype, "onclick", null);
NglButtonIconStateful = __decorate([ __metadata("design:paramtypes", [ElementRef, HostService, Renderer2])
], NglButtonIconStateful);

const NGL_BUTTON_ICON_DIRECTIVES = [
    NglButtonIcon,
    NglButtonIconStateful,
];
let NglButtonIconsModule = class NglButtonIconsModule {
};
NglButtonIconsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglButtonIconsModule });
NglButtonIconsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglButtonIconsModule_Factory(t) { return new (t || NglButtonIconsModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglButton = class NglButton {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Changes the appearance of the button.
         */
        this.variant = 'neutral';
        /**
         * Describes the position of the icon with respect to ng-content.
         */
        this.iconPosition = 'left';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges(changes) {
        if (changes.variant) {
            this.setHostClass();
        }
    }
    hasLeftIcon() {
        return this.iconName && (!this.iconPosition || this.iconPosition === 'left');
    }
    hasRightIcon() {
        return this.iconName && this.iconPosition === 'right';
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant}`]: this.variant && this.variant !== 'base',
        });
    }
};
NglButton.ɵfac = function NglButton_Factory(t) { return new (t || NglButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButton, selectors: [["", "nglButton", ""]], inputs: { variant: "variant", iconPosition: "iconPosition", iconName: "iconName" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-button__icon slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], ["class", "slds-button__icon slds-button__icon_right", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_left", 3, "nglIconName"], [1, "slds-button__icon", "slds-button__icon_right", 3, "nglIconName"]], template: function NglButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButton__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglButton__svg_svg_2_Template, 1, 1, "svg", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasLeftIcon());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRightIcon());
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButton.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "iconPosition", void 0);
NglButton = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglButton);

let NglButtonStateful = class NglButtonStateful {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Triggered when the button is clicked.
         */
        this.stateChange = new EventEmitter();
        /**
         * Appearance.
         */
        this.variant = 'neutral';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
        this.renderer.addClass(this.el.nativeElement, 'slds-button_stateful');
        this.renderer.setAttribute(this.el.nativeElement, 'aria-live', 'assertive');
    }
    onSelectChange() {
        this.stateChange.emit(!this.state);
    }
    onFocusToggle(focused) {
        this.focused = !!+focused;
        if (!this.focused) {
            this.setHostClass();
        }
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant === 'text' ? 'reset' : this.variant}`]: !!this.variant,
            [`slds-is-selected-clicked`]: this.state && this.focused,
            [`slds-is-selected`]: this.state && !this.focused,
            [`slds-not-selected`]: !this.state,
        });
    }
};
NglButtonStateful.ɵfac = function NglButtonStateful_Factory(t) { return new (t || NglButtonStateful)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglButtonStateful.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglButtonStateful, selectors: [["", "nglButtonStateful", ""]], hostBindings: function NglButtonStateful_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglButtonStateful_click_HostBindingHandler() { return ctx.onSelectChange(); })("focus", function NglButtonStateful_focus_HostBindingHandler() { return ctx.onFocusToggle(1); })("blur", function NglButtonStateful_blur_HostBindingHandler() { return ctx.onFocusToggle(0); });
    } }, inputs: { variant: "variant", state: "state" }, outputs: { stateChange: "stateChange" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature] });
NglButtonStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglButtonStateful.prototype, "state", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglButtonStateful.prototype, "stateChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonStateful.prototype, "variant", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglButtonStateful.prototype, "onSelectChange", null);
__decorate([
    HostListener('focus', ['1']),
    HostListener('blur', ['0']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NglButtonStateful.prototype, "onFocusToggle", null);
NglButtonStateful = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglButtonStateful);

let NglButtonStateOn = class NglButtonStateOn {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, this.getHostClass());
    }
    getHostClass() {
        return 'slds-text-selected';
    }
};
NglButtonStateOn.ɵfac = function NglButtonStateOn_Factory(t) { return new (t || NglButtonStateOn)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglButtonStateOn.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateOn, selectors: [["ngl-state-on"]], inputs: { iconName: "iconName" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateOn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateOn__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglButtonStateOn.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonStateOn.prototype, "iconName", void 0);
NglButtonStateOn = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglButtonStateOn);
let NglButtonStateOff = class NglButtonStateOff extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-not-selected';
    }
};
NglButtonStateOff.ɵfac = function NglButtonStateOff_Factory(t) { return ɵNglButtonStateOff_BaseFactory(t || NglButtonStateOff); };
NglButtonStateOff.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateOff, selectors: [["ngl-state-off"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateOff_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateOff__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
let NglButtonStateHover = class NglButtonStateHover extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-selected-focus';
    }
};
NglButtonStateHover.ɵfac = function NglButtonStateHover_Factory(t) { return ɵNglButtonStateHover_BaseFactory(t || NglButtonStateHover); };
NglButtonStateHover.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglButtonStateHover, selectors: [["ngl-state-hover"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["class", "slds-button__icon slds-button__icon_small slds-button__icon_left", 3, "nglIconName", 4, "ngIf"], [1, "slds-button__icon", "slds-button__icon_small", "slds-button__icon_left", 3, "nglIconName"]], template: function NglButtonStateHover_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglButtonStateHover__svg_svg_0_Template, 1, 1, "svg", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });

const NGL_BUTTON_DIRECTIVES = [
    NglButton,
    NglButtonStateful,
    NglButtonStateOn,
    NglButtonStateOff,
    NglButtonStateHover
];
let NglButtonsModule = class NglButtonsModule {
};
NglButtonsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglButtonsModule });
NglButtonsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglButtonsModule_Factory(t) { return new (t || NglButtonsModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglCarouselImage = class NglCarouselImage {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.uid = uniqueId('carousel-image');
        this.renderer.setAttribute(this.el.nativeElement, 'id', this.uid);
        this.renderer.addClass(this.el.nativeElement, 'slds-carousel__panel');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'tabpanel');
    }
    set labelledby(labelledby) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-labelledby', labelledby);
    }
    set active(active) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-hidden', `${!active}`);
    }
};
NglCarouselImage.ɵfac = function NglCarouselImage_Factory(t) { return new (t || NglCarouselImage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglCarouselImage.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCarouselImage, selectors: [["ngl-carousel-image"]], inputs: { src: "src", header: "header", description: "description", alternativeText: "alternativeText" }, decls: 6, vars: 5, consts: [["href", "javascript:void(0);", 1, "slds-carousel__panel-action", "slds-text-link_reset"], [1, "slds-carousel__image"], [3, "src"], [1, "slds-carousel__content"], [1, "slds-carousel__content-title", 3, "nglInternalOutlet"], [3, "nglInternalOutlet"]], template: function NglCarouselImage_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "img", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelement(4, "h2", 4);
        ɵngcc0.ɵɵelement(5, "p", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.active ? 0 : 0 - 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("src", ctx.src, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵattribute("alt", ctx.alternativeText || null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.description);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCarouselImage.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "src", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCarouselImage.prototype, "description", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "alternativeText", void 0);
NglCarouselImage = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglCarouselImage);

let NglCarouselIndicator = class NglCarouselIndicator {
    constructor(el) {
        this.el = el;
        this.uid = uniqueId('carousel-indicator');
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    ngOnChanges(changes) {
        this.image.active = this.isActive;
        if (changes.image) {
            this.image.labelledby = this.uid;
        }
    }
    focus() {
        this.el.nativeElement.focus();
    }
};
NglCarouselIndicator.ɵfac = function NglCarouselIndicator_Factory(t) { return new (t || NglCarouselIndicator)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglCarouselIndicator.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglCarouselIndicator, selectors: [["", "nglCarouselIndicator", ""]], hostVars: 5, hostBindings: function NglCarouselIndicator_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.uid)("tabindex", ctx.tabindex)("aria-selected", ctx.isActive);
        ɵngcc0.ɵɵclassProp("slds-is-active", ctx.isActive);
    } }, inputs: { isActive: "isActive", image: "image" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglCarouselIndicator.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('class.slds-is-active'),
    HostBinding('attr.aria-selected'),
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarouselIndicator.prototype, "isActive", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglCarouselIndicator.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", NglCarouselImage)
], NglCarouselIndicator.prototype, "image", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", Object)
], NglCarouselIndicator.prototype, "uid", void 0);
NglCarouselIndicator = __decorate([ __metadata("design:paramtypes", [ElementRef])
], NglCarouselIndicator);

let NglCarousel = class NglCarousel {
    constructor(document) {
        this.document = document;
        this.activeChange = new EventEmitter();
        /**
         * The auto scroll duration in seconds. After that the next image is displayed.
         */
        this.scrollDuration = 5;
        /**
         * Whether auto scroll is enabled.
         */
        this.autoScroll = true;
        /**
         * Whether the carousel should continue looping from the beginning after the last item is displayed.
         */
        this.autoRefresh = true;
        this.labels = {
            startAutoPlay: 'Start auto-play',
            stopAutoPlay: 'Stop auto-play',
        };
        this.playing = true;
        this.nextTimer = null;
    }
    isActive(index) {
        return index === this.active;
    }
    getImage(index) {
        return this.images.toArray()[index];
    }
    ngOnChanges(changes) {
        if (changes.active) {
            // Focus correct indicator if one is already focused
            if (this.document && this.indicatorsEl.nativeElement.contains(document.activeElement)) {
                this.indicators.toArray()[this.active].focus();
            }
        }
        if (changes.active || changes.autoScroll || changes.scrollDuration) {
            // Reset timer when active changes
            this.setTimer();
        }
    }
    onIndicatorClick(index) {
        this.setActive(index, true);
    }
    onKeyboard(evt) {
        if (evt.keyCode === LEFT_ARROW || evt.keyCode === RIGHT_ARROW) {
            this.activateNext(evt.keyCode === LEFT_ARROW);
        }
    }
    setActive(index, stopPlaying = false) {
        if (stopPlaying) {
            this.playing = false;
        }
        if (this.active !== index) {
            this.activeChange.emit(index);
        }
    }
    togglePlay() {
        this.playing = !this.playing;
        this.setTimer();
    }
    playLabel() {
        return this.labels[this.playing ? 'stopAutoPlay' : 'startAutoPlay'];
    }
    activateNext(reverse = false) {
        const active = this.active + (reverse ? -1 : 1);
        if ((active < 0 || active > this.images.length - 1) && !this.autoRefresh) {
            return;
        }
        this.setActive((this.images.length + active) % this.images.length);
    }
    setTimer() {
        clearTimeout(this.nextTimer);
        if (this.autoScroll && this.playing) {
            this.nextTimer = setTimeout(() => {
                this.activateNext();
            }, this.scrollDuration * 1000);
        }
    }
};
NglCarousel.ɵfac = function NglCarousel_Factory(t) { return new (t || NglCarousel)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)); };
NglCarousel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCarousel, selectors: [["ngl-carousel"]], contentQueries: function NglCarousel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCarouselImage, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.images = _t);
    } }, viewQuery: function NglCarousel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c8, true);
        ɵngcc0.ɵɵviewQuery(NglCarouselIndicator, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorsEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicators = _t);
    } }, hostVars: 2, hostBindings: function NglCarousel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-carousel", true);
    } }, inputs: { scrollDuration: "scrollDuration", autoScroll: "autoScroll", autoRefresh: "autoRefresh", labels: "labels", active: "active" }, outputs: { activeChange: "activeChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 7, vars: 4, consts: [[1, "slds-carousel__stage"], ["class", "slds-carousel__autoplay", 4, "ngIf"], [1, "slds-carousel__panels"], ["role", "tablist", 1, "slds-carousel__indicators", 3, "keydown"], ["indicatorsEl", ""], ["class", "slds-carousel__indicator", "role", "presentation", 4, "ngFor", "ngForOf"], [1, "slds-carousel__autoplay"], [1, "slds-button", "slds-button_icon", "slds-button_icon-border-filled", "slds-button_icon-x-small", 3, "title", "click"], [1, "slds-button__icon", 3, "nglIconName"], [1, "slds-assistive-text"], ["role", "presentation", 1, "slds-carousel__indicator"], ["nglCarouselIndicator", "", "href", "javascript:void(0);", "role", "tab", 1, "slds-carousel__indicator-action", 3, "isActive", "image", "title", "click"]], template: function NglCarousel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NglCarousel_span_1_Template, 5, 4, "span", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "ul", 3, 4);
        ɵngcc0.ɵɵlistener("keydown", function NglCarousel_Template_ul_keydown_4_listener($event) { return ctx.onKeyboard($event); });
        ɵngcc0.ɵɵtemplate(6, NglCarousel_li_6_Template, 4, 5, "li", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.autoScroll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", "translateX(" + (0 - ctx.active) * 100 + "%)");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.images);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, NglIconSvg,
        NglCarouselIndicator], encapsulation: 2, changeDetection: 0 });
NglCarousel.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "active", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "activeChange", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "scrollDuration", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoScroll", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoRefresh", void 0);
__decorate([
    ContentChildren(NglCarouselImage),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "images", void 0);
__decorate([
    ViewChildren(NglCarouselIndicator),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "indicators", void 0);
__decorate([
    ViewChild('indicatorsEl', { static: true }),
    __metadata("design:type", ElementRef)
], NglCarousel.prototype, "indicatorsEl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "labels", void 0);
NglCarousel = __decorate([ __param(0, Optional()), __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglCarousel);

const DIRECTIVES$1 = [
    NglCarousel,
    NglCarouselImage,
];
let NglCarouselModule = class NglCarouselModule {
};
NglCarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglCarouselModule });
NglCarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglCarouselModule_Factory(t) { return new (t || NglCarouselModule)(); }, imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

let NglCheckboxInput = class NglCheckboxInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('checkbox'));
        }
    }
    set describedBy(value) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-describedby', value);
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
    addClass(klass) {
        this.renderer.addClass(this.el.nativeElement, klass);
    }
};
NglCheckboxInput.ɵfac = function NglCheckboxInput_Factory(t) { return new (t || NglCheckboxInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglCheckboxInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglCheckboxInput, selectors: [["input", "ngl", "", "type", "checkbox"]], inputs: { required: "required" } });
NglCheckboxInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglCheckboxInput.prototype, "required", null);
NglCheckboxInput = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglCheckboxInput);

let NglCheckboxButton = class NglCheckboxButton {
    constructor(cd) {
        this.cd = cd;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside ${this}`);
        }
        this._uid = this.input.id;
        this.cd.detectChanges();
        this.input.addClass('slds-assistive-text');
    }
};
NglCheckboxButton.ɵfac = function NglCheckboxButton_Factory(t) { return new (t || NglCheckboxButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckboxButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxButton, selectors: [["ngl-checkbox-button"]], contentQueries: function NglCheckboxButton_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglCheckboxInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 2, hostBindings: function NglCheckboxButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-checkbox_add-button", true);
    } }, inputs: { label: "label" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [[1, "slds-checkbox_faux"], [1, "slds-assistive-text", 3, "nglInternalOutlet"]], template: function NglCheckboxButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label", 0);
        ɵngcc0.ɵɵelement(2, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxButton.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxButton.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxButton.prototype, "label", void 0);
NglCheckboxButton = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckboxButton);

let NglCheckbox = class NglCheckbox {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckbox`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
};
NglCheckbox.ɵfac = function NglCheckbox_Factory(t) { return new (t || NglCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCheckbox, selectors: [["ngl-checkbox"], ["", "ngl-checkbox", ""]], contentQueries: function NglCheckbox_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglCheckboxInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglCheckbox_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", error: "error", stacked: "stacked" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 6, consts: [[1, "slds-form-element__control"], [1, "slds-checkbox"], ["class", "slds-required", "title", "required", 4, "ngIf"], [1, "slds-checkbox__label"], [1, "slds-checkbox_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], ["title", "required", 1, "slds-required"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NglCheckbox_abbr_2_Template, 2, 0, "abbr", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementStart(4, "label", 3);
        ɵngcc0.ɵɵelement(5, "span", 4);
        ɵngcc0.ɵɵelement(6, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglCheckbox_div_7_Template, 1, 2, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-checkbox_stacked", ctx.stacked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckbox.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckbox.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckbox.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckbox.prototype, "error", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCheckbox.prototype, "stacked", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckbox.prototype, "hasError", null);
NglCheckbox = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckbox);

let NglCheckboxToggle = class NglCheckboxToggle {
    constructor(cd) {
        this.cd = cd;
        this.enabledText = 'Enabled';
        this.disabledText = 'Disabled';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckboxToggle`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this.uid = `${this.input.id}_toggle`;
        this.input.describedBy = this.uid;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
};
NglCheckboxToggle.ɵfac = function NglCheckboxToggle_Factory(t) { return new (t || NglCheckboxToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglCheckboxToggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxToggle, selectors: [["ngl-checkbox-toggle"]], contentQueries: function NglCheckboxToggle_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglCheckboxInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglCheckboxToggle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { enabledText: "enabledText", disabledText: "disabledText", label: "label", error: "error" }, ngContentSelectors: _c0, decls: 11, vars: 6, consts: [[1, "slds-checkbox_toggle", "slds-grid"], ["class", "slds-required", "title", "required", 4, "ngIf"], [1, "slds-form-element__label", "slds-m-bottom_none", 3, "nglInternalOutlet"], ["aria-live", "assertive", 1, "slds-checkbox_faux_container", 3, "id"], [1, "slds-checkbox_faux"], [1, "slds-checkbox_on"], [1, "slds-checkbox_off"], ["class", "slds-form-element__help", 4, "ngIf"], ["title", "required", 1, "slds-required"], [1, "slds-form-element__help"]], template: function NglCheckboxToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxToggle_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵelement(5, "span", 4);
        ɵngcc0.ɵɵelementStart(6, "span", 5);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglCheckboxToggle_div_10_Template, 2, 1, "div", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.enabledText);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.disabledText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxToggle.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxToggle.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCheckboxToggle.prototype, "error", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "enabledText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "disabledText", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckboxToggle.prototype, "hasError", null);
NglCheckboxToggle = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckboxToggle);

let NglCheckboxOption = class NglCheckboxOption {
    constructor(cd, element, hostService) {
        this.cd = cd;
        this.element = element;
        this.hostService = hostService;
    }
    set type(type) {
        this._type = type;
        this.setHostClass();
        this.cd.detectChanges();
    }
    get type() {
        return this._type;
    }
    setError(id) {
        this.input.describedBy = id;
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-checkbox`]: this.type === 'list',
            [`slds-button`]: this.type === 'button',
            [`slds-checkbox_button`]: this.type === 'button',
        });
    }
};
NglCheckboxOption.ɵfac = function NglCheckboxOption_Factory(t) { return new (t || NglCheckboxOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglCheckboxOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxOption, selectors: [["ngl-checkbox-option"]], contentQueries: function NglCheckboxOption_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglCheckboxInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, inputs: { label: "label" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService])], ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-checkbox__label", 4, "ngIf"], ["class", "slds-checkbox_button__label", 4, "ngIf"], [1, "slds-checkbox__label"], [1, "slds-checkbox_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-checkbox_button__label"], [1, "slds-checkbox_faux", 3, "nglInternalOutlet"]], template: function NglCheckboxOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxOption_label_1_Template, 3, 2, "label", 0);
        ɵngcc0.ɵɵtemplate(2, NglCheckboxOption_label_2_Template, 2, 2, "label", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "list");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button");
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglCheckboxOption.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxOption.prototype, "label", void 0);
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxOption.prototype, "input", void 0);
NglCheckboxOption = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef, ElementRef, HostService])
], NglCheckboxOption);

let NglCheckboxGroup = class NglCheckboxGroup {
    constructor() {
        this.uid = uniqueId('checkbox-group');
        this._type = 'list';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    set type(type) {
        this._type = type;
        this.updateChildrenType();
    }
    get type() {
        return this._type;
    }
    ngOnChanges(changes) {
        if (changes.error && this.options) {
            this.options.forEach((option) => {
                option.setError(this.error ? this.errorId : null);
            });
        }
    }
    ngAfterContentInit() {
        this.updateChildrenType();
    }
    updateChildrenType() {
        if (!this.options) {
            return;
        }
        this.options.forEach((option) => {
            option.type = this.type;
        });
    }
};
NglCheckboxGroup.ɵfac = function NglCheckboxGroup_Factory(t) { return new (t || NglCheckboxGroup)(); };
NglCheckboxGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCheckboxGroup, selectors: [["ngl-checkbox-group"], ["", "ngl-checkbox-group", ""]], contentQueries: function NglCheckboxGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglCheckboxOption, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostVars: 4, hostBindings: function NglCheckboxGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { type: "type", label: "label", error: "error", required: "required" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 5, consts: [[1, "slds-form-element__legend", "slds-form-element__label"], ["class", "slds-required", "title", "required", 4, "ngIf"], [3, "nglInternalOutlet"], [1, "slds-form-element__control"], ["class", "slds-checkbox_button-group", 4, "ngIf", "ngIfElse"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], ["contentTpl", ""], ["title", "required", 1, "slds-required"], [1, "slds-checkbox_button-group"], [4, "ngTemplateOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglCheckboxGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "legend", 0);
        ɵngcc0.ɵɵtemplate(1, NglCheckboxGroup_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NglCheckboxGroup_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglCheckboxGroup_div_5_Template, 1, 2, "div", 5);
        ɵngcc0.ɵɵtemplate(6, NglCheckboxGroup_ng_template_6_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r136 = ɵngcc0.ɵɵreference(7);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button")("ngIfElse", _r136);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    ContentChildren(NglCheckboxOption),
    __metadata("design:type", QueryList)
], NglCheckboxGroup.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxGroup.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxGroup.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckboxGroup.prototype, "hasError", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCheckboxGroup.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglCheckboxGroup.prototype, "type", null);

const DIRECTIVES$2 = [
    NglCheckboxButton,
    NglCheckbox,
    NglCheckboxToggle,
    NglCheckboxInput,
    NglCheckboxGroup,
    NglCheckboxOption,
];
let NglCheckboxesModule = class NglCheckboxesModule {
};
NglCheckboxesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglCheckboxesModule });
NglCheckboxesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglCheckboxesModule_Factory(t) { return new (t || NglCheckboxesModule)(); }, imports: [[CommonModule, NglInternalOutletModule]] });

/*
 * <ng-template ngl-tab label="...">
 *    Content goes here...
 * </ng-template>
 */
let NglTab = class NglTab {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.uid = uniqueId('tab');
        this._active = false;
    }
    set active(active) {
        if (active === this._active) {
            return;
        }
        this._active = active;
        if (active) {
            this.activate.emit(this);
        }
        else {
            this.deactivate.emit(this);
        }
    }
    get active() {
        return this._active;
    }
};
NglTab.ɵfac = function NglTab_Factory(t) { return new (t || NglTab)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NglTab.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTab, selectors: [["", "ngl-tab", ""]], inputs: { id: "id", label: "label" }, outputs: { activate: "activate", deactivate: "deactivate" }, exportAs: ["nglTab"] });
NglTab.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglTab.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTab.prototype, "label", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTab.prototype, "activate", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTab.prototype, "deactivate", void 0);
NglTab = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], NglTab);

let NglTabs = class NglTabs {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        /**
         * Whether every tab's content is instantiated when visible, and destroyed when hidden.
         */
        this.lazy = true;
        this.renderer.addClass(this.element.nativeElement, `slds-tabs_${this.variant}`);
    }
    set variant(variant) {
        const el = this.element.nativeElement;
        this.renderer.removeClass(el, `slds-tabs_${this.variant}`);
        this._variant = variant;
        this.renderer.addClass(el, `slds-tabs_${this.variant}`);
    }
    get variant() {
        return this._variant || 'default';
    }
    set setSelected(selected) {
        if (selected === this.selected) {
            return;
        }
        this.selected = selected;
        if (!this.tabs) {
            return;
        } // Wait for content to initialize
        this.activate();
    }
    ngAfterContentInit() {
        // Initial selection after all tabs are created
        this.activate();
        if (!this.activeTab) {
            setTimeout(() => this.select(this.tabs.first));
        }
    }
    select(tab) {
        this.selectedChange.emit(tab);
    }
    move(evt, moves) {
        evt.preventDefault();
        const tabs = this.tabs.toArray();
        const selectedIndex = tabs.indexOf(this.activeTab);
        this.select(tabs[(tabs.length + selectedIndex + moves) % tabs.length]);
    }
    tabClass(tab) {
        return {
            [`slds-tabs_${this.variant}__content`]: true,
            [`slds-${tab.active ? 'show' : 'hide'}`]: true,
        };
    }
    trackByTab(index, tab) {
        return tab.uid;
    }
    activate() {
        if (this.activeTab) {
            this.activeTab.active = false;
        }
        this.activeTab = this.findTab();
        if (this.activeTab) {
            this.activeTab.active = true;
        }
    }
    findTab(value = this.selected) {
        if (value instanceof NglTab) {
            return value;
        }
        if (isInt(value)) {
            return this.tabs.toArray()[+value];
        }
        return this.tabs.toArray().find((t) => {
            return t.id && t.id === value;
        });
    }
};
NglTabs.ɵfac = function NglTabs_Factory(t) { return new (t || NglTabs)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglTabs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglTabs, selectors: [["ngl-tabset"]], contentQueries: function NglTabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTab, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { lazy: "lazy", variant: "variant", setSelected: ["selected", "setSelected"] }, outputs: { selectedChange: "selectedChange" }, decls: 3, vars: 5, consts: [["role", "tablist", 3, "ngClass", "keydown.ArrowLeft", "keydown.ArrowRight"], ["role", "presentation", 3, "ngClass", "slds-is-active", "id", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "tabpanel", 3, "id", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", 3, "ngClass", "id", "click"], ["role", "tab", 3, "nglInternalOutlet", "ngClass"], ["role", "tabpanel", 3, "id", "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function NglTabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵlistener("keydown.ArrowLeft", function NglTabs_Template_ul_keydown_ArrowLeft_0_listener($event) { return ctx.move($event, 0 - 1); })("keydown.ArrowRight", function NglTabs_Template_ul_keydown_ArrowRight_0_listener($event) { return ctx.move($event, 1); });
        ɵngcc0.ɵɵtemplate(1, NglTabs_li_1_Template, 2, 9, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglTabs_div_2_Template, 2, 4, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", "slds-tabs_" + ctx.variant + "__nav");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByTab);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByTab);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, NglInternalOutlet, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
NglTabs.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglTabs.prototype, "variant", null);
__decorate([
    ContentChildren(NglTab),
    __metadata("design:type", QueryList)
], NglTabs.prototype, "tabs", void 0);
__decorate([
    Input('selected'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTabs.prototype, "setSelected", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTabs.prototype, "selectedChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglTabs.prototype, "lazy", void 0);
NglTabs = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglTabs);

var NglTabVerbose_1;
/*
 * <ngl-tab [label="..."]>
 *    <ng-template ngl-tab-label>...</ng-template>
 *    <ng-template ngl-tab-content>
 *       Content goes here...
 *    </ng-template>
 * </ngl-tab>
 */
// tslint:disable-next-line:directive-selector
let NglTabLabel = class NglTabLabel {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglTabLabel.ɵfac = function NglTabLabel_Factory(t) { return new (t || NglTabLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglTabLabel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTabLabel, selectors: [["", "ngl-tab-label", ""]] });
NglTabLabel.ctorParameters = () => [
    { type: TemplateRef }
];
NglTabLabel = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglTabLabel);
// tslint:disable-next-line:directive-selector
let NglTabContent = class NglTabContent {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglTabContent.ɵfac = function NglTabContent_Factory(t) { return new (t || NglTabContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglTabContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTabContent, selectors: [["", "ngl-tab-content", ""]] });
NglTabContent.ctorParameters = () => [
    { type: TemplateRef }
];
NglTabContent = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglTabContent);
let NglTabVerbose = NglTabVerbose_1 = class NglTabVerbose extends NglTab {
    ngAfterContentInit() {
        if (this.labelTemplate) {
            this.label = this.labelTemplate.templateRef;
        }
        this.templateRef = this.contentTemplate.templateRef;
    }
};
NglTabVerbose.ɵfac = function NglTabVerbose_Factory(t) { return ɵNglTabVerbose_BaseFactory(t || NglTabVerbose); };
NglTabVerbose.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTabVerbose, selectors: [["ngl-tab"]], contentQueries: function NglTabVerbose_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTabContent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglTabLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NglTab, useExisting: NglTabVerbose_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChild(NglTabContent),
    __metadata("design:type", NglTabContent)
], NglTabVerbose.prototype, "contentTemplate", void 0);
__decorate([
    ContentChild(NglTabLabel),
    __metadata("design:type", NglTabLabel)
], NglTabVerbose.prototype, "labelTemplate", void 0);

const NGL_TAB_DIRECTIVES = [
    NglTabs,
    NglTab,
    NglTabVerbose, NglTabContent, NglTabLabel,
];
let NglTabsModule = class NglTabsModule {
};
NglTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglTabsModule });
NglTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglTabsModule_Factory(t) { return new (t || NglTabsModule)(); }, imports: [[CommonModule, NglInternalOutletModule]] });

const POSITION_MAP = {
    'top': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'center', overlayY: 'bottom' }),
        nubbin: 'bottom'
    },
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left'
    },
    'top-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left-corner'
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right'
    },
    'top-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right-corner'
    },
    'right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' }),
        nubbin: 'left'
    },
    'right-top': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top'
    },
    'right-top-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top-corner'
    },
    'right-bottom': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom'
    },
    'right-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom-corner'
    },
    'bottom': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'center', overlayY: 'top' }),
        nubbin: 'top'
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left'
    },
    'bottom-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left-corner'
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right'
    },
    'bottom-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right-corner'
    },
    'left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' }),
        nubbin: 'right'
    },
    'left-top': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top'
    },
    'left-top-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top-corner'
    },
    'left-bottom': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom'
    },
    'left-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom-corner'
    }
};
const DROPDOWN_POSITION_MAP = {
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    },
};
const ɵ0 = (p) => DROPDOWN_POSITION_MAP[p].position, ɵ1 = (p) => DROPDOWN_POSITION_MAP[p].position;
const DEFAULT_DROPDOWN_POSITIONS = {
    left: [`bottom-left`, `top-left`].map(ɵ0),
    right: [`bottom-right`, `top-right`].map(ɵ1),
};
const ɵ2 = (placement) => POSITION_MAP[placement].position;
const DEFAULT_TOOLTIP_POSITIONS = ['top', 'right', 'bottom', 'left'].map(ɵ2);
const DEFAULT_POPOVER_POSITIONS = DEFAULT_TOOLTIP_POSITIONS;
function getPlacementName(position, initialPlacement) {
    const keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
    for (const placement in POSITION_MAP) {
        if (keyList.every(key => position.connectionPair[key] === POSITION_MAP[placement]['position'][key])) {
            if (initialPlacement && initialPlacement === `${placement}-corner`) {
                return initialPlacement;
            }
            return placement;
        }
    }
}
function getPlacementStyles(nubbin) {
    const [direction, align, corner] = nubbin.split('-');
    return {
        [direction]: '1rem',
        [align]: corner ? '-0.75rem' : (align ? '-1.5rem' : false),
    };
}

function isTemplateRef(value) {
    return value instanceof TemplateRef;
}

function OnChange(callback = 'nglOnPropertyChange') {
    const cachedValueKey = Symbol();
    const isFirstChangeKey = Symbol();
    return (target, key) => {
        Object.defineProperty(target, key, {
            set: function (value) {
                // change status of "isFirstChange"
                if (this[isFirstChangeKey] === undefined) {
                    this[isFirstChangeKey] = true;
                }
                else {
                    this[isFirstChangeKey] = false;
                }
                // No operation if new value is same as old value
                if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                    return;
                }
                const oldValue = this[cachedValueKey];
                this[cachedValueKey] = value;
                const simpleChange = {
                    firstChange: this[isFirstChangeKey],
                    previousValue: oldValue,
                    currentValue: this[cachedValueKey],
                    isFirstChange: () => this[isFirstChangeKey],
                };
                this[callback](key, this[cachedValueKey], simpleChange);
            },
            get: function () {
                return this[cachedValueKey];
            },
        });
    };
}

let NglPopover = class NglPopover {
    constructor(hostService, element, renderer, focusTrapFactory, cd) {
        this.hostService = hostService;
        this.element = element;
        this.renderer = renderer;
        this.focusTrapFactory = focusTrapFactory;
        this.cd = cd;
        this.close = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.uid = uniqueId('popover');
    }
    get labelledby() {
        return this.header ? `${this.uid}-heading` : null;
    }
    get describedby() {
        return this.template ? this.uid : null;
    }
    ngOnInit() {
        this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
        this.focusTrap.focusInitialElementWhenReady();
    }
    ngOnDestroy() {
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
    }
    nglOnPropertyChange(prop) {
        if (prop === 'size' || prop === 'popoverClass') {
            this.setHostClass();
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'variant') {
            this.inverseCloseButton = ['walkthrough', 'feature', 'error'].indexOf(this.variant) > -1;
            this.setHostClass();
        }
    }
    markForCheck() {
        this.cd.markForCheck();
    }
    onClose() {
        this.close.emit();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.popoverClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
            [`slds-popover_${this.size}`]: !!this.size,
            [`slds-popover_walkthrough`]: this.variant === 'feature',
            [`slds-popover_${this.variant}`]: !!this.variant,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
};
NglPopover.ɵfac = function NglPopover_Factory(t) { return new (t || NglPopover)(ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglPopover.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglPopover, selectors: [["section", "ngl-popover", ""]], hostAttrs: ["role", "dialog"], hostVars: 4, hostBindings: function NglPopover_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.labelledby)("aria-describedby", ctx.describedby);
        ɵngcc0.ɵɵclassProp("slds-popover", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([HostService])], attrs: _c9, decls: 4, vars: 5, consts: [["class", "slds-button slds-button_icon slds-button_icon-small slds-float_right slds-popover__close", 3, "title", "slds-button_icon-inverse", "click", 4, "ngIf"], ["class", "slds-popover__header", 4, "ngIf"], [1, "slds-popover__body", 3, "id", "nglInternalOutlet"], ["class", "slds-popover__footer", 3, "nglInternalOutlet", 4, "ngIf"], [1, "slds-button", "slds-button_icon", "slds-button_icon-small", "slds-float_right", "slds-popover__close", 3, "title", "click"], ["nglIconName", "close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"], [1, "slds-popover__header"], [3, "id", 4, "ngIf", "ngIfElse"], ["defaultTpl", ""], [3, "id"], [3, "ngTemplateOutlet"], [1, "slds-text-heading_small", 3, "id"], [1, "slds-popover__footer", 3, "nglInternalOutlet"]], template: function NglPopover_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglPopover_button_0_Template, 3, 4, "button", 0);
        ɵngcc0.ɵɵtemplate(1, NglPopover_header_1_Template, 4, 2, "header", 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NglPopover_footer_3_Template, 1, 1, "footer", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.canClose && ctx.closeVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("nglInternalOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footer);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet,
        NglIconSvg, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglPopover.ctorParameters = () => [
    { type: HostService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: FocusTrapFactory },
    { type: ChangeDetectorRef }
];
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglPopover.prototype, "popoverClass", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "size", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "variant", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "placement", void 0);
__decorate([
    HostBinding('attr.aria-labelledby'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglPopover.prototype, "labelledby", null);
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglPopover.prototype, "describedby", null);
NglPopover = __decorate([ __metadata("design:paramtypes", [HostService,
        ElementRef,
        Renderer2,
        FocusTrapFactory,
        ChangeDetectorRef])
], NglPopover);

function hasObservers(output) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`[ng-lightning]: The prop "${privatePropName}" already exists, it will be overridden by ${propName} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                if (!(this[output] instanceof EventEmitter)) {
                    throw Error(`[ng-lightning] ${target.constructor.name}: "${output}" is not an EventEmitter`);
                }
                return this[output].observers.length > 0;
            },
            set() {
                console.warn(`[ng-lightning] ${target.constructor.name}: "${propName}" is readonly and cannot be assigned a value`);
            }
        });
    }
    return propDecorator;
}

let NglPopoverTrigger = class NglPopoverTrigger {
    constructor(element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Close button title (and assistive text).
         */
        this.closeTitle = 'Close dialog';
        /**
           * Whether or not to override the close button's visibility, if `nglPopoverOpenChange` is set.
           */
        this.closeVisible = true;
        /** Emit an event when actual popover is shown or hidden */
        this.nglPopoverOpenChange = new EventEmitter();
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'header',
            'footer',
            'placement',
            'variant',
            'size',
            'closeTitle',
            'canClose',
            'popoverClass',
            'closeVisible',
        ]);
        this._placement = 'top';
        this.backdrop = new Subject();
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    /**
     * Position relative to host element.
     */
    set placement(_placement) {
        _placement = _placement || 'top';
        if (_placement === this._placement) {
            return;
        }
        this._placement = _placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement;
    }
    /**
     * Whether the floating popover is visible.
     */
    set nglOpen(_open) {
        _open = toBoolean(_open) && (['backdrop', 'x', 'escape'].indexOf(_open) === -1);
        _open ? this.create() : this.detach();
        this._open = _open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (changes.nglOpen && !changes.nglOpen.firstChange) {
            const open = changes.nglOpen.currentValue;
            if (!toBoolean(open) || open === 'x' || open === 'escape') {
                this.element.nativeElement.focus();
            }
        }
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
            this.popover.markForCheck();
        }
    }
    onclick(evt) {
        evt.preventDefault();
        this.toggle();
    }
    ngOnDestroy() {
        this.detach();
        this.close();
    }
    open() {
        if (!this.nglOpen) {
            this.nglPopoverOpenChange.emit(true);
        }
    }
    close(reason = false) {
        if (this.nglOpen) {
            this.nglPopoverOpenChange.emit(reason);
        }
    }
    toggle() {
        this.nglOpen ? this.close() : this.open();
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglPopover, this.viewContainerRef);
        this.popover = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updatePopover(property, this[property]));
        this.popover.markForCheck();
        this.clearGlobalClickTimeout();
        this.globalClickTimeout = setTimeout(() => {
            this.subscribeToClickEvents();
        });
        this.closeSubscription = this.popoverClosingActions()
            .subscribe(reason => this.close(reason));
    }
    /** Detaches the currently attached popover. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        this.unsubscribeFromClickEvents();
        if (this.closeSubscription) {
            this.closeSubscription.unsubscribe();
            this.closeSubscription = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.popover = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updatePopover('placement', placement);
            this.popover.markForCheck();
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current popover. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_POPOVER_POSITIONS,
        ]);
    }
    updatePopover(key, value) {
        this.popover[key] = value;
    }
    /** Set inputs of child components when this component's inputs change. */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updatePopover(key, this[key]));
    }
    /** Returns a stream that emits whenever an action that should close the popover occurs. */
    popoverClosingActions() {
        const backdrop = this.backdrop.pipe(mapTo('backdrop'));
        const close = this.popover.close.pipe(mapTo('x'));
        const escape = this.overlayRef.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE), mapTo('escape'));
        return merge(backdrop, close, escape);
    }
    handleGlobalClickEvent($event) {
        if ($event.$nglStop) {
            return;
        }
        this.backdrop.next();
    }
    subscribeToClickEvents() {
        this.unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.popover.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
};
NglPopoverTrigger.ɵfac = function NglPopoverTrigger_Factory(t) { return new (t || NglPopoverTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay)); };
NglPopoverTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglPopoverTrigger, selectors: [["", "nglPopover", ""]], hostBindings: function NglPopoverTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglPopoverTrigger_click_HostBindingHandler($event) { return ctx.onclick($event); });
    } }, inputs: { closeTitle: ["nglPopoverCloseTitle", "closeTitle"], closeVisible: ["nglPopoverCloseVisible", "closeVisible"], placement: ["nglPopoverPlacement", "placement"], nglOpen: ["nglPopoverOpen", "nglOpen"], template: ["nglPopover", "template"], header: ["nglPopoverHeader", "header"], footer: ["nglPopoverFooter", "footer"], variant: ["nglPopoverVariant", "variant"], size: ["nglPopoverSize", "size"], popoverClass: ["nglPopoverClass", "popoverClass"] }, outputs: { nglPopoverOpenChange: "nglPopoverOpenChange" }, exportAs: ["nglPopover"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglPopoverTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
__decorate([
    Input('nglPopover'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "template", void 0);
__decorate([
    Input('nglPopoverHeader'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "header", void 0);
__decorate([
    Input('nglPopoverFooter'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "footer", void 0);
__decorate([
    Input('nglPopoverVariant'),
    __metadata("design:type", String)
], NglPopoverTrigger.prototype, "variant", void 0);
__decorate([
    Input('nglPopoverSize'),
    __metadata("design:type", String)
], NglPopoverTrigger.prototype, "size", void 0);
__decorate([
    Input('nglPopoverPlacement'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglPopoverTrigger.prototype, "placement", null);
__decorate([
    Input('nglPopoverOpen'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPopoverTrigger.prototype, "nglOpen", null);
__decorate([
    Input('nglPopoverCloseTitle'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "closeTitle", void 0);
__decorate([
    Input('nglPopoverClass'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "popoverClass", void 0);
__decorate([
    Input('nglPopoverCloseVisible'), InputBoolean(),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "closeVisible", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "nglPopoverOpenChange", void 0);
__decorate([
    hasObservers('nglPopoverOpenChange'),
    __metadata("design:type", Boolean)
], NglPopoverTrigger.prototype, "canClose", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglPopoverTrigger.prototype, "onclick", null);
NglPopoverTrigger = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ViewContainerRef,
        Overlay])
], NglPopoverTrigger);

const NGL_POPOVER_DIRECTIVES = [
    NglPopover,
    NglPopoverTrigger,
];
let NglPopoversModule = class NglPopoversModule {
};
NglPopoversModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglPopoversModule });
NglPopoversModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglPopoversModule_Factory(t) { return new (t || NglPopoversModule)(); }, imports: [[CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule]] });

let NglTooltip = class NglTooltip {
    constructor(element, renderer, hostService, cd) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.cd = cd;
        this.renderer.addClass(this.element.nativeElement, 'slds-popover');
        this.renderer.addClass(this.element.nativeElement, 'slds-popover_tooltip');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'tooltip');
    }
    nglOnPropertyChange(prop) {
        if (prop === 'uid') {
            this.renderer.setAttribute(this.element.nativeElement, 'id', this.uid);
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'template') {
            this.cd.markForCheck();
        }
        else if (prop === 'tooltipClass') {
            this.setHostClass();
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.tooltipClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
};
NglTooltip.ɵfac = function NglTooltip_Factory(t) { return new (t || NglTooltip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglTooltip.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglTooltip, selectors: [["div", "ngl-tooltip", ""]], features: [ɵngcc0.ɵɵProvidersFeature([HostService])], attrs: _c10, decls: 1, vars: 1, consts: [[1, "slds-popover__body", 3, "nglInternalOutlet"]], template: function NglTooltip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.template);
    } }, directives: [NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglTooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService },
    { type: ChangeDetectorRef }
];
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglTooltip.prototype, "template", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglTooltip.prototype, "placement", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglTooltip.prototype, "uid", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglTooltip.prototype, "tooltipClass", void 0);
NglTooltip = __decorate([ __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        HostService,
        ChangeDetectorRef])
], NglTooltip);

/** Injection token that can be used to specify default options. */
const NGL_TOOLTIP_CONFIG = new InjectionToken('ngl-tooltip-config');
class NglTooltipConfig {
    constructor() {
        /**
         * Default position relative to host element.
         */
        this.placement = 'top';
        /**
         * Whether you can interact with the content of the tooltip.
         */
        this.interactive = false;
        /**
         * Whether tooltip will open/close without two-way binding input.
         */
        this.openAuto = false;
        /**
         * Delay in milliseconds until it opens/closes.
         */
        this.delay = 0;
    }
}

let NglTooltipTrigger = class NglTooltipTrigger {
    constructor(defaultConfig, element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Emit an event when actual tooltip is shown or hidden.
         */
        this.nglTooltipOpenChange = new EventEmitter();
        this.uid = uniqueId('tooltip');
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'placement',
            'uid',
            'tooltipClass',
        ]);
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.overlayListeners = new Set();
        this.config = Object.assign(Object.assign({}, new NglTooltipConfig()), defaultConfig);
        this.openAuto = this.config.openAuto;
        this.interactive = this.config.interactive;
        this.delay = this.config.delay;
        this.renderer.setAttribute(this.element.nativeElement, 'aria-describedby', this.uid);
    }
    /**
     * Position relative to host element.
     */
    set placement(placement) {
        if (placement === this.placement) {
            return;
        }
        this._placement = placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement || this.config.placement;
    }
    /**
     * Delay in milliseconds until it opens/closes.
     */
    set delay(_delay) {
        const delay = Array.isArray(_delay) ? _delay : [_delay, _delay];
        [this.openDelay, this.closeDelay] = delay.map(Number);
    }
    /**
     * Whether the floating tooltip is visible.
     */
    set nglOpen(open) {
        if (open === this.nglOpen) {
            return;
        }
        open ? this.create() : this.detach();
        this._open = open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
        }
    }
    onMouseOver() {
        this.open();
    }
    onMouseOut() {
        this.close();
        if (this.overlayRef && !this.overlayElement && this.interactive) {
            this.overlayElement = this.overlayRef.overlayElement;
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseenter', () => this.open()));
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseleave', () => this.close()));
        }
    }
    ngOnDestroy() {
        this.detach();
        this.close(0);
    }
    // Expose open method
    open(delay = this.openDelay) {
        this.handle(true, delay);
    }
    // Expose close method
    close(delay = this.closeDelay) {
        this.handle(false, delay);
    }
    // Expose toggle method
    toggle() {
        this.nglOpen ? this.close(0) : this.open(0);
    }
    handle(open, delay) {
        if (this.toggleTimeout !== null) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        if (open !== this.nglOpen) {
            if (delay > 0) {
                this.toggleTimeout = setTimeout(() => {
                    this.toggleTimeout = null;
                    this.emitOpen(open);
                }, delay);
            }
            else {
                this.emitOpen(open);
            }
        }
    }
    emitOpen(open) {
        if (this.openAuto) {
            this.nglOpen = open;
        }
        this.nglTooltipOpenChange.emit(open);
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglTooltip, this.viewContainerRef);
        this.tooltip = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updateTooltip(property, this[property]));
    }
    /** Detaches the currently-attached tooltip. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        // Clean up the event listeners
        this.overlayListeners.forEach((unlisten) => unlisten());
        this.overlayListeners.clear();
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.tooltip = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updateTooltip('placement', placement);
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current tooltip. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_TOOLTIP_POSITIONS,
        ]);
    }
    updateTooltip(key, value) {
        this.tooltip[key] = value;
    }
    /**
     * Set inputs of child components when this component's inputs change.
     */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updateTooltip(key, this[key]));
    }
};
NglTooltipTrigger.ɵfac = function NglTooltipTrigger_Factory(t) { return new (t || NglTooltipTrigger)(ɵngcc0.ɵɵdirectiveInject(NGL_TOOLTIP_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay)); };
NglTooltipTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTooltipTrigger, selectors: [["", "nglTooltip", ""]], hostBindings: function NglTooltipTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function NglTooltipTrigger_mouseenter_HostBindingHandler() { return ctx.onMouseOver(); })("focus", function NglTooltipTrigger_focus_HostBindingHandler() { return ctx.onMouseOver(); })("mouseleave", function NglTooltipTrigger_mouseleave_HostBindingHandler() { return ctx.onMouseOut(); })("blur", function NglTooltipTrigger_blur_HostBindingHandler() { return ctx.onMouseOut(); });
    } }, inputs: { openAuto: ["nglTooltipOpenAuto", "openAuto"], interactive: ["nglTooltipInteractive", "interactive"], delay: ["nglTooltipDelay", "delay"], placement: ["nglTooltipPlacement", "placement"], nglOpen: ["nglTooltipOpen", "nglOpen"], template: ["nglTooltip", "template"], tooltipClass: ["nglTooltipClass", "tooltipClass"] }, outputs: { nglTooltipOpenChange: "nglTooltipOpenChange" }, exportAs: ["nglTooltip"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NglTooltipTrigger.ctorParameters = () => [
    { type: NglTooltipConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_TOOLTIP_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
__decorate([
    Input('nglTooltip'),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "template", void 0);
__decorate([
    Input('nglTooltipPlacement'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglTooltipTrigger.prototype, "placement", null);
__decorate([
    Input('nglTooltipDelay'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTooltipTrigger.prototype, "delay", null);
__decorate([
    Input('nglTooltipOpen'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglTooltipTrigger.prototype, "nglOpen", null);
__decorate([
    Input('nglTooltipOpenAuto'), InputBoolean(),
    __metadata("design:type", Boolean)
], NglTooltipTrigger.prototype, "openAuto", void 0);
__decorate([
    Input('nglTooltipInteractive'), InputBoolean(),
    __metadata("design:type", Boolean)
], NglTooltipTrigger.prototype, "interactive", void 0);
__decorate([
    Input('nglTooltipClass'),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "tooltipClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "nglTooltipOpenChange", void 0);
__decorate([
    HostListener('mouseenter'),
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglTooltipTrigger.prototype, "onMouseOver", null);
__decorate([
    HostListener('mouseleave'),
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglTooltipTrigger.prototype, "onMouseOut", null);
NglTooltipTrigger = __decorate([ __param(0, Optional()), __param(0, Inject(NGL_TOOLTIP_CONFIG)),
    __metadata("design:paramtypes", [NglTooltipConfig,
        ElementRef,
        Renderer2,
        ViewContainerRef,
        Overlay])
], NglTooltipTrigger);

let NglTooltipsModule = class NglTooltipsModule {
};
NglTooltipsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglTooltipsModule });
NglTooltipsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglTooltipsModule_Factory(t) { return new (t || NglTooltipsModule)(); }, imports: [[CommonModule, OverlayModule, A11yModule, NglInternalOutletModule]] });

let NglFormLabel = class NglFormLabel {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.klass = 'slds-form-element__label';
    }
    ngOnInit() {
        this.renderer.addClass(this.element.nativeElement, this.klass);
    }
};
NglFormLabel.ɵfac = function NglFormLabel_Factory(t) { return new (t || NglFormLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFormLabel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglFormLabel, selectors: [["label", "nglFormLabel", ""]], inputs: { klass: ["nglFormLabelClass", "klass"], label: ["nglFormLabel", "label"], required: "required" }, attrs: _c11, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-required", "title", "Required", 4, "ngIf"], [3, "nglInternalOutlet"], ["title", "Required", 1, "slds-required"]], template: function NglFormLabel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NglFormLabel_abbr_0_Template, 2, 0, "abbr", 0);
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglFormLabel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('nglFormLabel'),
    __metadata("design:type", Object)
], NglFormLabel.prototype, "label", void 0);
__decorate([
    Input('nglFormLabelClass'),
    __metadata("design:type", Object)
], NglFormLabel.prototype, "klass", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglFormLabel.prototype, "required", void 0);
NglFormLabel = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFormLabel);

let NglFormHelp = class NglFormHelp {
    constructor() {
        this.isOpen = false;
    }
};
NglFormHelp.ɵfac = function NglFormHelp_Factory(t) { return new (t || NglFormHelp)(); };
NglFormHelp.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglFormHelp, selectors: [["ngl-form-help"]], hostVars: 2, hostBindings: function NglFormHelp_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element__icon", true);
    } }, inputs: { content: "content" }, decls: 4, vars: 2, consts: [[1, "slds-button", "slds-button_icon", 3, "nglTooltip", "nglTooltipOpen", "nglTooltipOpenChange"], ["nglIconName", "utility:info", 1, "slds-button__icon"], [1, "slds-assistive-text"]], template: function NglFormHelp_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("nglTooltipOpenChange", function NglFormHelp_Template_button_nglTooltipOpenChange_0_listener($event) { return ctx.isOpen = $event; });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "svg", 1);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3, "Help");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglTooltip", ctx.content)("nglTooltipOpen", ctx.isOpen);
    } }, directives: [NglTooltipTrigger,
        NglIconSvg], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFormHelp.prototype, "content", void 0);

const DIRECTIVES$3 = [
    NglFormLabel,
    NglFormHelp,
];
let NglFormsModule = class NglFormsModule {
};
NglFormsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglFormsModule });
NglFormsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglFormsModule_Factory(t) { return new (t || NglFormsModule)(); }, imports: [[CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule]] });

function getHexFromHsv(hsv) {
    return hsv ? getHexFromRgb(getRgbFromHsv(hsv)) : null;
}
function getRgbFromHsv({ hue, saturation, value }) {
    const hueRatio = hue / 360;
    const satRatio = saturation / 100;
    const valRatio = value / 100;
    let red;
    let green;
    let blue;
    const i = Math.floor(hueRatio * 6);
    const f = hueRatio * 6 - i;
    const p = valRatio * (1 - satRatio);
    const q = valRatio * (1 - f * satRatio);
    const t = valRatio * (1 - (1 - f) * satRatio);
    switch (i % 6) {
        case 0:
            red = valRatio;
            green = t;
            blue = p;
            break;
        case 1:
            red = q;
            green = valRatio;
            blue = p;
            break;
        case 2:
            red = p;
            green = valRatio;
            blue = t;
            break;
        case 3:
            red = p;
            green = q;
            blue = valRatio;
            break;
        case 4:
            red = t;
            green = p;
            blue = valRatio;
            break;
        default:
            red = valRatio;
            green = p;
            blue = q;
    }
    return {
        red: Math.round(red * 255),
        blue: Math.round(blue * 255),
        green: Math.round(green * 255),
    };
}
function getHex(color) {
    return `0${Math.round(color).toString(16)}`.substr(-2);
}
function getHexFromRgb({ red, green, blue }) {
    return `#${getHex(red)}${getHex(green)}${getHex(blue)}`;
}
function getHsvFromHex(hex) {
    return hex ? getHsvFromRgb(getRgbFromHex(hex)) : null;
}
function getHsvFromRgb({ red, green, blue }) {
    const redRatio = red / 255;
    const greenRatio = green / 255;
    const blueRatio = blue / 255;
    const max = Math.max(redRatio, greenRatio, blueRatio);
    const min = Math.min(redRatio, greenRatio, blueRatio);
    const delta = max - min;
    const saturation = max === 0 ? 0 : delta / max * 100;
    const value = max * 100;
    let hue;
    if (max === min) {
        hue = 0;
    }
    else {
        if (redRatio === max) {
            hue =
                (greenRatio - blueRatio) / delta + (greenRatio < blueRatio ? 6 : 0);
        }
        else if (greenRatio === max) {
            hue = (blueRatio - redRatio) / delta + 2;
        }
        else {
            hue = (redRatio - greenRatio) / delta + 4;
        }
        hue *= 60;
    }
    return { hue, saturation, value };
}
const HEX_REGEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
function getRgbFromHex(hex) {
    const result = HEX_REGEX.exec(toSixDigitHex(hex));
    return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16),
    };
}
function toSixDigitHex(value) {
    const shortHandHex = /^#([a-f\d])([a-f\d])([a-f\d])$/i;
    const match = shortHandHex.exec(value);
    if (match) {
        return `#${match[1]}${match[1]}${match[2]}${match[2]}${match[3]}${match[3]}`;
    }
    return value;
}
function isValidHex(value) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(value);
}

/** Injection token that can be used to specify default options. */
const NGL_COLORPICKER_CONFIG = new InjectionToken('ngl-colorpicker-config');
class NglColorpickerConfig {
    constructor() {
        this.swatchColors = [
            '#e3abec', '#c2dbf7', '#9fd6ff', '#9de7da', '#9df0c0', '#fff099', '#fed49a',
            '#d073e0', '#86baf3', '#5ebbff', '#44d8be', '#3be282', '#ffe654', '#ffb758',
            '#bd35bd', '#5779c1', '#5679c0', '#00aea9', '#3cba4c', '#f5bc25', '#f99221',
            '#580d8c', '#001970', '#0a2399', '#0b7477', '#0b6b50', '#b67e11', '#b85d0d',
        ];
        this.variant = 'base';
    }
}

const NGL_COLORPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglColorpicker),
    multi: true
};
let NglColorpicker = class NglColorpicker {
    constructor(defaultConfig, el, renderer, cd) {
        this.el = el;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * An input label as for a form.
         */
        this.label = 'Choose Color';
        /**
         * Placeholder of input box.
         */
        this.placeholder = '';
        /**
         * Text for cancel button on popover.
         */
        this.cancelButtonLabel = 'Cancel';
        /**
         * Text for submit button of popover.
         */
        this.submitButtonLabel = 'Done';
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        this.required = false;
        /**
         * Error message when hex color input is invalid.
         */
        this.invalidColorLabel = 'Please ensure value is correct';
        /**
         * Text for swatch tab of popover.
         */
        this.swatchTabLabel = 'Default';
        /**
         * Text for custom tab of popover.
         */
        this.customTabLabel = 'Custom';
        /**
         * Whether to make the hex color input readonly.
         */
        this.readonlyInput = false;
        /**
         * Determines which tab is visible when popover opens.
         */
        this.defaultSelectedTab = 'swatches';
        this.uid = uniqueId('colorpicker');
        this.hexCurrent = '#FFF';
        this.hsvCurrent = getHsvFromHex(this.hexCurrent);
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker');
        const config = Object.assign(Object.assign({}, new NglColorpickerConfig()), defaultConfig);
        this.swatchColors = config.swatchColors;
        this.variant = config.variant;
    }
    writeValue(value) {
        this.color = value || '';
        if (isValidHex(value)) {
            this.hexCurrent = value;
            this.hsvCurrent = getHsvFromHex(value);
        }
        this.cd.detectChanges();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onSwatchSelection(hex) {
        this.hsvCurrent = getHsvFromHex(hex);
        this.hexCurrent = hex;
    }
    onCustomSelection(hsv) {
        this.hsvCurrent = hsv;
        this.hexCurrent = getHexFromHsv(hsv);
    }
    openChange(open) {
        this.open = open;
    }
    cancel() {
        this.open = false;
    }
    done() {
        this.open = false;
        if (this.hexCurrent !== this.color) {
            this.color = this.hexCurrent;
            this.onChange(this.color);
        }
    }
    canApply() {
        return isValidHex(this.hexCurrent);
    }
    onInput(hex) {
        this.color = hex;
        if (isValidHex(hex)) {
            this.onSwatchSelection(hex);
            this.onChange(hex);
        }
        else {
            this.onChange(null);
        }
    }
    get isValidInput() {
        return !this.color || isValidHex(this.color);
    }
};
NglColorpicker.ɵfac = function NglColorpicker_Factory(t) { return new (t || NglColorpicker)(ɵngcc0.ɵɵdirectiveInject(NGL_COLORPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglColorpicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpicker, selectors: [["ngl-colorpicker"]], inputs: { label: "label", placeholder: "placeholder", cancelButtonLabel: "cancelButtonLabel", submitButtonLabel: "submitButtonLabel", required: "required", invalidColorLabel: "invalidColorLabel", swatchTabLabel: "swatchTabLabel", customTabLabel: "customTabLabel", readonlyInput: "readonlyInput", defaultSelectedTab: "defaultSelectedTab", swatchColors: "swatchColors", variant: "variant", fieldLevelHelpTooltip: "fieldLevelHelpTooltip" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_COLORPICKER_VALUE_ACCESSOR])], decls: 20, vars: 21, consts: [[1, "slds-color-picker__summary", "slds-form-element"], [1, "slds-form-element__label", "slds-color-picker__summary-label", 3, "nglFormLabel", "required"], ["class", "slds-m-horizontal_xx-small", 3, "content", 4, "ngIf"], [1, "slds-form-element__control"], ["nglPopoverPlacement", "bottom-left", "nglPopoverClass", "slds-color-picker__selector", "nglPopoverCloseVisible", "false", 1, "slds-button", "slds-color-picker__summary-button", "slds-button_icon", "slds-button_icon-more", 3, "title", "nglPopover", "nglPopoverOpen", "nglPopoverFooter", "disabled", "nglPopoverOpenChange"], ["nglColorpickerSwatch", "", 1, "slds-swatch", 3, "color"], ["class", "slds-button__icon slds-button__icon_small slds-m-left_xx-small", "nglIconName", "utility:down", 4, "ngIf"], [1, "slds-assistive-text"], [1, "slds-color-picker__summary-input"], ["type", "text", "maxlength", "7", 1, "slds-input", 3, "id", "value", "disabled", "readOnly", "placeholder", "input"], ["class", "slds-form-error", 3, "nglInternalOutlet", 4, "ngIf"], ["tip", ""], ["swatches", ""], ["custom", ""], ["footer", ""], [1, "slds-m-horizontal_xx-small", 3, "content"], ["nglIconName", "utility:down", 1, "slds-button__icon", "slds-button__icon_small", "slds-m-left_xx-small"], [1, "slds-form-error", 3, "nglInternalOutlet"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "selected", "selectedChange", 4, "ngSwitchDefault"], [3, "ngTemplateOutlet"], [3, "selected", "selectedChange"], ["ngl-tab", "", "id", "swatches", 3, "label"], ["ngl-tab", "", "id", "custom", 3, "label"], [3, "hex", "swatchColors", "hexChange"], [3, "hsv", "hsvChange"], [1, "slds-color-picker__selector-footer"], ["type", "button", 1, "slds-button", "slds-button_neutral", 3, "click"], ["type", "button", 1, "slds-button", "slds-button_brand", 3, "disabled", "click"]], template: function NglColorpicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtemplate(2, NglColorpicker_ngl_form_help_2_Template, 1, 1, "ngl-form-help", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "button", 4);
        ɵngcc0.ɵɵlistener("nglPopoverOpenChange", function NglColorpicker_Template_button_nglPopoverOpenChange_4_listener($event) { return ctx.openChange($event); });
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵtemplate(6, NglColorpicker__svg_svg_6_Template, 1, 0, "svg", 6);
        ɵngcc0.ɵɵelementStart(7, "span", 7);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 8);
        ɵngcc0.ɵɵelementStart(10, "input", 9);
        ɵngcc0.ɵɵlistener("input", function NglColorpicker_Template_input_input_10_listener($event) { return ctx.onInput($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglColorpicker_p_11_Template, 1, 1, "p", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, NglColorpicker_ng_template_12_Template, 4, 3, "ng-template", null, 11, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(14, NglColorpicker_ng_template_14_Template, 1, 2, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, NglColorpicker_ng_template_16_Template, 1, 1, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(18, NglColorpicker_ng_template_18_Template, 5, 3, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r161 = ɵngcc0.ɵɵreference(13);
        const _r167 = ɵngcc0.ɵɵreference(19);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isValidInput);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "-summary-input");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("title", ctx.label)("nglPopover", _r161)("nglPopoverOpen", ctx.open)("nglPopoverFooter", _r167)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.isValidInput ? ctx.color : ctx.hexCurrent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.label, ": ", ctx.color, "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-summary-input")("value", ctx.color)("disabled", ctx.disabled)("readOnly", ctx.readonlyInput)("placeholder", ctx.placeholder || "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isValidInput);
    } }, directives: function () { return [NglFormLabel, ɵngcc1.NgIf, NglPopoverTrigger,
        NglColorpickerSwatch,
        NglFormHelp,
        NglIconSvg,
        NglInternalOutlet, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgSwitchDefault, ɵngcc1.NgTemplateOutlet, NglTabs,
        NglTab,
        NglColorpickerSwatches,
        NglColorpickerCustom]; }, encapsulation: 2, changeDetection: 0 });
NglColorpicker.ctorParameters = () => [
    { type: NglColorpickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_COLORPICKER_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "cancelButtonLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "submitButtonLabel", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "invalidColorLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "swatchTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "customTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglColorpicker.prototype, "swatchColors", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "readonlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpicker.prototype, "defaultSelectedTab", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpicker.prototype, "variant", void 0);
NglColorpicker = __decorate([ __param(0, Optional()), __param(0, Inject(NGL_COLORPICKER_CONFIG)),
    __metadata("design:paramtypes", [NglColorpickerConfig,
        ElementRef,
        Renderer2,
        ChangeDetectorRef])
], NglColorpicker);

let NglColorpickerSwatch = class NglColorpickerSwatch {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, 'slds-swatch');
    }
};
NglColorpickerSwatch.ɵfac = function NglColorpickerSwatch_Factory(t) { return new (t || NglColorpickerSwatch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatch.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerSwatch, selectors: [["", "nglColorpickerSwatch", ""]], hostVars: 2, hostBindings: function NglColorpickerSwatch_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("background", ctx.color, ɵngcc0.ɵɵdefaultStyleSanitizer);
    } }, inputs: { color: "color" }, attrs: _c12, decls: 2, vars: 1, consts: [["aria-hidden", "true", 1, "slds-assistive-text"]], template: function NglColorpickerSwatch_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
NglColorpickerSwatch.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('style.background'),
    Input(),
    __metadata("design:type", String)
], NglColorpickerSwatch.prototype, "color", void 0);
NglColorpickerSwatch = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatch);

let NglColorpickerCustom = class NglColorpickerCustom {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hsvChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__custom');
    }
    ngOnChanges(changes) {
        if (changes.hsv) {
            this.hex = getHexFromHsv(this.hsv);
        }
    }
    onHsvChange($event) {
        this.hsvChange.emit($event);
    }
    onHexChange(hex) {
        const hsv = getHsvFromHex(hex);
        this.hsvChange.emit(hsv);
    }
};
NglColorpickerCustom.ɵfac = function NglColorpickerCustom_Factory(t) { return new (t || NglColorpickerCustom)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerCustom.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerCustom, selectors: [["ngl-colorpicker-custom"]], inputs: { hsv: "hsv" }, outputs: { hsvChange: "hsvChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[3, "hsv", "hsvChange"], [3, "hex", "hexChange"]], template: function NglColorpickerCustom_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngl-colorpicker-range", 0);
        ɵngcc0.ɵɵlistener("hsvChange", function NglColorpickerCustom_Template_ngl_colorpicker_range_hsvChange_0_listener($event) { return ctx.onHsvChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "ngl-colorpicker-inputs", 1);
        ɵngcc0.ɵɵlistener("hexChange", function NglColorpickerCustom_Template_ngl_colorpicker_inputs_hexChange_1_listener($event) { return ctx.onHexChange($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hsv", ctx.hsv);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hex", ctx.hex);
    } }, directives: function () { return [NglColorpickerRange,
        NglColorpickerInputs]; }, encapsulation: 2, changeDetection: 0 });
NglColorpickerCustom.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpickerCustom.prototype, "hsv", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerCustom.prototype, "hsvChange", void 0);
NglColorpickerCustom = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerCustom);

let NglColorpickerRange = class NglColorpickerRange {
    constructor(document) {
        this.document = document;
        this.hsvChange = new EventEmitter();
        this.uid = uniqueId('colorpicker-range');
        this._hsv = { hue: 0, saturation: 0, value: 0 };
    }
    set hsv(hsv) {
        if (hsv) {
            this._hsv = hsv;
        }
    }
    get hsv() {
        return this._hsv;
    }
    get hex() {
        return getHexFromHsv(this.hsv);
    }
    ngAfterViewInit() {
        this.dragSubscription = this.setupDrag().subscribe((mm) => this.emitChange(mm));
    }
    hueSliderChange(value) {
        this.emitChange({ hue: value });
    }
    rangeIndicatorKeyboard(evt) {
        let saturation = this.hsv.saturation;
        let value = this.hsv.value;
        switch (evt.keyCode) {
            case LEFT_ARROW:
                saturation = this.limit(saturation - 1);
                break;
            case RIGHT_ARROW:
                saturation = this.limit(saturation + 1);
                break;
            case UP_ARROW:
                value = this.limit(value + 1);
                break;
            case DOWN_ARROW:
                value = this.limit(value - 1);
                break;
            default:
                return;
        }
        trapEvent(evt);
        this.emitChange({ saturation, value });
    }
    indicatorStyle() {
        return {
            'bottom.%': this.hsv.value,
            'left.%': this.hsv.saturation,
            'background': this.hex,
        };
    }
    ngOnDestroy() {
        if (this.dragSubscription) {
            this.dragSubscription.unsubscribe();
            this.dragSubscription = null;
        }
    }
    emitChange(hsv) {
        this.hsvChange.emit(Object.assign(Object.assign({}, this.hsv), hsv));
    }
    limit(value) {
        return Math.min(Math.max(value, 0), 100);
    }
    setupDrag() {
        const dragTarget = this.rangeIndicatorContainer.nativeElement;
        const pressEnd = merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend'));
        const pressMove = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));
        const pressStart = merge(fromEvent(dragTarget, 'mousedown'), fromEvent(dragTarget, 'touchstart'));
        return pressStart.pipe(flatMap((md) => {
            this.rangeIndicator.nativeElement.focus();
            const rect = dragTarget.getBoundingClientRect();
            return pressMove.pipe(startWith(md), map((mm) => {
                mm.preventDefault();
                const saturation = Math.round((mm.clientX - rect.left) / rect.width * 100);
                const value = Math.round((rect.bottom - mm.clientY) / rect.height * 100);
                return { saturation: this.limit(saturation), value: this.limit(value) };
            }), takeUntil(pressEnd));
        }));
    }
};
NglColorpickerRange.ɵfac = function NglColorpickerRange_Factory(t) { return new (t || NglColorpickerRange)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
NglColorpickerRange.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerRange, selectors: [["ngl-colorpicker-range"]], viewQuery: function NglColorpickerRange_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c13, true);
        ɵngcc0.ɵɵviewQuery(_c14, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeIndicatorContainer = _t.first);
    } }, inputs: { hsv: "hsv" }, outputs: { hsvChange: "hsvChange" }, decls: 14, vars: 11, consts: [[1, "slds-assistive-text"], [1, "slds-color-picker__custom-range"], ["rangeIndicatorContainer", ""], ["href", "javascript:void(0);", "aria-live", "assertive", "aria-atomic", "true", 1, "slds-color-picker__range-indicator", 3, "ngStyle", "keydown"], ["rangeIndicator", ""], [1, "slds-color-picker__hue-and-preview"], ["type", "range", "min", "0", "max", "360", 1, "slds-color-picker__hue-slider", 3, "id", "value", "input"], ["hueSlider", ""], ["nglColorpickerSwatch", "", 3, "color"]], template: function NglColorpickerRange_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "p", 0);
        ɵngcc0.ɵɵtext(1, "Use arrow keys to select a saturation and brightness, on an x and y axis.");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "a", 3, 4);
        ɵngcc0.ɵɵlistener("keydown", function NglColorpickerRange_Template_a_keydown_4_listener($event) { return ctx.rangeIndicatorKeyboard($event); });
        ɵngcc0.ɵɵelementStart(6, "span", 0);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "label", 0);
        ɵngcc0.ɵɵtext(10, "Select Hue");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "input", 6, 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerRange_Template_input_input_11_listener($event) { return ctx.hueSliderChange($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(13, "span", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.uid + "-instructions");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("background", "hsl(" + ctx.hsv.hue + ", 100%, 50%)", ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.indicatorStyle());
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.uid + "-instructions");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate2("Saturation: ", ctx.hsv.saturation, "%. Brightness: ", ctx.hsv.value, "%.");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "-hue");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-hue")("value", ctx.hsv.hue);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("color", ctx.hex);
    } }, directives: [ɵngcc1.NgStyle, NglColorpickerSwatch], encapsulation: 2, changeDetection: 0 });
NglColorpickerRange.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange.prototype, "hsv", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerRange.prototype, "hsvChange", void 0);
__decorate([
    ViewChild('rangeIndicator'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicator", void 0);
__decorate([
    ViewChild('rangeIndicatorContainer'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicatorContainer", void 0);
NglColorpickerRange = __decorate([ __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange);

let NglColorpickerInputs = class NglColorpickerInputs {
    constructor() {
        this.hexChange = new EventEmitter();
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.uid = uniqueId('colorpicker-inputs');
    }
    set hex(hex) {
        if (hex) {
            this._hex = hex;
            const { red, green, blue } = getRgbFromHex(this.hex);
            this.red = red;
            this.green = green;
            this.blue = blue;
        }
    }
    get hex() {
        return this._hex;
    }
    updateHex(value) {
        const isValid = isValidHex(value);
        if (!isValid) {
            this.red = this.green = this.blue = null;
        }
        this.hexChange.emit(isValid ? value : null);
    }
    onRGB(key, value) {
        this[key] = value;
        const hex = this.isRGBValid() ? getHexFromRgb({ red: this.red, green: this.green, blue: this.blue }) : null;
        this.hexChange.emit(hex);
    }
    get isHexInvalid() {
        return this.red === null && this.green === null && this.blue === null;
    }
    isColorNumberValid(key) {
        const value = this[key];
        return _isNumberValue(value) && value >= 0 && value <= 255;
    }
    isRGBValid() {
        return ['red', 'green', 'blue'].every((prop) => this.isColorNumberValid(prop));
    }
};
NglColorpickerInputs.ɵfac = function NglColorpickerInputs_Factory(t) { return new (t || NglColorpickerInputs)(); };
NglColorpickerInputs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerInputs, selectors: [["ngl-colorpicker-inputs"]], inputs: { hex: "hex" }, outputs: { hexChange: "hexChange" }, decls: 28, vars: 22, consts: [[1, "slds-color-picker__custom-inputs"], [1, "slds-form-element", "slds-color-picker__input-custom-hex"], [1, "slds-form-element__label"], [1, "slds-form-element__control"], ["type", "text", "maxlength", "7", 1, "slds-input", 3, "id", "value", "input"], [1, "slds-form-element"], ["title", "red"], ["type", "text", "maxlength", "3", 1, "slds-input", 3, "id", "value", "input"], ["title", "green"], ["title", "blue"], [1, "slds-color-picker"], ["class", "slds-form-error slds-color-picker__input-custom-error", 4, "ngIf", "ngIfElse"], ["rgbError", ""], [1, "slds-form-error", "slds-color-picker__input-custom-error"], ["class", "slds-form-error slds-color-picker__input-custom-error", 4, "ngIf"]], template: function NglColorpickerInputs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "label", 2);
        ɵngcc0.ɵɵtext(3, "Hex");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵelementStart(5, "input", 4);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_5_listener($event) { return ctx.updateHex($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵelementStart(7, "label", 2);
        ɵngcc0.ɵɵelementStart(8, "abbr", 6);
        ɵngcc0.ɵɵtext(9, "R");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 3);
        ɵngcc0.ɵɵelementStart(11, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_11_listener($event) { return ctx.onRGB("red", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 5);
        ɵngcc0.ɵɵelementStart(13, "label", 2);
        ɵngcc0.ɵɵelementStart(14, "abbr", 8);
        ɵngcc0.ɵɵtext(15, "G");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 3);
        ɵngcc0.ɵɵelementStart(17, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_17_listener($event) { return ctx.onRGB("green", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "div", 5);
        ɵngcc0.ɵɵelementStart(19, "label", 2);
        ɵngcc0.ɵɵelementStart(20, "abbr", 9);
        ɵngcc0.ɵɵtext(21, "B");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(22, "div", 3);
        ɵngcc0.ɵɵelementStart(23, "input", 7);
        ɵngcc0.ɵɵlistener("input", function NglColorpickerInputs_Template_input_input_23_listener($event) { return ctx.onRGB("blue", $event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(24, "div", 10);
        ɵngcc0.ɵɵtemplate(25, NglColorpickerInputs_p_25_Template, 2, 0, "p", 11);
        ɵngcc0.ɵɵtemplate(26, NglColorpickerInputs_ng_template_26_Template, 1, 1, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r191 = ɵngcc0.ɵɵreference(27);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.isHexInvalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "hex");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "hex")("value", ctx.hex);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("red"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "red");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "red")("value", ctx.red);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("green"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "green");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "green")("value", ctx.green);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-has-error", !ctx.isColorNumberValid("blue"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.uid + "blue");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "blue")("value", ctx.blue);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isHexInvalid)("ngIfElse", _r191);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglColorpickerInputs.prototype, "hex", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerInputs.prototype, "hexChange", void 0);

let NglColorpickerSwatchTrigger = class NglColorpickerSwatchTrigger {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatch-trigger');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'option');
    }
    onSelect() {
        return this.selectedChange.emit();
    }
    focus() {
        this.el.nativeElement.focus();
        this.onSelect();
    }
};
NglColorpickerSwatchTrigger.ɵfac = function NglColorpickerSwatchTrigger_Factory(t) { return new (t || NglColorpickerSwatchTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatchTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglColorpickerSwatchTrigger, selectors: [["", "nglColorpickerSwatchTrigger", ""]], hostVars: 2, hostBindings: function NglColorpickerSwatchTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglColorpickerSwatchTrigger_click_HostBindingHandler() { return ctx.onSelect(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ngl-color-picker__swatch-selected", ctx.selected);
    } }, inputs: { selected: "selected" }, outputs: { selectedChange: "selectedChange" } });
NglColorpickerSwatchTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.ngl-color-picker__swatch-selected'),
    Input(),
    __metadata("design:type", Boolean)
], NglColorpickerSwatchTrigger.prototype, "selected", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerSwatchTrigger.prototype, "selectedChange", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglColorpickerSwatchTrigger.prototype, "onSelect", null);
NglColorpickerSwatchTrigger = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatchTrigger);

let NglColorpickerSwatches = class NglColorpickerSwatches {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hexChange = new EventEmitter();
        this.swatchColors = [];
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatches');
    }
    ngOnChanges() {
        this.activeIndex = Math.max(this.swatchColors.indexOf(this.hex), 0);
    }
    onSelectViaInteraction(evt) {
        let direction = 0;
        switch (evt.keyCode) {
            case LEFT_ARROW:
            case UP_ARROW:
                direction = -1;
                break;
            case RIGHT_ARROW:
            case DOWN_ARROW:
                direction = 1;
                break;
            default:
                return;
        }
        trapEvent(evt);
        const activeIndex = this.swatchColors.indexOf(this.hex);
        const index = (this.triggers.length + activeIndex + direction) % this.triggers.length;
        const trigger = this.triggers.toArray()[index];
        trigger.focus();
    }
    isSelected(hex) {
        return hex === this.hex;
    }
    onSelect(hex) {
        this.hexChange.emit(hex);
    }
};
NglColorpickerSwatches.ɵfac = function NglColorpickerSwatches_Factory(t) { return new (t || NglColorpickerSwatches)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglColorpickerSwatches.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglColorpickerSwatches, selectors: [["ngl-colorpicker-swatches"]], viewQuery: function NglColorpickerSwatches_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglColorpickerSwatchTrigger, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.triggers = _t);
    } }, hostBindings: function NglColorpickerSwatches_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NglColorpickerSwatches_keydown_HostBindingHandler($event) { return ctx.onSelectViaInteraction($event); });
    } }, inputs: { swatchColors: "swatchColors", hex: "hex" }, outputs: { hexChange: "hexChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "slds-color-picker__swatch", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "slds-color-picker__swatch"], ["nglColorpickerSwatchTrigger", "", "href", "javascript:void(0);", 3, "selected", "selectedChange"], ["nglColorpickerSwatch", "", 3, "color"]], template: function NglColorpickerSwatches_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglColorpickerSwatches_li_0_Template, 3, 3, "li", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.swatchColors);
    } }, directives: [ɵngcc1.NgForOf, NglColorpickerSwatchTrigger,
        NglColorpickerSwatch], styles: [".ngl-color-picker__swatch-selected[_ngcontent-%COMP%] {\n      box-shadow: rgb(117, 112, 112) 1px 1px 1px;"], changeDetection: 0 });
NglColorpickerSwatches.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpickerSwatches.prototype, "hex", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerSwatches.prototype, "hexChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglColorpickerSwatches.prototype, "swatchColors", void 0);
__decorate([
    ViewChildren(NglColorpickerSwatchTrigger),
    __metadata("design:type", QueryList)
], NglColorpickerSwatches.prototype, "triggers", void 0);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglColorpickerSwatches.prototype, "onSelectViaInteraction", null);
NglColorpickerSwatches = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatches);

const DIRECTIVES$4 = [
    NglColorpicker,
];
let NglColorpickerModule = class NglColorpickerModule {
};
NglColorpickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglColorpickerModule });
NglColorpickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglColorpickerModule_Factory(t) { return new (t || NglColorpickerModule)(); }, imports: [[
            CommonModule,
            NglIconsModule,
            NglTabsModule,
            NglPopoversModule,
            NglFormsModule,
            NglInternalOutletModule,
        ]] });

let NglOverlaynglOverlayScrolledOutsideViewDirective = class NglOverlaynglOverlayScrolledOutsideViewDirective {
    constructor(cdkOverlay, ngZone, scrollDispatcher) {
        this.cdkOverlay = cdkOverlay;
        this.ngZone = ngZone;
        this.scrollDispatcher = scrollDispatcher;
        this.overlayOutside = new EventEmitter();
    }
    ngOnInit() {
        const elementRef = this.cdkOverlay.origin.elementRef;
        const scrollableAncestors = this.scrollDispatcher.getAncestorScrollContainers(elementRef).map(container => container.getElementRef());
        if (!scrollableAncestors || !scrollableAncestors.length)
            return;
        this.subscription = this.cdkOverlay.positionChange.subscribe(() => {
            const bounds = elementRef.nativeElement.getBoundingClientRect();
            for (let i = 0, n = scrollableAncestors.length; i < n; i++) {
                const ancestorsBounds = scrollableAncestors[i].nativeElement.getBoundingClientRect();
                if (isElementOutside(bounds, ancestorsBounds)) {
                    this.ngZone.run(() => this.overlayOutside.emit());
                    return;
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
};
NglOverlaynglOverlayScrolledOutsideViewDirective.ɵfac = function NglOverlaynglOverlayScrolledOutsideViewDirective_Factory(t) { return new (t || NglOverlaynglOverlayScrolledOutsideViewDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.CdkConnectedOverlay, 2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ScrollDispatcher)); };
NglOverlaynglOverlayScrolledOutsideViewDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglOverlaynglOverlayScrolledOutsideViewDirective, selectors: [["", "nglOverlayScrolledOutsideView", ""]], outputs: { overlayOutside: "nglOverlayScrolledOutsideView" } });
NglOverlaynglOverlayScrolledOutsideViewDirective.ctorParameters = () => [
    { type: CdkConnectedOverlay, decorators: [{ type: Self }] },
    { type: NgZone },
    { type: ScrollDispatcher }
];
__decorate([
    Output('nglOverlayScrolledOutsideView'),
    __metadata("design:type", EventEmitter)
], NglOverlaynglOverlayScrolledOutsideViewDirective.prototype, "overlayOutside", void 0);
NglOverlaynglOverlayScrolledOutsideViewDirective = __decorate([ __param(0, Self()),
    __metadata("design:paramtypes", [CdkConnectedOverlay,
        NgZone,
        ScrollDispatcher])
], NglOverlaynglOverlayScrolledOutsideViewDirective);
/**
 * Gets whether an element is scrolled outside of view by its parent scrolling container.
 * @param element Dimensions of the element (from getBoundingClientRect)
 * @param container Dimensions of element's scrolling container (from getBoundingClientRect)
 * @returns Whether the element is scrolled out of view
 */
function isElementOutside(element, container) {
    return (element.bottom < container.top || element.top > container.bottom ||
        element.right < container.left || element.left > container.right);
}

const DIRECTIVES$5 = [
    NglOverlaynglOverlayScrolledOutsideViewDirective,
];
let NglOverlayModule = class NglOverlayModule {
};
NglOverlayModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglOverlayModule });
NglOverlayModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglOverlayModule_Factory(t) { return new (t || NglOverlayModule)(); }, imports: [[CommonModule]] });

let NglComboboxService = class NglComboboxService {
};
NglComboboxService.ɵfac = function NglComboboxService_Factory(t) { return new (t || NglComboboxService)(); };
NglComboboxService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NglComboboxService, factory: NglComboboxService.ɵfac });

let NglComboboxOption = class NglComboboxOption {
    constructor(element, service, cd, ngZone, renderer) {
        this.element = element;
        this.service = service;
        this.cd = cd;
        this.ngZone = ngZone;
        this.disabled = false;
        this.uid = uniqueId('combo-option');
        this._active = false;
        // Flag to disable scrolling into view when option is activated using mouse
        this.disableNextScrollIntoView = false;
        this.destroyed = false;
        renderer.addClass(element.nativeElement, 'slds-listbox__item');
        renderer.setAttribute(element.nativeElement, 'role', 'presentation');
    }
    // Whether or not the option is currently active and ready to be selected
    set active(active) {
        if (this.active === active || this.destroyed) {
            return;
        }
        this._active = active;
        this.cd.detectChanges();
        if (active) {
            this.service.combobox.inputEl.setAriaActiveDescendant(this.uid);
            this.scrollIntoView();
        }
        else {
            clearTimeout(this.scrollTimer);
        }
    }
    get active() {
        return this._active;
    }
    onSelectViaInteraction(evt) {
        trapEvent(evt);
        if (!this.disabled) {
            this.service.combobox.onOptionSelection(this);
        }
    }
    hover() {
        if (!this.disabled) {
            this.disableNextScrollIntoView = true;
            this.service.combobox.keyManager.setActiveItem(this);
        }
    }
    setActiveStyles() {
        this.active = true;
    }
    setInactiveStyles() {
        this.active = false;
    }
    scrollIntoView() {
        if (this.disableNextScrollIntoView) {
            this.disableNextScrollIntoView = false;
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.scrollTimer = setTimeout(() => {
                const li = this.element.nativeElement;
                menuItemScroll(li.parentElement.parentElement, li);
            }, 0);
        });
    }
    ngOnDestroy() {
        this.destroyed = true;
        clearTimeout(this.scrollTimer);
    }
};
NglComboboxOption.ɵfac = function NglComboboxOption_Factory(t) { return new (t || NglComboboxOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NglComboboxService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglComboboxOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglComboboxOption, selectors: [["ngl-combobox-option"], ["", "nglComboboxOption", ""]], hostBindings: function NglComboboxOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function NglComboboxOption_mousedown_HostBindingHandler($event) { return ctx.onSelectViaInteraction($event); })("mouseenter", function NglComboboxOption_mouseenter_HostBindingHandler() { return ctx.hover(); });
    } }, inputs: { disabled: "disabled", value: "value", label: "label", selected: "selected" }, decls: 7, vars: 10, consts: [["role", "option", 1, "slds-media", "slds-listbox__option", "slds-listbox__option_plain", "slds-media_small", "slds-media_center"], [1, "slds-media__figure", "slds-listbox__option-icon"], ["class", "slds-icon_container slds-icon-utility-check slds-current-color", 4, "ngIf"], [1, "slds-media__body"], [1, "slds-truncate"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-icon_container", "slds-icon-utility-check", "slds-current-color"], ["nglIconName", "utility:check", 1, "slds-icon", "slds-icon_x-small"], [1, "slds-assistive-text"]], template: function NglComboboxOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, NglComboboxOption_span_2_Template, 2, 0, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtemplate(5, NglComboboxOption_span_5_Template, 2, 0, "span", 5);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-focus", ctx.active)("slds-is-selected", ctx.selected);
        ɵngcc0.ɵɵattribute("id", ctx.uid)("aria-selected", ctx.selected || null)("aria-disabled", ctx.disabled || null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selected);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selected);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglComboboxOption.ctorParameters = () => [
    { type: ElementRef },
    { type: NglComboboxService },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglComboboxOption.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglComboboxOption.prototype, "label", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglComboboxOption.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglComboboxOption.prototype, "disabled", void 0);
__decorate([
    HostListener('mousedown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], NglComboboxOption.prototype, "onSelectViaInteraction", null);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxOption.prototype, "hover", null);
NglComboboxOption = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NglComboboxService,
        ChangeDetectorRef,
        NgZone,
        Renderer2])
], NglComboboxOption);

const MAX_INTERVAL_BETWEEN_KEYSTROKES = 300; // ms
let NglComboboxInput = class NglComboboxInput {
    constructor(service, el, renderer) {
        this.service = service;
        this.el = el;
        this.renderer = renderer;
        const { nativeElement } = this.el;
        this.renderer.addClass(nativeElement, 'slds-input');
        this.renderer.addClass(nativeElement, 'slds-combobox__input');
        this.renderer.setAttribute(nativeElement, 'autoComplete', 'off');
        this.renderer.setAttribute(nativeElement, 'role', 'textbox');
        this.renderer.setAttribute(nativeElement, 'aria-controls', this.service.combobox.uid);
        if (!nativeElement.id) {
            this.renderer.setAttribute(nativeElement, 'id', uniqueId('combobox-input'));
        }
        const keyboardEvent$ = fromEvent(nativeElement, 'keypress').pipe(map((e) => e.keyCode));
        this.keyboardBuffer$ = keyboardEvent$.pipe(buffer(keyboardEvent$.pipe(debounceTime(MAX_INTERVAL_BETWEEN_KEYSTROKES))), map((keyCodes) => keyCodes.map((c) => String.fromCharCode(c)).join('')));
    }
    get isReadonly() {
        return this.service.combobox.variant === 'base' || this.service.combobox.hasLookupSingleSelection;
    }
    get ariaAutocomplete() {
        return this.service.combobox.isLookup ? 'list' : null;
    }
    get hasReadonlyValue() {
        return this.service.combobox.hasLookupSingleSelection;
    }
    get id() {
        return this.el.nativeElement.id;
    }
    setAriaActiveDescendant(uid) {
        if (uid) {
            this.renderer.setAttribute(this.el.nativeElement, 'aria-activedescendant', uid);
        }
        else {
            this.renderer.removeAttribute(this.el.nativeElement, 'aria-activedescendant');
        }
    }
    setValue(value) {
        this.renderer.setProperty(this.el.nativeElement, 'value', value !== null ? value : '');
    }
    focus() {
        this.el.nativeElement.focus();
    }
    onMouseInteraction() {
        if (this.service.combobox.hasLookupSingleSelection || (this.service.combobox.open && this.service.combobox.isLookup)) {
            return;
        }
        this.service.combobox.openChange.emit(!this.service.combobox.open);
    }
    onBlur() {
        this.service.combobox.openChange.emit(false);
    }
    onKeyboard(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ESCAPE) {
            // This is handled by CDK, and detaches overlay
            return;
        }
        if (this.service.combobox.open) {
            switch (keyCode) {
                // User selects currently active option by pressing the `Enter` key
                case ENTER:
                    trapEvent(evt);
                    this.service.combobox.onOptionSelection();
                    return;
                // Propagate to keymanager
                default:
                    this.service.combobox.keyManager.onKeydown(evt);
                    return;
            }
        }
        else {
            // Do nothing if readonly Lookup
            if (this.service.combobox.hasLookupSingleSelection) {
                return;
            }
            // Pressing the `Down` or `Enter` key will expand the collapsed menu
            if (keyCode === DOWN_ARROW || keyCode === ENTER) {
                trapEvent(evt);
                this.service.combobox.openChange.emit(true);
                return;
            }
            // Any key on Lookup should expand the collapsed menu
            if (this.service.combobox.isLookup) {
                // Delay emission so actual value of the input has been updated
                setTimeout(() => this.service.combobox.openChange.emit(true), 0);
            }
        }
    }
};
NglComboboxInput.ɵfac = function NglComboboxInput_Factory(t) { return new (t || NglComboboxInput)(ɵngcc0.ɵɵdirectiveInject(NglComboboxService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglComboboxInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglComboboxInput, selectors: [["input", "nglCombobox", ""]], hostVars: 4, hostBindings: function NglComboboxInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglComboboxInput_click_HostBindingHandler() { return ctx.onMouseInteraction(); })("blur", function NglComboboxInput_blur_HostBindingHandler() { return ctx.onBlur(); })("keydown", function NglComboboxInput_keydown_HostBindingHandler($event) { return ctx.onKeyboard($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("readOnly", ctx.isReadonly);
        ɵngcc0.ɵɵattribute("aria-autocomplete", ctx.ariaAutocomplete);
        ɵngcc0.ɵɵclassProp("slds-combobox__input-value", ctx.hasReadonlyValue);
    } } });
NglComboboxInput.ctorParameters = () => [
    { type: NglComboboxService },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('readOnly'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "isReadonly", null);
__decorate([
    HostBinding('attr.aria-autocomplete'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "ariaAutocomplete", null);
__decorate([
    HostBinding('class.slds-combobox__input-value'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "hasReadonlyValue", null);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onMouseInteraction", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onBlur", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onKeyboard", null);
NglComboboxInput = __decorate([ __metadata("design:paramtypes", [NglComboboxService,
        ElementRef,
        Renderer2])
], NglComboboxInput);

let NglCombobox = class NglCombobox {
    constructor(ngZone, cd, service) {
        this.ngZone = ngZone;
        this.cd = cd;
        this.service = service;
        this.variant = 'base';
        this.uid = uniqueId('combobox');
        this.open = false;
        this.openChange = new EventEmitter();
        this.selectionChange = new EventEmitter();
        this.multiple = false;
        this.visibleLength = 5;
        this.closeOnSelection = true;
        this.overlayWidth = 0;
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS['left']];
        this.selectionValueFn = (selection) => {
            if (selection.length > 0) {
                if (this.multiple && this.isLookup) {
                    return '';
                }
                return selection.length === 1 ? selection[0] : `${selection.length} options selected`;
            }
            return '';
        };
        this.service.combobox = this;
        // this.service.openChange = this.openChange;
    }
    set data(data) {
        this._data = (data || []).map((d) => {
            if (typeof d === 'string') {
                // Support array of strings as options, by mapping to NglComboboxOptionItem
                return { value: d, label: d };
            }
            else if (!d.label) {
                // Use `value` if missing `label`
                return Object.assign(Object.assign({}, d), { label: d.value });
            }
            return d;
        });
    }
    get data() {
        return this._data;
    }
    get activeOption() {
        return this.keyManager ? this.keyManager.activeItem : null;
    }
    get selectedOptions() {
        return this.data ? this.data.filter(d => this.isSelected(d.value)) : [];
    }
    get isLookup() {
        return this.variant === 'lookup';
    }
    get hasLookupSingleSelection() {
        return this.isLookup && !this.multiple && this.selectedOptions.length > 0;
    }
    ngOnChanges(changes) {
        if (changes.selection) {
            this.calculateDisplayValue();
        }
    }
    onAttach() {
        // Same width as the trigger element
        this.overlayWidth = this.overlayOrigin.elementRef.nativeElement.offsetWidth;
        this.cd.detectChanges();
        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        // Activate selected item or first option
        const selectedOption = this.options.find(o => o.selected);
        if (selectedOption) {
            this.keyManager.setActiveItem(selectedOption);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
        // Listen to button presses if picklist to activate matching option
        this.keyboardSubscribe(this.variant === 'base');
        // When it is open we listen for option changes in order to fix active option and handle scroll
        this.optionChangesSubscription = this.options.changes.subscribe(() => {
            if (!this.activeOption || this.options.toArray().indexOf(this.activeOption) === -1) {
                // Activate first option if active one is destroyed
                this.keyManager.setFirstItemActive();
            }
            else {
                this.activeOption.scrollIntoView();
            }
            this.updateMenuHeight();
        });
        this.updateMenuHeight();
    }
    onDetach() {
        if (this.open) {
            this.close();
            return;
        }
        // Clear aria-activedescendant when menu is closed
        this.inputEl.setAriaActiveDescendant(null);
        this.detach();
    }
    trackByOption(index, option) {
        return option.value;
    }
    dropdownClass() {
        return {
            [`slds-dropdown_length-${this.visibleLength}`]: this.visibleLength > 0,
        };
    }
    inputIconRight() {
        return this.isLookup ? 'utility:search' : 'utility:down';
    }
    hasNoMatches() {
        return this.isLookup && this.data.length === 0 && !this.loadingMore;
    }
    onOptionSelection(option = this.activeOption) {
        const selection = addOptionToSelection(option.value, this.selection, this.multiple);
        this.selectionChange.emit(selection);
        if (this.closeOnSelection) {
            this.close();
        }
    }
    // Trigger by clear button on Lookup
    onClearSelection() {
        this.selectionChange.emit(null);
        setTimeout(() => this.inputEl.focus(), 0);
    }
    /**
     * Check whether value is currently selected.
     *
     * @param value The value in test, whether is (part of) selection or not
     */
    isSelected(value) {
        return isOptionSelected(value, this.selection, this.multiple);
    }
    ngOnDestroy() {
        this.detach();
    }
    close() {
        this.openChange.emit(false);
    }
    detach() {
        this.keyboardSubscribe(false);
        this.keyManager = null;
        if (this.optionChangesSubscription) {
            this.optionChangesSubscription.unsubscribe();
            this.optionChangesSubscription = null;
        }
    }
    calculateDisplayValue() {
        const value = this.selectionValueFn(this.selectedOptions.map(option => option.label));
        this.inputEl.setValue(value);
    }
    keyboardSubscribe(listen) {
        if (this.keyboardSubscription) {
            this.keyboardSubscription.unsubscribe();
            this.keyboardSubscription = null;
        }
        if (listen) {
            this.keyboardSubscription = this.inputEl.keyboardBuffer$.subscribe((pattern) => {
                pattern = pattern.toLocaleLowerCase();
                const options = this.options.toArray();
                const activeIndex = this.activeOption ? this.keyManager.activeItemIndex + 1 : 0;
                for (let i = 0, n = options.length; i < n; i++) {
                    const index = (activeIndex + i) % n;
                    const option = options[index];
                    if (!option.disabled && option.label.toLocaleLowerCase().substr(0, pattern.length) === pattern) {
                        this.keyManager.setActiveItem(option);
                        break;
                    }
                }
            });
        }
    }
    updateMenuHeight() {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            const height = this.dropdownElementRef.nativeElement.offsetHeight;
            overlayRef.updateSize({
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
};
NglCombobox.ɵfac = function NglCombobox_Factory(t) { return new (t || NglCombobox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NglComboboxService)); };
NglCombobox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglCombobox, selectors: [["ngl-combobox"]], contentQueries: function NglCombobox_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglComboboxInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    } }, viewQuery: function NglCombobox_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c15, true);
        ɵngcc0.ɵɵviewQuery(_c16, true);
        ɵngcc0.ɵɵviewQuery(_c17, true);
        ɵngcc0.ɵɵviewQuery(NglComboboxOption, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayOrigin = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cdkOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostAttrs: ["class.slds-form-element", "true"], inputs: { variant: "variant", open: "open", multiple: "multiple", visibleLength: "visibleLength", closeOnSelection: "closeOnSelection", selectionValueFn: "selectionValueFn", data: ["options", "data"], label: "label", selection: "selection", loading: "loading", loadingMore: "loadingMore" }, outputs: { openChange: "openChange", selectionChange: "selectionChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NglComboboxService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c19, decls: 14, vars: 18, consts: [[3, "nglFormLabel"], [1, "slds-form-element__control"], [1, "slds-combobox_container"], ["aria-haspopup", "listbox", "role", "combobox", 1, "slds-combobox", "slds-dropdown-trigger", "slds-dropdown-trigger_click"], ["role", "none", "cdkOverlayOrigin", "", 1, "slds-combobox__form-element", "slds-input-has-icon"], ["overlayOrigin", "cdkOverlayOrigin"], ["class", "slds-input__icon-group slds-input__icon-group_right", 4, "ngIf", "ngIfElse"], ["iconRight", ""], ["iconTpl", ""], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOpen", "nglOverlayScrolledOutsideView", "attach", "detach"], ["cdkOverlay", "cdkConnectedOverlay"], [1, "slds-input__icon-group", "slds-input__icon-group_right"], ["role", "status", 1, "slds-spinner", "slds-spinner_brand", "slds-spinner_x-small", "slds-input__spinner"], [1, "slds-assistive-text"], [1, "slds-spinner__dot-a"], [1, "slds-spinner__dot-b"], [3, "ngTemplateOutlet"], ["class", "slds-button slds-button_icon slds-input__icon slds-input__icon_right", "type", "button", "title", "Remove selected option", 3, "click", 4, "ngIf", "ngIfElse"], ["type", "button", "title", "Remove selected option", 1, "slds-button", "slds-button_icon", "slds-input__icon", "slds-input__icon_right", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon"], [1, "slds-icon_container", "slds-input__icon", "slds-input__icon_right"], [1, "slds-icon", "slds-icon_x-small", "slds-icon-text-default", 3, "nglIconName"], ["role", "listbox", 1, "slds-dropdown", "slds-dropdown_fluid", 3, "ngClass", "mousedown"], ["dropdown", ""], ["role", "presentation", 1, "slds-listbox", "slds-listbox_vertical"], ["nglComboboxOption", "", 3, "value", "label", "disabled", "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "slds-listbox__item", "role", "presentation", 4, "ngIf"], ["class", "slds-listbox__item", "role", "presentation", "aria-live", "polite", 4, "ngIf"], ["nglComboboxOption", "", 3, "value", "label", "disabled", "selected"], ["role", "presentation", 1, "slds-listbox__item"], [1, "slds-align_absolute-center", "slds-p-top_medium"], ["role", "status", 1, "slds-spinner", "slds-spinner_x-small", "slds-spinner_inline"], ["role", "presentation", "aria-live", "polite", 1, "slds-listbox__item"], [1, "slds-align_absolute-center"], ["role", "status"]], template: function NglCombobox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c18);
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4, 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵtemplate(7, NglCombobox_div_7_Template, 7, 1, "div", 6);
        ɵngcc0.ɵɵtemplate(8, NglCombobox_ng_template_8_Template, 1, 2, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, NglCombobox_ng_template_10_Template, 2, 1, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, NglCombobox_ng_template_12_Template, 6, 6, "ng-template", 9, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵlistener("nglOverlayScrolledOutsideView", function NglCombobox_Template_ng_template_nglOverlayScrolledOutsideView_12_listener() { return ctx.close(); })("attach", function NglCombobox_Template_ng_template_attach_12_listener() { return ctx.onAttach(); })("detach", function NglCombobox_Template_ng_template_detach_12_listener() { return ctx.onDetach(); });
    } if (rf & 2) {
        const _r201 = ɵngcc0.ɵɵreference(5);
        const _r203 = ɵngcc0.ɵɵreference(9);
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label);
        ɵngcc0.ɵɵattribute("for", ctx.inputEl.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("slds-has-selection", ctx.hasLookupSingleSelection);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-is-open", ctx.open);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.open)("aria-owns", ctx.uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-input-has-icon_group-right", ctx.loading)("slds-input-has-icon_right", !ctx.loading);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading)("ngIfElse", _r203);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayOrigin", _r201)("cdkConnectedOverlayMinWidth", ctx.overlayWidth)("cdkConnectedOverlayOpen", ctx.open);
    } }, directives: [NglFormLabel, ɵngcc3.CdkOverlayOrigin, ɵngcc1.NgIf, ɵngcc3.CdkConnectedOverlay, NglOverlaynglOverlayScrolledOutsideViewDirective, ɵngcc1.NgTemplateOutlet, NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgForOf, NglComboboxOption], encapsulation: 2, changeDetection: 0 });
NglCombobox.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NglComboboxService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "label", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "openChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selection", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "multiple", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglCombobox.prototype, "visibleLength", void 0);
__decorate([
    ContentChild(NglComboboxInput, { static: true }),
    __metadata("design:type", NglComboboxInput)
], NglCombobox.prototype, "inputEl", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loading", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loadingMore", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "closeOnSelection", void 0);
__decorate([
    ViewChildren(NglComboboxOption),
    __metadata("design:type", QueryList)
], NglCombobox.prototype, "options", void 0);
__decorate([
    Input('options'),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], NglCombobox.prototype, "data", null);
__decorate([
    ViewChild('overlayOrigin', { static: true }),
    __metadata("design:type", CdkOverlayOrigin)
], NglCombobox.prototype, "overlayOrigin", void 0);
__decorate([
    ViewChild('cdkOverlay'),
    __metadata("design:type", CdkConnectedOverlay)
], NglCombobox.prototype, "cdkOverlay", void 0);
__decorate([
    ViewChild('dropdown'),
    __metadata("design:type", ElementRef)
], NglCombobox.prototype, "dropdownElementRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionValueFn", void 0);
NglCombobox = __decorate([ __metadata("design:paramtypes", [NgZone, ChangeDetectorRef, NglComboboxService])
], NglCombobox);

const DIRECTIVES$6 = [
    NglCombobox,
    NglComboboxOption,
    NglComboboxInput,
];
let NglComboboxesModule = class NglComboboxesModule {
};
NglComboboxesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglComboboxesModule });
NglComboboxesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglComboboxesModule_Factory(t) { return new (t || NglComboboxesModule)(); }, imports: [[CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule]] });

let NglDatatableCell = class NglDatatableCell {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableCell.ɵfac = function NglDatatableCell_Factory(t) { return new (t || NglDatatableCell)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableCell.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDatatableCell, selectors: [["", "nglDatatableCell", ""]] });
NglDatatableCell.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableCell = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglDatatableCell);

let NglDatatableHeadingTemplate = class NglDatatableHeadingTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableHeadingTemplate.ɵfac = function NglDatatableHeadingTemplate_Factory(t) { return new (t || NglDatatableHeadingTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableHeadingTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDatatableHeadingTemplate, selectors: [["", "nglDatatableHeading", ""]] });
NglDatatableHeadingTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableHeadingTemplate = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglDatatableHeadingTemplate);

let NglDatatableColumn = class NglDatatableColumn {
    constructor() {
        this.sortable = false;
        this.truncate = false;
    }
};
NglDatatableColumn.ɵfac = function NglDatatableColumn_Factory(t) { return new (t || NglDatatableColumn)(); };
NglDatatableColumn.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDatatableColumn, selectors: [["ngl-datatable-column"]], contentQueries: function NglDatatableColumn_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableCell, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableHeadingTemplate, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headingTpl = _t.first);
    } }, inputs: { sortable: "sortable", truncate: "truncate", heading: "heading", key: "key", headClass: "headClass", cellClass: "cellClass" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatableColumn.prototype, "heading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatableColumn.prototype, "key", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "headClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "cellClass", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "sortable", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "truncate", void 0);
__decorate([
    ContentChild(NglDatatableCell),
    __metadata("design:type", NglDatatableCell)
], NglDatatableColumn.prototype, "cellTpl", void 0);
__decorate([
    ContentChild(NglDatatableHeadingTemplate),
    __metadata("design:type", NglDatatableHeadingTemplate)
], NglDatatableColumn.prototype, "headingTpl", void 0);

let NglDatatableLoadingOverlay = class NglDatatableLoadingOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableLoadingOverlay.ɵfac = function NglDatatableLoadingOverlay_Factory(t) { return new (t || NglDatatableLoadingOverlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableLoadingOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDatatableLoadingOverlay, selectors: [["", "nglLoadingOverlay", ""]] });
NglDatatableLoadingOverlay.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableLoadingOverlay = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglDatatableLoadingOverlay);
let NglDatatableNoRowsOverlay = class NglDatatableNoRowsOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableNoRowsOverlay.ɵfac = function NglDatatableNoRowsOverlay_Factory(t) { return new (t || NglDatatableNoRowsOverlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglDatatableNoRowsOverlay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDatatableNoRowsOverlay, selectors: [["", "nglNoRowsOverlay", ""]] });
NglDatatableNoRowsOverlay.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableNoRowsOverlay = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglDatatableNoRowsOverlay);

let NglDatatable = class NglDatatable {
    constructor(detector) {
        this.detector = detector;
        this.data = [];
        this.sortChange = new EventEmitter();
        this.loading = false;
        this.rowClick = new EventEmitter();
        this.dataTrackBy = (index, data) => {
            return this.trackByKey ? data[this.trackByKey] : index;
        };
    }
    get showLoading() {
        return this.loading && this.loadingOverlay;
    }
    columnTrackBy(index, column) {
        return column.key || index;
    }
    onColumnSort(column, order) {
        const key = column.key;
        if (!key) {
            throw new Error(`ng-lightning: No "key" property is set for sortable column "${column.heading}"`);
        }
        this.sortChange.emit({ key, order });
    }
    getColumnSortOrder(column) {
        return this.sort && column.key === this.sort.key ? this.sort.order : null;
    }
    onRowClick(event, data) {
        this.rowClick.emit({ event, data });
    }
    ngAfterContentInit() {
        this._columnsSubscription = this.columns.changes.subscribe(() => this.detector.markForCheck());
    }
    ngOnDestroy() {
        if (this._columnsSubscription) {
            this._columnsSubscription.unsubscribe();
            this._columnsSubscription = null;
        }
    }
};
NglDatatable.ɵfac = function NglDatatable_Factory(t) { return new (t || NglDatatable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglDatatable.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatatable, selectors: [["table", "ngl-datatable", ""]], contentQueries: function NglDatatable_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableLoadingOverlay, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableNoRowsOverlay, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDatatableColumn, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noRowsOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, hostVars: 4, hostBindings: function NglDatatable_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-table", true)("slds-is-relative", ctx.loading);
    } }, inputs: { data: "data", loading: "loading", trackByKey: "trackByKey", sort: "sort" }, outputs: { sortChange: "sortChange", rowClick: "rowClick" }, attrs: _c20, decls: 8, vars: 5, consts: [[1, "slds-line-height_reset"], ["nglDatatableHead", "", "scope", "col", 3, "heading", "headingTpl", "sortable", "sortOrder", "ngClass", "sort", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["noData", ""], [4, "ngIf", "ngIfElse"], ["class", "ngl-datatable-loading slds-align_absolute-center", 4, "ngIf"], ["nglDatatableHead", "", "scope", "col", 3, "heading", "headingTpl", "sortable", "sortOrder", "ngClass", "sort"], [3, "ngTemplateOutlet"], [3, "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "click"], ["nglDatatatableCell_", "", 3, "ngClass", "row", "column", "index", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["nglDatatatableCell_", "", 3, "ngClass", "row", "column", "index"], [1, "ngl-datatable-loading", "slds-align_absolute-center"]], template: function NglDatatable_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "thead");
        ɵngcc0.ɵɵelementStart(1, "tr", 0);
        ɵngcc0.ɵɵtemplate(2, NglDatatable_th_2_Template, 1, 5, "th", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "tbody");
        ɵngcc0.ɵɵtemplate(4, NglDatatable_ng_template_4_Template, 3, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, NglDatatable_ng_container_6_Template, 2, 2, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglDatatable_div_7_Template, 2, 1, "div", 4);
    } if (rf & 2) {
        const _r221 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns)("ngForTrackBy", ctx.columnTrackBy);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.data && ctx.data.length > 0)("ngIfElse", _r221);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLoading);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, NglInternalDatatableHeadCell, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet, NglInternalDatatableCell]; }, styles: [".ngl-datatable-loading[_ngcontent-%COMP%] {\n      position: absolute;\n      z-index: 1;\n      top: 0; left: 0; right: 0; bottom: 0;\n      background: rgba(255, 255, 255, 0.5)\n    }"] });
NglDatatable.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatatable.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatable.prototype, "trackByKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sort", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sortChange", void 0);
__decorate([
    HostBinding('class.slds-is-relative'),
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "loading", void 0);
__decorate([
    ContentChild(NglDatatableLoadingOverlay),
    __metadata("design:type", NglDatatableLoadingOverlay)
], NglDatatable.prototype, "loadingOverlay", void 0);
__decorate([
    ContentChild(NglDatatableNoRowsOverlay),
    __metadata("design:type", NglDatatableNoRowsOverlay)
], NglDatatable.prototype, "noRowsOverlay", void 0);
__decorate([
    ContentChildren(NglDatatableColumn),
    __metadata("design:type", QueryList)
], NglDatatable.prototype, "columns", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "rowClick", void 0);
NglDatatable = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglDatatable);

let NglInternalDatatableHeadCell = class NglInternalDatatableHeadCell {
    constructor() {
        this.sort = new EventEmitter();
    }
    get header() {
        return this.headingTpl || this.heading;
    }
    get attrTitle() {
        return this.heading || null;
    }
    get ariaSort() {
        return this.sortOrder ? `${this.sortOrder}ending` : 'none';
    }
    sortChange() {
        this.sort.emit(this.sortOrder === 'desc' ? 'asc' : 'desc');
    }
};
NglInternalDatatableHeadCell.ɵfac = function NglInternalDatatableHeadCell_Factory(t) { return new (t || NglInternalDatatableHeadCell)(); };
NglInternalDatatableHeadCell.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglInternalDatatableHeadCell, selectors: [["th", "nglDatatableHead", ""]], hostVars: 9, hostBindings: function NglInternalDatatableHeadCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-sort", ctx.ariaSort);
        ɵngcc0.ɵɵclassProp("slds-is-sorted_asc", ctx.sortOrder === "asc")("slds-is-sorted_desc", ctx.sortOrder === "desc")("slds-is-sorted", !!ctx.sortOrder)("slds-is-sortable", ctx.sortable);
    } }, inputs: { heading: "heading", headingTpl: "headingTpl", sortable: "sortable", sortOrder: "sortOrder" }, outputs: { sort: "sort" }, attrs: _c21, decls: 3, vars: 2, consts: [["class", "slds-th__action slds-text-link_reset", "role", "button", "tabindex", "0", 3, "click", 4, "ngIf", "ngIfElse"], ["baseTpl", ""], ["role", "button", "tabindex", "0", 1, "slds-th__action", "slds-text-link_reset", 3, "click"], [1, "slds-assistive-text"], [1, "slds-grid", "slds-grid_vertical-align-center", "slds-has-flexi-truncate"], [1, "slds-truncate", 3, "nglInternalOutlet"], [1, "slds-icon_container", "slds-icon-utility-arrowdown"], ["nglIconName", "arrowdown", 1, "slds-icon", "slds-icon-text-default", "slds-is-sortable__icon"]], template: function NglInternalDatatableHeadCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglInternalDatatableHeadCell_a_0_Template, 7, 2, "a", 0);
        ɵngcc0.ɵɵtemplate(1, NglInternalDatatableHeadCell_ng_template_1_Template, 1, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r239 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.sortable)("ngIfElse", _r239);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet,
        NglIconSvg], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglInternalDatatableHeadCell.prototype, "heading", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], NglInternalDatatableHeadCell.prototype, "headingTpl", void 0);
__decorate([
    HostBinding('class.slds-is-sortable'),
    Input(),
    __metadata("design:type", Boolean)
], NglInternalDatatableHeadCell.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglInternalDatatableHeadCell.prototype, "sortOrder", void 0);
__decorate([
    HostBinding('attr.aria-sort'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglInternalDatatableHeadCell.prototype, "ariaSort", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglInternalDatatableHeadCell.prototype, "sort", void 0);

let NglInternalDatatableCell = class NglInternalDatatableCell {
    get dataLabel() {
        return this.column.heading;
    }
    ngOnChanges() {
        this.context = {
            $implicit: this.value,
            row: this.row,
            index: this.index,
        };
    }
    get value() {
        const { key } = this.column;
        return key ? this.row[key] : null;
    }
};
NglInternalDatatableCell.ɵfac = function NglInternalDatatableCell_Factory(t) { return new (t || NglInternalDatatableCell)(); };
NglInternalDatatableCell.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglInternalDatatableCell, selectors: [["td", "nglDatatatableCell_", ""]], hostVars: 1, hostBindings: function NglInternalDatatableCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-label", ctx.dataLabel);
    } }, inputs: { row: "row", column: "column", index: "index" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c22, decls: 4, vars: 5, consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], ["stringTpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglInternalDatatableCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, NglInternalDatatableCell_ng_container_1_Template, 1, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, NglInternalDatatableCell_ng_template_2_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r244 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵclassProp("slds-truncate", ctx.column.truncate);
        ɵngcc0.ɵɵattribute("title", ctx.column.truncate ? ctx.value : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.cellTpl)("ngIfElse", _r244);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalDatatableCell.prototype, "row", void 0);
__decorate([
    Input(),
    __metadata("design:type", NglDatatableColumn)
], NglInternalDatatableCell.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglInternalDatatableCell.prototype, "index", void 0);
__decorate([
    HostBinding('attr.data-label'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglInternalDatatableCell.prototype, "dataLabel", null);

const NGL_DATATABLE_DIRECTIVES = [
    NglDatatable,
    NglDatatableColumn,
    NglDatatableCell,
    NglDatatableHeadingTemplate,
    NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay,
];
let NglDatatablesModule = class NglDatatablesModule {
};
NglDatatablesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglDatatablesModule });
NglDatatablesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglDatatablesModule_Factory(t) { return new (t || NglDatatablesModule)(); }, imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

let NglClickOutsideDirective = class NglClickOutsideDirective {
    constructor(document, element) {
        this.document = document;
        this.element = element;
        this.clickOutside = new EventEmitter();
    }
    ngAfterViewInit() {
        this.subscription = fromEvent(this.document, 'click').subscribe((e) => {
            if (this.shouldClose(e)) {
                this.clickOutside.emit();
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    shouldClose(event) {
        const element = event.target;
        if ((event instanceof MouseEvent && event.button === 2) || isContainedIn(element, this.ignore)) {
            return false;
        }
        return !isContainedIn(element, this.element.nativeElement);
    }
};
NglClickOutsideDirective.ɵfac = function NglClickOutsideDirective_Factory(t) { return new (t || NglClickOutsideDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglClickOutsideDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglClickOutsideDirective, selectors: [["", "nglClickOutside", ""]], inputs: { ignore: ["nglClickOutsideIgnore", "ignore"] }, outputs: { clickOutside: "nglClickOutside" } });
NglClickOutsideDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
__decorate([
    Output('nglClickOutside'),
    __metadata("design:type", EventEmitter)
], NglClickOutsideDirective.prototype, "clickOutside", void 0);
__decorate([
    Input('nglClickOutsideIgnore'),
    __metadata("design:type", Object)
], NglClickOutsideDirective.prototype, "ignore", void 0);
NglClickOutsideDirective = __decorate([ __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object, ElementRef])
], NglClickOutsideDirective);
function isContainedIn(el, container) {
    if (!container) {
        return false;
    }
    return Array.isArray(container) ? container.some(c => c.contains(el)) : container.contains(el);
}

const DIRECTIVES$7 = [NglClickOutsideDirective];
let NglClickOutsideModule = class NglClickOutsideModule {
};
NglClickOutsideModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglClickOutsideModule });
NglClickOutsideModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglClickOutsideModule_Factory(t) { return new (t || NglClickOutsideModule)(); }, imports: [[CommonModule]] });

class NglDateAdapterBase {
}

const PATTERNS = {
    'big-endian': 'yyyy/MM/dd',
    'little-endian': 'dd/MM/yyyy',
    'middle-endian': 'MM/dd/yyyy',
};
let NglDateAdapter = class NglDateAdapter extends NglDateAdapterBase {
    parse(value, format) {
        const date = parse(value, format, new Date());
        return this.isValidDate(date) ? date : null;
    }
    format(date, format$1) {
        return format(date, format$1);
    }
    pattern(name, delimiter) {
        const pattern = PATTERNS[name];
        return (delimiter && delimiter !== '/') ? pattern.replace(/\//g, delimiter) : pattern;
    }
    isValidDate(value) {
        const dateWrapper = new Date(value);
        return !isNaN(dateWrapper.getDate());
    }
};
NglDateAdapter.ɵfac = function NglDateAdapter_Factory(t) { return ɵNglDateAdapter_BaseFactory(t || NglDateAdapter); };
NglDateAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NglDateAdapter, factory: NglDateAdapter.ɵfac });

/** Injection token that can be used to specify default options. */
const NGL_DATEPICKER_CONFIG = new InjectionToken('ngl-datepicker-config');
class NglDatepickerConfig {
    constructor(locale) {
        this.format = 'big-endian';
        this.delimiter = '/';
        this.dropdownAlign = 'left';
        this.showToday = true;
        this.relativeYearFrom = -100;
        this.relativeYearTo = 10;
        this.openOnInputClick = true;
        this.todayLabel = 'Today';
        this.previousMonthLabel = 'Previous Month';
        this.nextMonthLabel = 'Next Month';
        this.monthNames = getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.dayNamesShort = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        this.dayNamesLong = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.firstDayOfWeek = getLocaleFirstDayOfWeek(locale);
    }
}

function parseDate(date) {
    if (!date) {
        return null;
    }
    return { year: date.getFullYear(), month: date.getMonth(), day: date.getDate() };
}
function isEqualDate(d1, d2) {
    return d1 && d2 && d1.day === d2.day && d1.month === d2.month && d1.year === d2.year;
}
function getToday() {
    const today = new Date();
    return { year: today.getFullYear(), month: today.getMonth(), day: today.getDate() };
}
function numberOfDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}
// Split array into smaller arrays
function split(arr, size = 7) {
    const arrays = [];
    while (arr.length > 0) {
        arrays.push(arr.splice(0, size));
    }
    return arrays;
}
function isDisabled(d, disabledCallback, min, max) {
    const date = new Date(d.year, d.month, d.day);
    return (disabledCallback && disabledCallback(date)) ||
        (min && compareDate(d, min) < 0) ||
        (max && compareDate(d, max) > 0);
}
function compareDate(d1, d2) {
    if (isEqualDate(d1, d2)) {
        return 0;
    }
    const keys = ['year', 'month', 'day'];
    for (let i = 0; i < 3; i++) {
        const key = keys[i];
        const diff = d1[key] - d2[key];
        if (diff !== 0) {
            return diff > 0 ? 1 : -1;
        }
    }
}
function isSameMonth(d1, d2) {
    return d1.year === d2.year && d1.month === d2.month;
}

const NGL_DATEPICKER_INPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
const NGL_DATEPICKER_INPUT_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
let NglDatepickerInput = class NglDatepickerInput {
    constructor(defaultConfig, locale, element, renderer, cd, hostService, ngZone, focusTrapFactory, adapter) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.hostService = hostService;
        this.ngZone = ngZone;
        this.focusTrapFactory = focusTrapFactory;
        this.adapter = adapter;
        /**
         * Placeholder of input.
         */
        this.placeholder = '';
        /**
         * Whether input is readonly and calendar is available for date selection.
         */
        this.readonlyInput = false;
        /**
         * Emits when selected date changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * Text for button to open calendar.
         */
        this.selectDateLabel = 'Select a date';
        this.dateDisabled = null;
        this.uid = uniqueId('datepicker-input');
        this._open = new BehaviorSubject(false);
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger_click');
        this.config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.format = this.config.format;
        this.delimiter = this.config.delimiter;
        this.setPositions(this.config.dropdownAlign);
        this.monthNames = this.config.monthNames;
        this.dayNamesShort = this.config.dayNamesShort;
        this.dayNamesLong = this.config.dayNamesLong;
        this.firstDayOfWeek = this.config.firstDayOfWeek;
        this.showToday = this.config.showToday;
        this.relativeYearFrom = this.config.relativeYearFrom;
        this.relativeYearTo = this.config.relativeYearTo;
        this.openOnInputClick = this.config.openOnInputClick;
        this.todayLabel = this.config.todayLabel;
        this.previousMonthLabel = this.config.previousMonthLabel;
        this.nextMonthLabel = this.config.nextMonthLabel;
    }
    /**
     * The date value.
     */
    set value(value) {
        if (value === this._value) {
            return;
        }
        this._value = value;
        if (this.value instanceof Date) {
            this.date = this.value;
            this.formatInputValue();
        }
        else {
            this.updateInputValue(value || '');
        }
    }
    get value() {
        return this._value;
    }
    set open(open) {
        this._open.next(open);
    }
    get open() {
        return this._open.value;
    }
    validate(c) {
        const value = c.value;
        if (!value) {
            return null;
        }
        if (!(this.value instanceof Date)) {
            return { 'nglDatepickerInput': { invalid: c.value } };
        }
        const date = parseDate(value);
        if (isDisabled(date, this.dateDisabled, parseDate(this.min), parseDate(this.max))) {
            return { 'nglDatepickerInput': { disabled: c.value } };
        }
        return null;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(disabled) { this.disabled = disabled; }
    onBlur() {
        if (this.value instanceof Date) {
            this.updateInputValue();
        }
        this.onTouched();
    }
    ngOnInit() {
        this._open.subscribe(() => {
            this.setHostClass();
            this.cd.markForCheck();
        });
    }
    ngOnChanges(changes) {
        if (changes.format || changes.delimiter) {
            this.setPattern();
            if (this.value instanceof Date) {
                this.updateInputValue();
            }
        }
        if (changes.dropdownAlign) {
            this.setPositions(this.dropdownAlign);
        }
        if (changes.min || changes.max) {
            this.validatorChange();
        }
    }
    ngOnDestroy() {
        this.closeCalendar(false);
    }
    onKeyboardInput(evt) {
        const keyCode = evt.keyCode;
        if (!this.open && (keyCode === DOWN_ARROW || keyCode === UP_ARROW)) {
            this.openCalendar();
        }
    }
    onInputChange(value) {
        const date = this.dateParse(value);
        this.emitSelection(date || value);
    }
    openCalendar() {
        this.open = true;
    }
    onAttach() {
        this.focusTrap = this.focusTrapFactory.create(this.cdkOverlay.overlayRef.overlayElement);
    }
    onDetach() {
        if (this.open) {
            this.closeCalendar();
        }
    }
    closeCalendar(focusInput = true) {
        this.open = false;
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
        if (focusInput) {
            this.inputEl.nativeElement.focus();
        }
    }
    onTriggerClick(origin) {
        if (origin === 'input' && !this.openOnInputClick) {
            return;
        }
        if (!this.open) {
            this.openCalendar();
        }
        else {
            this.closeCalendar(false);
        }
    }
    pickerSelection(date) {
        this.emitSelection(date);
        this.closeCalendar();
    }
    updateDatepickerSize(width, height) {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            overlayRef.updateSize({
                minWidth: width,
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
    setPositions(align) {
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS[align]];
    }
    formatInputValue() {
        const inputValue = this.inputEl.nativeElement.value;
        if (!inputValue) {
            this.updateInputValue();
        }
        else {
            const date = this.value;
            const dateNow = this.dateParse(inputValue);
            if (!dateNow || dateNow.getFullYear() !== date.getFullYear() || dateNow.getMonth() !== date.getMonth() || dateNow.getDate() !== date.getDate()) {
                this.updateInputValue();
            }
        }
    }
    updateInputValue(value = this.dateFormat(this.value)) {
        this.renderer.setProperty(this.inputEl.nativeElement, 'value', value || '');
    }
    dateParse(value) {
        return this.adapter.parse(value, this.getPattern());
    }
    dateFormat(date) {
        return this.adapter.format(date, this.getPattern());
    }
    getPattern() {
        if (!this.pattern) {
            this.setPattern();
        }
        return this.pattern;
    }
    setPattern() {
        this.pattern = this.adapter.pattern(this.format || this.config.format, this.delimiter || this.config.delimiter);
    }
    emitSelection(value) {
        this.valueChange.emit(value);
        if (this.onChange) {
            this.value = value;
            this.onChange(value);
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-is-open`]: this.open,
        });
    }
};
NglDatepickerInput.ɵfac = function NglDatepickerInput_Factory(t) { return new (t || NglDatepickerInput)(ɵngcc0.ɵɵdirectiveInject(NGL_DATEPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(HostService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(NglDateAdapter)); };
NglDatepickerInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerInput, selectors: [["ngl-datepicker-input"]], viewQuery: function NglDatepickerInput_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c23, true);
        ɵngcc0.ɵɵviewQuery(_c16, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cdkOverlay = _t.first);
    } }, inputs: { placeholder: "placeholder", readonlyInput: "readonlyInput", selectDateLabel: "selectDateLabel", dateDisabled: "dateDisabled", format: "format", delimiter: "delimiter", monthNames: "monthNames", dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek", showToday: "showToday", relativeYearFrom: "relativeYearFrom", relativeYearTo: "relativeYearTo", openOnInputClick: "openOnInputClick", todayLabel: "todayLabel", previousMonthLabel: "previousMonthLabel", nextMonthLabel: "nextMonthLabel", value: "value", disabled: "disabled", label: "label", dropdownAlign: "dropdownAlign", min: "min", max: "max" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_DATEPICKER_INPUT_VALUE_ACCESSOR, NGL_DATEPICKER_INPUT_VALIDATOR, HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 12, vars: 11, consts: [["class", "slds-form-element__label", 3, "nglInternalOutlet", 4, "ngIf"], [1, "slds-form-element__control", "slds-input-has-icon", "slds-input-has-icon_right"], ["formEl", ""], ["cdkOverlayOrigin", "", "type", "text", "autocomplete", "off", 1, "slds-input", 3, "id", "placeholder", "disabled", "readOnly", "click", "keydown", "input", "blur"], ["inputEl", "", "overlayOrigin", "cdkOverlayOrigin"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-input__icon", "slds-input__icon_right", 3, "title", "disabled", "click"], ["nglIconName", "utility:event", 1, "slds-button__icon"], [1, "slds-assistive-text"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "nglOverlayScrolledOutsideView", "attach", "detach"], ["cdkOverlay", "cdkConnectedOverlay"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-dropdown", 3, "date", "monthNames", "dayNamesShort", "dayNamesLong", "firstDayOfWeek", "showToday", "min", "max", "relativeYearFrom", "relativeYearTo", "todayLabel", "previousMonthLabel", "nextMonthLabel", "dateDisabled", "nglClickOutsideIgnore", "dateChange", "nglClickOutside"]], template: function NglDatepickerInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglDatepickerInput_label_0_Template, 1, 2, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(3, "input", 3, 4);
        ɵngcc0.ɵɵlistener("click", function NglDatepickerInput_Template_input_click_3_listener() { return ctx.onTriggerClick("input"); })("keydown", function NglDatepickerInput_Template_input_keydown_3_listener($event) { return ctx.onKeyboardInput($event); })("input", function NglDatepickerInput_Template_input_input_3_listener($event) { return ctx.onInputChange($event.target.value); })("blur", function NglDatepickerInput_Template_input_blur_3_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 5);
        ɵngcc0.ɵɵlistener("click", function NglDatepickerInput_Template_button_click_6_listener() { return ctx.onTriggerClick("button"); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(7, "svg", 6);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(8, "span", 7);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglDatepickerInput_ng_template_10_Template, 1, 16, "ng-template", 8, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵlistener("nglOverlayScrolledOutsideView", function NglDatepickerInput_Template_ng_template_nglOverlayScrolledOutsideView_10_listener() { return ctx.closeCalendar(false); })("attach", function NglDatepickerInput_Template_ng_template_attach_10_listener() { return ctx.onAttach(); })("detach", function NglDatepickerInput_Template_ng_template_detach_10_listener() { return ctx.onDetach(); });
    } if (rf & 2) {
        const _r249 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("placeholder", ctx.placeholder)("disabled", ctx.disabled)("readOnly", ctx.readonlyInput);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("title", ctx.selectDateLabel)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.selectDateLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayOrigin", _r249)("cdkConnectedOverlayOpen", ctx.open);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc3.CdkOverlayOrigin, NglIconSvg, ɵngcc3.CdkConnectedOverlay, NglOverlaynglOverlayScrolledOutsideViewDirective,
        NglInternalOutlet,
        NglDatepicker,
        NglClickOutsideDirective]; }, encapsulation: 2, changeDetection: 0 });
NglDatepickerInput.ctorParameters = () => [
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: HostService },
    { type: NgZone },
    { type: FocusTrapFactory },
    { type: NglDateAdapter }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "delimiter", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "disabled", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "readonlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "dropdownAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglDatepickerInput.prototype, "value", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "openOnInputClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "valueChange", void 0);
__decorate([
    ViewChild('inputEl', { static: true }),
    __metadata("design:type", ElementRef)
], NglDatepickerInput.prototype, "inputEl", void 0);
__decorate([
    ViewChild('cdkOverlay'),
    __metadata("design:type", CdkConnectedOverlay)
], NglDatepickerInput.prototype, "cdkOverlay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepickerInput.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepickerInput.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "selectDateLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "monthNames", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "showToday", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepickerInput.prototype, "dateDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "relativeYearFrom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "relativeYearTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "todayLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "previousMonthLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "nextMonthLabel", void 0);
NglDatepickerInput = __decorate([ __param(0, Optional()), __param(0, Inject(NGL_DATEPICKER_CONFIG)),
    __param(1, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [NglDatepickerConfig, String, ElementRef,
        Renderer2,
        ChangeDetectorRef,
        HostService,
        NgZone,
        FocusTrapFactory,
        NglDateAdapter])
], NglDatepickerInput);

let NglDay = class NglDay {
    constructor(el) {
        this.el = el;
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    focus() {
        this.el.nativeElement.focus();
    }
};
NglDay.ɵfac = function NglDay_Factory(t) { return new (t || NglDay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDay.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDay, selectors: [["td", "nglDay", ""]], hostVars: 7, hostBindings: function NglDay_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("aria-disabled", ctx.nglDayDisabled)("aria-selected", ctx.nglDaySelected);
        ɵngcc0.ɵɵclassProp("slds-disabled-text", ctx.nglDayDisabled)("slds-is-selected", ctx.nglDaySelected);
    } }, inputs: { date: ["nglDay", "date"], nglDayDisabled: "nglDayDisabled", nglDaySelected: "nglDaySelected", isActive: "isActive" } });
NglDay.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('nglDay'),
    __metadata("design:type", Object)
], NglDay.prototype, "date", void 0);
__decorate([
    HostBinding('class.slds-disabled-text'),
    HostBinding('attr.aria-disabled'),
    Input(),
    __metadata("design:type", Boolean)
], NglDay.prototype, "nglDayDisabled", void 0);
__decorate([
    HostBinding('class.slds-is-selected'),
    HostBinding('attr.aria-selected'),
    Input(),
    __metadata("design:type", Boolean)
], NglDay.prototype, "nglDaySelected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDay.prototype, "isActive", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglDay.prototype, "tabindex", null);
NglDay = __decorate([ __metadata("design:paramtypes", [ElementRef])
], NglDay);

let NglDatepickerMonth = class NglDatepickerMonth {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.dateDisabled = null;
        this.selectDate = new EventEmitter();
    }
    indexTrackBy(index) {
        return index;
    }
    dateTrackBy(index, { year, month, day }) {
        return `${day}-${month}-${year}`;
    }
    onSelect(date) {
        if (date.disabled)
            return;
        this.selectDate.emit(date);
    }
    ngOnChanges(changes) {
        if (changes.year || changes.month || changes.firstDayOfWeek) {
            this.renderView();
            return;
        }
        if (changes.day) {
            this.updateActive();
        }
        if (changes.selected) {
            this.updateSelected();
        }
        if (changes.minDate || changes.maxDate || changes.dateDisabled) {
            this.updateDisabled();
        }
    }
    focusActiveDay() {
        this.ngZone.runOutsideAngular(() => {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const active = this.days.find((d) => d.isActive);
                if (active) {
                    active.focus();
                }
            });
        });
    }
    renderView() {
        const days = this.daysInMonth(this.year, this.month);
        Array.prototype.unshift.apply(days, this.daysInPreviousMonth(this.year, this.month));
        const nextMonth = this.daysInNextMonth(this.year, this.month + 1, days.length);
        if (nextMonth) {
            Array.prototype.push.apply(days, nextMonth);
        }
        this.weeks = split(days);
    }
    daysInMonth(year, month) {
        const last = numberOfDaysInMonth(year, month);
        return this.getDayObjects(year, month, 1, last);
    }
    daysInPreviousMonth(year, month) {
        const firstIndex = (new Date(year, month, 1)).getDay();
        const last = new Date(year, month, 0).getDate();
        const numDays = (7 + firstIndex - this.firstDayOfWeek) % 7;
        return this.getDayObjects(year, month - 1, last - numDays + 1, last, false);
    }
    daysInNextMonth(year, month, numOfDays) {
        if (numOfDays % 7 === 0) {
            return;
        }
        return this.getDayObjects(year, month, 1, 7 - (numOfDays % 7), false);
    }
    getDayObjects(year, month, from, to, isCurrentMonth = true) {
        const today = getToday();
        const days = [];
        for (let day = from; day <= to; day++) {
            const d = {
                year,
                month,
                day,
                isCurrentMonth,
                today: isEqualDate(today, { year, month, day }),
            };
            d.active = this.isActive(d);
            d.selected = this.isSelected(d);
            d.disabled = this.isDisabled(d);
            days.push(d);
        }
        return days;
    }
    updateActive() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.active = this.isActive(day);
            });
        });
    }
    isActive(day) {
        return day.isCurrentMonth && day.day === this.day;
    }
    updateSelected() {
        this.weeks.forEach((days) => {
            days.forEach((day) => {
                day.selected = this.isSelected(day);
            });
        });
    }
    isSelected(day) {
        return isEqualDate(this.selected, day);
    }
    updateDisabled() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.disabled = this.isDisabled(day);
            });
        });
    }
    /** Date filter for the month */
    isDisabled(d) {
        return !d.isCurrentMonth || isDisabled(d, this.dateDisabled, this.minDate, this.maxDate);
    }
};
NglDatepickerMonth.ɵfac = function NglDatepickerMonth_Factory(t) { return new (t || NglDatepickerMonth)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NglDatepickerMonth.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerMonth, selectors: [["", "nglDatepickerMonth", ""]], viewQuery: function NglDatepickerMonth_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglDay, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.days = _t);
    } }, inputs: { dateDisabled: "dateDisabled", selected: "selected", year: "year", month: "month", day: "day", firstDayOfWeek: "firstDayOfWeek", minDate: "minDate", maxDate: "maxDate" }, outputs: { selectDate: "selectDate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c24, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell", 3, "slds-is-today", "isActive", "nglDay", "nglDaySelected", "nglDayDisabled", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell", 3, "isActive", "nglDay", "nglDaySelected", "nglDayDisabled", "click"], [1, "slds-day"]], template: function NglDatepickerMonth_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglDatepickerMonth_tr_0_Template, 2, 2, "tr", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.weeks)("ngForTrackBy", ctx.indexTrackBy);
    } }, directives: [ɵngcc1.NgForOf, NglDay], encapsulation: 2, changeDetection: 0 });
NglDatepickerMonth.ctorParameters = () => [
    { type: NgZone }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "year", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "month", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "day", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "minDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "maxDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepickerMonth.prototype, "dateDisabled", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "selectDate", void 0);
__decorate([
    ViewChildren(NglDay),
    __metadata("design:type", QueryList)
], NglDatepickerMonth.prototype, "days", void 0);
NglDatepickerMonth = __decorate([ __metadata("design:paramtypes", [NgZone])
], NglDatepickerMonth);

const KEYBOARD_MOVES = {
    [UP_ARROW]: ['Move', -7],
    [LEFT_ARROW]: ['Move', -1],
    [DOWN_ARROW]: ['Move', 7],
    [RIGHT_ARROW]: ['Move', 1],
    [PAGE_UP]: ['MoveMonth', -1],
    [PAGE_DOWN]: ['MoveMonth', 1],
    [HOME]: ['MoveTo', 1],
    [END]: ['MoveTo', 31],
};
let NglDatepicker = class NglDatepicker {
    constructor(dtInput, defaultConfig, locale, element) {
        this.dtInput = dtInput;
        this.element = element;
        this.dateDisabled = null;
        this.dateChange = new EventEmitter();
        this.uid = uniqueId('datepicker');
        const config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.monthNames = config.monthNames;
        this.dayNamesShort = config.dayNamesShort;
        this.dayNamesLong = config.dayNamesLong;
        this.firstDayOfWeek = config.firstDayOfWeek;
        this.showToday = config.showToday;
        this.relativeYearFrom = config.relativeYearFrom;
        this.relativeYearTo = config.relativeYearTo;
        this.todayLabel = config.todayLabel;
        this.previousMonthLabel = config.previousMonthLabel;
        this.nextMonthLabel = config.nextMonthLabel;
    }
    set date(date) {
        this._date = parseDate(date);
    }
    ngOnInit() {
        this.setMinMaxDates();
        this.setCurrent(this._date || getToday());
    }
    ngOnChanges(changes) {
        if ((changes.date && changes.date.isFirstChange()) ||
            changes.relativeYearFrom || changes.relativeYearTo ||
            changes.min || changes.max) {
            this.setMinMaxDates();
        }
        if (changes.date) {
            this.setCurrent(this._date);
        }
    }
    moveYear(year) {
        this.setCurrent({ year: +year });
    }
    moveMonth(diff) {
        this.moveCalendar('MoveMonth', diff);
    }
    keyboardHandler(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ENTER) {
            trapEvent(evt);
            if (!this.isDisabledDate(this.current)) {
                this.select(this.current);
            }
            return;
        }
        const move = KEYBOARD_MOVES[keyCode];
        if (!move) {
            return;
        }
        // Handle keyboard event inside datepicker
        trapEvent(evt);
        const [code, param] = move;
        this.moveCalendar(code, param);
        this.focusActiveDay();
    }
    select(date) {
        if (date.disabled) {
            return;
        }
        const { year, month, day } = date;
        this.dateChange.emit(new Date(year, month, day));
    }
    selectToday() {
        const today = getToday();
        if (this.isDisabledDate(today)) {
            this.setCurrent(today);
        }
        else {
            this.dateChange.emit(new Date());
        }
    }
    ngAfterViewInit() {
        if (this.dtInput) {
            const el = this.element.nativeElement;
            this.dtInput.updateDatepickerSize(el.offsetWidth, el.offsetHeight);
            this.focusActiveDay();
        }
    }
    /** Whether the previous period button is disabled. */
    previousDisabled() {
        return this.minDate && isSameMonth(this.current, this.minDate);
    }
    /** Whether the next period button is disabled. */
    nextDisabled() {
        return this.maxDate && isSameMonth(this.current, this.maxDate);
    }
    focusActiveDay() {
        this.monthView.focusActiveDay();
    }
    moveCalendar(code, param) {
        const { year, month, day } = this.current;
        const date = new Date(year, month, day, 12);
        if (code === 'Move') {
            date.setDate(day + (+param));
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day: date.getDate() });
        }
        else if (code === 'MoveMonth') {
            date.setMonth(month + (+param), 1);
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day });
        }
        else if (code === 'MoveTo') {
            this.setCurrent({ day: +param });
        }
    }
    setCurrent(d, doRender = true) {
        this.current = Object.assign(Object.assign({}, this.current), d);
        // Keep current inside minimum/maximum range
        if (compareDate(this.current, this.minDate) < 0) {
            this.current = this.minDate;
        }
        else if (compareDate(this.current, this.maxDate) > 0) {
            this.current = this.maxDate;
        }
        if (doRender) {
            this.render();
        }
    }
    render() {
        const { year, month, day } = this.current;
        this.monthLabel = this.monthNames[month];
        // Keep current day inside limits of this month
        this.setCurrent({ day: Math.min(day, numberOfDaysInMonth(year, month)) }, false);
    }
    /** Date filter for the month */
    isDisabledDate(date) {
        return isDisabled(date, this.dateDisabled, this.minDate, this.maxDate);
    }
    setMinMaxDates() {
        const { year } = getToday();
        this.minDate = this.min ? parseDate(this.min) : { year: year + this.relativeYearFrom, month: 0, day: 1 };
        this.maxDate = this.max ? parseDate(this.max) : { year: year + this.relativeYearTo, month: 11, day: 31 };
    }
};
NglDatepicker.ɵfac = function NglDatepicker_Factory(t) { return new (t || NglDatepicker)(ɵngcc0.ɵɵdirectiveInject(NglDatepickerInput, 8), ɵngcc0.ɵɵdirectiveInject(NGL_DATEPICKER_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDatepicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatepicker, selectors: [["ngl-datepicker"]], viewQuery: function NglDatepicker_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NglDatepickerMonth, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);
    } }, hostVars: 2, hostBindings: function NglDatepicker_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-datepicker", true);
    } }, inputs: { dateDisabled: "dateDisabled", monthNames: "monthNames", dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek", showToday: "showToday", relativeYearFrom: "relativeYearFrom", relativeYearTo: "relativeYearTo", todayLabel: "todayLabel", previousMonthLabel: "previousMonthLabel", nextMonthLabel: "nextMonthLabel", date: "date", min: "min", max: "max" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 20, vars: 17, consts: [[1, "slds-datepicker__filter", "slds-grid"], [1, "slds-datepicker__filter_month", "slds-grid", "slds-grid_align-spread", "slds-grow"], [1, "slds-align-middle"], ["type", "button", 1, "slds-button", "slds-button_icon-container", 3, "disabled", "title", "click"], ["nglIconName", "left", 1, "slds-button__icon"], [1, "slds-assistive-text"], ["aria-live", "assertive", "aria-atomic", "true", 1, "slds-align-middle", 3, "id"], ["nglIconName", "right", 1, "slds-button__icon"], [1, "slds-shrink-none", 3, "year", "from", "to", "yearChange"], ["role", "grid", 1, "datepicker__month", 3, "keydown"], ["nglWeekdays", "", 3, "firstDayOfWeek", "dayNamesShort", "dayNamesLong"], ["nglDatepickerMonth", "", 3, "year", "month", "day", "selected", "firstDayOfWeek", "minDate", "maxDate", "dateDisabled", "selectDate", 4, "ngIf"], ["class", "slds-button slds-align_absolute-center slds-text-link", 3, "click", 4, "ngIf"], ["nglDatepickerMonth", "", 3, "year", "month", "day", "selected", "firstDayOfWeek", "minDate", "maxDate", "dateDisabled", "selectDate"], [1, "slds-button", "slds-align_absolute-center", "slds-text-link", 3, "click"]], template: function NglDatepicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NglDatepicker_Template_button_click_3_listener() { return ctx.moveMonth(0 - 1); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(4, "svg", 4);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "h2", 6);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 2);
        ɵngcc0.ɵɵelementStart(10, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NglDatepicker_Template_button_click_10_listener() { return ctx.moveMonth(1); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(11, "svg", 7);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(12, "span", 5);
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "ngl-date-year", 8);
        ɵngcc0.ɵɵlistener("yearChange", function NglDatepicker_Template_ngl_date_year_yearChange_14_listener($event) { return ctx.moveYear($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(15, "table", 9);
        ɵngcc0.ɵɵlistener("keydown", function NglDatepicker_Template_table_keydown_15_listener($event) { return ctx.keyboardHandler($event); });
        ɵngcc0.ɵɵelementStart(16, "thead");
        ɵngcc0.ɵɵelement(17, "tr", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(18, NglDatepicker_tbody_18_Template, 1, 8, "tbody", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(19, NglDatepicker_button_19_Template, 2, 1, "button", 12);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("disabled", ctx.previousDisabled())("title", ctx.previousMonthLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.previousMonthLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "_month");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.monthLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.nextDisabled())("title", ctx.nextMonthLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.nextMonthLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("year", ctx.current.year)("from", ctx.minDate)("to", ctx.maxDate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.uid + "_month");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("firstDayOfWeek", ctx.firstDayOfWeek)("dayNamesShort", ctx.dayNamesShort)("dayNamesLong", ctx.dayNamesLong);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.current);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToday);
    } }, directives: function () { return [NglIconSvg,
        NglDatepickerYear,
        NglDatepickerWeekdays, ɵngcc1.NgIf, NglDatepickerMonth]; }, styles: ["[_nghost-%COMP%] { display: block; }"], changeDetection: 0 });
NglDatepicker.ctorParameters = () => [
    { type: NglDatepickerInput, decorators: [{ type: Optional }, { type: Inject, args: [NglDatepickerInput,] }] },
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "monthNames", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepicker.prototype, "dateDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], NglDatepicker.prototype, "date", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepicker.prototype, "dateChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepicker.prototype, "showToday", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "relativeYearFrom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "relativeYearTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepicker.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepicker.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "todayLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "previousMonthLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "nextMonthLabel", void 0);
__decorate([
    ViewChild(NglDatepickerMonth),
    __metadata("design:type", NglDatepickerMonth)
], NglDatepicker.prototype, "monthView", void 0);
NglDatepicker = __decorate([ __param(0, Optional()), __param(0, Inject(NglDatepickerInput)),
    __param(1, Optional()), __param(1, Inject(NGL_DATEPICKER_CONFIG)),
    __param(2, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [NglDatepickerInput,
        NglDatepickerConfig, String, ElementRef])
], NglDatepicker);

let NglDatepickerWeekdays = class NglDatepickerWeekdays {
    constructor() {
        this.weekdays = [];
    }
    ngOnChanges(changes) {
        this.weekdays = [];
        for (let i = 0; i < 7; i++) {
            const offset = (this.firstDayOfWeek + i) % 7;
            this.weekdays.push({
                id: `weekday-${i}`,
                label: this.dayNamesShort[offset],
                title: this.dayNamesLong[offset],
            });
        }
    }
};
NglDatepickerWeekdays.ɵfac = function NglDatepickerWeekdays_Factory(t) { return new (t || NglDatepickerWeekdays)(); };
NglDatepickerWeekdays.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerWeekdays, selectors: [["tr", "nglWeekdays", ""]], inputs: { dayNamesShort: "dayNamesShort", dayNamesLong: "dayNamesLong", firstDayOfWeek: "firstDayOfWeek" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c25, decls: 1, vars: 1, consts: [["scope", "col", 3, "id", 4, "ngFor", "ngForOf"], ["scope", "col", 3, "id"], [3, "title"]], template: function NglDatepickerWeekdays_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglDatepickerWeekdays_th_0_Template, 3, 3, "th", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.weekdays);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerWeekdays.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerWeekdays.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerWeekdays.prototype, "firstDayOfWeek", void 0);

let NglDatepickerYear = class NglDatepickerYear {
    constructor() {
        this.uid = uniqueId('datepicker_year');
        this.yearChange = new EventEmitter();
    }
    change($event) {
        this.yearChange.emit($event);
    }
    ngOnChanges() {
        this.range = this.getRange();
    }
    getRange() {
        const minYear = Math.min(this.from.year, this.year);
        const maxYear = Math.max(this.to.year, this.year);
        const size = maxYear - minYear;
        return Array.apply(null, { length: size + 1 }).map((value, index) => minYear + index);
    }
};
NglDatepickerYear.ɵfac = function NglDatepickerYear_Factory(t) { return new (t || NglDatepickerYear)(); };
NglDatepickerYear.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDatepickerYear, selectors: [["ngl-date-year"]], inputs: { from: "from", to: "to", year: "year" }, outputs: { yearChange: "yearChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 4, consts: [[1, "slds-assistive-text"], [1, "slds-select_container"], [1, "slds-select", 3, "id", "ngModel", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function NglDatepickerYear_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1, "Pick a Year");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "select", 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function NglDatepickerYear_Template_select_ngModelChange_3_listener($event) { return ctx.change($event); });
        ɵngcc0.ɵɵtemplate(4, NglDatepickerYear_option_4_Template, 2, 2, "option", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("ngModel", ctx.year);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.range);
    } }, directives: [ɵngcc4.SelectControlValueAccessor, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc1.NgForOf, ɵngcc4.NgSelectOption, ɵngcc4.ɵangular_packages_forms_forms_x], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "to", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglDatepickerYear.prototype, "year", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "yearChange", void 0);

const EXPORTS = [
    NglDatepicker, NglDatepickerInput
];
let NglDatepickersModule = class NglDatepickersModule {
};
NglDatepickersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglDatepickersModule });
NglDatepickersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglDatepickersModule_Factory(t) { return new (t || NglDatepickersModule)(); }, providers: [NglDateAdapter], imports: [[
            CommonModule,
            FormsModule,
            NglIconsModule,
            NglInternalOutletModule,
            OverlayModule,
            NglClickOutsideModule,
            NglOverlayModule,
        ]] });

class BaseDynamicIconComponent {
}
BaseDynamicIconComponent.ɵfac = function BaseDynamicIconComponent_Factory(t) { return new (t || BaseDynamicIconComponent)(); };
BaseDynamicIconComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseDynamicIconComponent, inputs: { alternativeText: "alternativeText" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], BaseDynamicIconComponent.prototype, "alternativeText", void 0);

let NglDynamicIcon = class NglDynamicIcon extends BaseDynamicIconComponent {
};
NglDynamicIcon.ɵfac = function NglDynamicIcon_Factory(t) { return ɵNglDynamicIcon_BaseFactory(t || NglDynamicIcon); };
NglDynamicIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIcon, selectors: [["ngl-dynamic-icon"]], inputs: { type: "type", option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[3, "ngSwitch"], [3, "alternativeText", 4, "ngSwitchCase"], [3, "option", "alternativeText", 4, "ngSwitchCase"], [3, "alternativeText"], [3, "option", "alternativeText"]], template: function NglDynamicIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, NglDynamicIcon_ngl_dynamic_icon_ellie_1_Template, 1, 1, "ngl-dynamic-icon-ellie", 1);
        ɵngcc0.ɵɵtemplate(2, NglDynamicIcon_ngl_dynamic_icon_eq_2_Template, 1, 2, "ngl-dynamic-icon-eq", 2);
        ɵngcc0.ɵɵtemplate(3, NglDynamicIcon_ngl_dynamic_icon_score_3_Template, 1, 2, "ngl-dynamic-icon-score", 2);
        ɵngcc0.ɵɵtemplate(4, NglDynamicIcon_ngl_dynamic_icon_waffle_4_Template, 1, 1, "ngl-dynamic-icon-waffle", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.type);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "ellie");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "eq");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "score");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "waffle");
    } }, directives: function () { return [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, NglDynamicIconEllie,
        NglDynamicIconEq,
        NglDynamicIconScore,
        NglDynamicIconWaffle]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDynamicIcon.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDynamicIcon.prototype, "option", void 0);

let NglDynamicIconEllie = class NglDynamicIconEllie extends BaseDynamicIconComponent {
};
NglDynamicIconEllie.ɵfac = function NglDynamicIconEllie_Factory(t) { return ɵNglDynamicIconEllie_BaseFactory(t || NglDynamicIconEllie); };
NglDynamicIconEllie.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconEllie, selectors: [["ngl-dynamic-icon-ellie"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 43, vars: 1, consts: [[1, "slds-icon-ellie", "slds-is-animated"], ["viewbox", "0 0 280 14", "aria-hidden", "true"], ["cx", "7", "cy", "7", "r", "4"], ["cx", "7", "cy", "7", "r", "3"], ["cx", "21", "cy", "7", "r", "4"], ["cx", "21", "cy", "7", "r", "3"], ["cx", "35", "cy", "7", "r", "4"], ["cx", "35", "cy", "7", "r", "3"], ["cx", "49", "cy", "7", "r", "4"], ["cx", "49", "cy", "7", "r", "3"], ["cx", "63", "cy", "7", "r", "4"], ["cx", "63", "cy", "7", "r", "3"], ["cx", "77", "cy", "7", "r", "4"], ["cx", "77", "cy", "7", "r", "3"], ["cx", "91", "cy", "7", "r", "4"], ["cx", "91", "cy", "7", "r", "3"], ["cx", "105", "cy", "7", "r", "4"], ["cx", "105", "cy", "7", "r", "3"], ["cx", "119", "cy", "7", "r", "4"], ["cx", "119", "cy", "7", "r", "3"], ["cx", "133", "cy", "7", "r", "4"], ["cx", "133", "cy", "7", "r", "3"], ["cx", "147", "cy", "7", "r", "4"], ["cx", "147", "cy", "7", "r", "3"], ["cx", "161", "cy", "7", "r", "4"], ["cx", "161", "cy", "7", "r", "3"], ["cx", "175", "cy", "7", "r", "4"], ["cx", "175", "cy", "7", "r", "3"], ["cx", "189", "cy", "7", "r", "4"], ["cx", "189", "cy", "7", "r", "3"], ["cx", "203", "cy", "7", "r", "4"], ["cx", "203", "cy", "7", "r", "3"], ["cx", "217", "cy", "7", "r", "4"], ["cx", "217", "cy", "7", "r", "3"], ["cx", "231", "cy", "7", "r", "4"], ["cx", "231", "cy", "7", "r", "3"], ["cx", "245", "cy", "7", "r", "4"], ["cx", "245", "cy", "7", "r", "3"], ["cx", "259", "cy", "7", "r", "4"], ["cx", "259", "cy", "7", "r", "3"], ["cx", "273", "cy", "7", "r", "4"], ["cx", "273", "cy", "7", "r", "3"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconEllie_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelement(3, "circle", 3);
        ɵngcc0.ɵɵelement(4, "circle", 4);
        ɵngcc0.ɵɵelement(5, "circle", 5);
        ɵngcc0.ɵɵelement(6, "circle", 6);
        ɵngcc0.ɵɵelement(7, "circle", 7);
        ɵngcc0.ɵɵelement(8, "circle", 8);
        ɵngcc0.ɵɵelement(9, "circle", 9);
        ɵngcc0.ɵɵelement(10, "circle", 10);
        ɵngcc0.ɵɵelement(11, "circle", 11);
        ɵngcc0.ɵɵelement(12, "circle", 12);
        ɵngcc0.ɵɵelement(13, "circle", 13);
        ɵngcc0.ɵɵelement(14, "circle", 14);
        ɵngcc0.ɵɵelement(15, "circle", 15);
        ɵngcc0.ɵɵelement(16, "circle", 16);
        ɵngcc0.ɵɵelement(17, "circle", 17);
        ɵngcc0.ɵɵelement(18, "circle", 18);
        ɵngcc0.ɵɵelement(19, "circle", 19);
        ɵngcc0.ɵɵelement(20, "circle", 20);
        ɵngcc0.ɵɵelement(21, "circle", 21);
        ɵngcc0.ɵɵelement(22, "circle", 22);
        ɵngcc0.ɵɵelement(23, "circle", 23);
        ɵngcc0.ɵɵelement(24, "circle", 24);
        ɵngcc0.ɵɵelement(25, "circle", 25);
        ɵngcc0.ɵɵelement(26, "circle", 26);
        ɵngcc0.ɵɵelement(27, "circle", 27);
        ɵngcc0.ɵɵelement(28, "circle", 28);
        ɵngcc0.ɵɵelement(29, "circle", 29);
        ɵngcc0.ɵɵelement(30, "circle", 30);
        ɵngcc0.ɵɵelement(31, "circle", 31);
        ɵngcc0.ɵɵelement(32, "circle", 32);
        ɵngcc0.ɵɵelement(33, "circle", 33);
        ɵngcc0.ɵɵelement(34, "circle", 34);
        ɵngcc0.ɵɵelement(35, "circle", 35);
        ɵngcc0.ɵɵelement(36, "circle", 36);
        ɵngcc0.ɵɵelement(37, "circle", 37);
        ɵngcc0.ɵɵelement(38, "circle", 38);
        ɵngcc0.ɵɵelement(39, "circle", 39);
        ɵngcc0.ɵɵelement(40, "circle", 40);
        ɵngcc0.ɵɵelement(41, "circle", 41);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(42, NglDynamicIconEllie_span_42_Template, 2, 1, "span", 42);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(42);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });

let NglDynamicIconEq = class NglDynamicIconEq extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'play';
    }
    get option() {
        return this._option;
    }
    isAnimated() {
        return this.option !== 'stop';
    }
};
NglDynamicIconEq.ɵfac = function NglDynamicIconEq_Factory(t) { return ɵNglDynamicIconEq_BaseFactory(t || NglDynamicIconEq); };
NglDynamicIconEq.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconEq, selectors: [["ngl-dynamic-icon-eq"]], inputs: { option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 3, consts: [[1, "slds-icon-eq"], [1, "slds-icon-eq__bar"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconEq_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "div", 1);
        ɵngcc0.ɵɵelement(3, "div", 1);
        ɵngcc0.ɵɵtemplate(4, NglDynamicIconEq_span_4_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-is-animated", ctx.isAnimated());
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglDynamicIconEq.prototype, "option", null);

let NglDynamicIconScore = class NglDynamicIconScore extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'positive';
    }
    get option() {
        return this._option;
    }
};
NglDynamicIconScore.ɵfac = function NglDynamicIconScore_Factory(t) { return ɵNglDynamicIconScore_BaseFactory(t || NglDynamicIconScore); };
NglDynamicIconScore.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconScore, selectors: [["ngl-dynamic-icon-score"]], inputs: { option: "option" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 2, consts: [[1, "slds-icon-score"], ["viewBox", "0 0 5 5", "aria-hidden", "true", 1, "slds-icon-score__positive"], ["cx", "50%", "cy", "50%", "r", "1.875"], ["viewBox", "0 0 5 5", "aria-hidden", "true", 1, "slds-icon-score__negative"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconScore_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelement(4, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglDynamicIconScore_span_5_Template, 2, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-slds-state", ctx.option);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglDynamicIconScore.prototype, "option", null);

let NglDynamicIconWaffle = class NglDynamicIconWaffle extends BaseDynamicIconComponent {
};
NglDynamicIconWaffle.ɵfac = function NglDynamicIconWaffle_Factory(t) { return ɵNglDynamicIconWaffle_BaseFactory(t || NglDynamicIconWaffle); };
NglDynamicIconWaffle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglDynamicIconWaffle, selectors: [["ngl-dynamic-icon-waffle"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 1, consts: [["type", "button", 1, "slds-button", "slds-icon-waffle_container"], [1, "slds-icon-waffle"], [1, "slds-r1"], [1, "slds-r2"], [1, "slds-r3"], [1, "slds-r4"], [1, "slds-r5"], [1, "slds-r6"], [1, "slds-r7"], [1, "slds-r8"], [1, "slds-r9"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglDynamicIconWaffle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵelement(4, "span", 4);
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelement(6, "span", 6);
        ɵngcc0.ɵɵelement(7, "span", 7);
        ɵngcc0.ɵɵelement(8, "span", 8);
        ɵngcc0.ɵɵelement(9, "span", 9);
        ɵngcc0.ɵɵelement(10, "span", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglDynamicIconWaffle_span_11_Template, 2, 1, "span", 11);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });

const NGL_DYNAMIC_ICON_DIRECTIVES = [
    NglDynamicIcon,
    NglDynamicIconEllie,
    NglDynamicIconEq,
    NglDynamicIconScore,
    NglDynamicIconWaffle,
];
let NglDynamicIconsModule = class NglDynamicIconsModule {
};
NglDynamicIconsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglDynamicIconsModule });
NglDynamicIconsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglDynamicIconsModule_Factory(t) { return new (t || NglDynamicIconsModule)(); }, imports: [[CommonModule]] });

let NglFile = class NglFile {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.renderer.addClass(this.element.nativeElement, 'slds-file');
        this.renderer.addClass(this.element.nativeElement, 'slds-file_card');
    }
};
NglFile.ɵfac = function NglFile_Factory(t) { return new (t || NglFile)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFile.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglFile, selectors: [["ngl-file"]], hostVars: 2, hostBindings: function NglFile_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-title", ctx.text);
    } }, inputs: { text: "text", iconName: "iconName" }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [["class", "slds-file__title slds-file__title_card", 4, "ngIf"], [1, "slds-file__title", "slds-file__title_card"], [1, "slds-media", "slds-media_small", "slds-media_center"], ["class", "slds-media__figure slds-line-height_reset", 4, "ngIf"], [1, "slds-media__body"], [1, "slds-file__text", "slds-truncate", 3, "title", "nglInternalOutlet"], [1, "slds-media__figure", "slds-line-height_reset"], [3, "iconName"]], template: function NglFile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "figure");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NglFile_figcaption_2_Template, 5, 3, "figcaption", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.text);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet,
        NglIcon], encapsulation: 2, changeDetection: 0 });
NglFile.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.slds-has-title'),
    Input(),
    __metadata("design:type", Object)
], NglFile.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglFile.prototype, "iconName", void 0);
NglFile = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFile);

let NglFileCrop = class NglFileCrop {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.cropClass = 'slds-file__crop';
        // this.renderer.addClass(this.element.nativeElement, this.cropClass);
    }
    set nglFileCrop(ratio) {
        const nativeElement = this.element.nativeElement;
        if (this.currentRatio) {
            this.renderer.removeClass(nativeElement, `${this.cropClass}`);
            this.renderer.removeClass(nativeElement, `${this.cropClass}_${this.currentRatio}`);
        }
        if (ratio) {
            this.renderer.addClass(nativeElement, `${this.cropClass}`);
            this.renderer.addClass(nativeElement, `${this.cropClass}_${ratio}`);
        }
        this.currentRatio = ratio;
    }
};
NglFileCrop.ɵfac = function NglFileCrop_Factory(t) { return new (t || NglFileCrop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFileCrop.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglFileCrop, selectors: [["", "nglFileCrop", ""]], inputs: { nglFileCrop: "nglFileCrop" } });
NglFileCrop.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglFileCrop.prototype, "nglFileCrop", null);
NglFileCrop = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFileCrop);

let NglFilesModule = class NglFilesModule {
};
NglFilesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglFilesModule });
NglFilesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglFilesModule_Factory(t) { return new (t || NglFilesModule)(); }, imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

const FILE_EXT_REG = /(^[.]\w*)$/m;
function isFileTypeAccepted(accept, file) {
    if (typeof accept === 'string') {
        accept = accept.split(',');
    }
    return accept.some((acc) => {
        if (FILE_EXT_REG.test(acc)) {
            return acc === `.${file.name.split('.').pop()}`;
        }
        else {
            return (new RegExp(acc.replace('*', '.\*'))).test(file.type);
        }
    });
}

var NglFileUpload_1;
let NglFileUpload = NglFileUpload_1 = class NglFileUpload {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * File types that can be accepted. See [input accept Attribute](https://www.w3schools.com/tags/att_input_accept.asp).
         */
        this.accept = null;
        /**
         * Whether file selection is disabled.
         */
        this.disabled = false;
        /**
          * How many files can be selected simultaneously. `0` means unlimited.
          */
        this.maxFiles = 1;
        /**
         * File size limit in bytes. `0` means unlimited.
         */
        this.maxFilesize = 0;
        /**
         * Message to display when there is in an error state.
         */
        this.error = null;
        /**
         * Text for button to open file selector.
         */
        this.uploadButtonLabel = 'Upload Files';
        /**
         * Text to display inside drop zone.
         */
        this.dropZoneLabel = 'or Drop Files';
        this.uid = uniqueId('file-upload');
        this.isDragOver = false;
        this.files = [];
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    writeValue(value) {
        this.files = value;
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    validate(c) {
        const files = c.value;
        if (!files || files.length === 0) {
            return null;
        }
        if (this.maxFiles > 0 && files.length > this.maxFiles) {
            return { nglFileUpload: { maxFiles: files.length } };
        }
        for (let i = 0, n = files.length; i < n; i++) {
            const file = files[i];
            if (this.accept && !isFileTypeAccepted(this.accept, file)) {
                return { nglFileUpload: { invalidType: file } };
            }
            if (this.maxFilesize && file.size > this.maxFilesize) {
                return { nglFileUpload: { maxFilesize: file } };
            }
        }
        return null;
    }
    ngOnChanges(changes) {
        if (changes['maxFiles'] || changes['maxFilesize'] || changes['accept']) {
            this.validatorChange();
        }
    }
    onDropZone(evt) {
        trapEvent(evt);
        if (this.disabled) {
            return;
        }
        this.isDragOver = evt.type === 'dragover';
        if (evt.type === 'drop' && evt.dataTransfer) {
            this.select(evt.dataTransfer.files);
        }
    }
    onInputChange(files) {
        this.select(files);
    }
    select(files) {
        this.onChange(Array.from(files));
    }
};
NglFileUpload.ɵfac = function NglFileUpload_Factory(t) { return new (t || NglFileUpload)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglFileUpload.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglFileUpload, selectors: [["ngl-file-upload"]], hostVars: 2, hostBindings: function NglFileUpload_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.error);
    } }, inputs: { accept: "accept", disabled: "disabled", maxFiles: "maxFiles", maxFilesize: "maxFilesize", error: "error", uploadButtonLabel: "uploadButtonLabel", dropZoneLabel: "dropZoneLabel", label: "label" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NglFileUpload_1,
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: NglFileUpload_1,
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 12, vars: 14, consts: [["class", "slds-form-element__label", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-file-selector", "slds-file-selector_files"], [1, "slds-file-selector__dropzone", 3, "dragover", "dragleave", "drop"], ["type", "file", 1, "slds-file-selector__input", "slds-assistive-text", 3, "id", "disabled", "multiple", "change"], [1, "slds-file-selector__body", 3, "id"], [1, "slds-file-selector__button", "slds-button", "slds-button_neutral"], ["nglIconName", "utility:upload", 1, "slds-button__icon", "slds-button__icon_left"], [1, "slds-file-selector__text", "slds-medium-show"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-form-element__label", 3, "id", "nglInternalOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglFileUpload_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglFileUpload_span_0_Template, 1, 2, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("dragover", function NglFileUpload_Template_div_dragover_3_listener($event) { return ctx.onDropZone($event); })("dragleave", function NglFileUpload_Template_div_dragleave_3_listener($event) { return ctx.onDropZone($event); })("drop", function NglFileUpload_Template_div_drop_3_listener($event) { return ctx.onDropZone($event); });
        ɵngcc0.ɵɵelementStart(4, "input", 4);
        ɵngcc0.ɵɵlistener("change", function NglFileUpload_Template_input_change_4_listener($event) { return ctx.onInputChange($event.target.files); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "label", 5);
        ɵngcc0.ɵɵelementStart(6, "span", 6);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(7, "svg", 7);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(9, "span", 8);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NglFileUpload_div_11_Template, 1, 2, "div", 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassProp("slds-has-drag-over", ctx.isDragOver);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("disabled", ctx.disabled)("multiple", ctx.maxFiles !== 1);
        ɵngcc0.ɵɵattribute("accept", ctx.accept)("aria-describedby", ctx.error ? ctx.uid + "-error" : null)("aria-labelledby", ctx.uid + "-primary-label " + ctx.uid + "-secondary-label");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid + "-secondary-label");
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.uploadButtonLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.dropZoneLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg,
        NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglFileUpload.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "accept", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "disabled", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "maxFiles", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "maxFilesize", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "error", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "uploadButtonLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "dropZoneLabel", void 0);
NglFileUpload = NglFileUpload_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFileUpload);

let NglFileUploadModule = class NglFileUploadModule {
};
NglFileUploadModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglFileUploadModule });
NglFileUploadModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglFileUploadModule_Factory(t) { return new (t || NglFileUploadModule)(); }, imports: [[CommonModule, NglIconsModule, NglInternalOutletModule]] });

let NglInputElement = class NglInputElement {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('input'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglInputElement.ɵfac = function NglInputElement_Factory(t) { return new (t || NglInputElement)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglInputElement.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglInputElement, selectors: [["input", "ngl", "", 3, "type", "checkbox", 3, "type", "radio"]], hostVars: 3, hostBindings: function NglInputElement_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-input", true);
    } }, inputs: { required: "required" } });
NglInputElement.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglInputElement.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglInputElement.prototype, "required", null);
NglInputElement = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglInputElement);

let NglInput = class NglInput {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input> with [ngl] attribute inside NglInput`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
};
NglInput.ɵfac = function NglInput_Factory(t) { return new (t || NglInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglInput, selectors: [["ngl-input"], ["", "ngl-input", ""]], contentQueries: function NglInput_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglInputElement, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", error: "error", stacked: "stacked", fieldLevelHelpTooltip: "fieldLevelHelpTooltip" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 5, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglInput_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, NglInput_div_4_Template, 1, 2, "div", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp,
        NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglInput.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglInputElement, { static: true }),
    __metadata("design:type", NglInputElement)
], NglInput.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "error", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglInput.prototype, "stacked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglInput.prototype, "hasError", null);
NglInput = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglInput);

const DIRECTIVES$8 = [
    NglInput,
    NglInputElement,
];
let NglInputModule = class NglInputModule {
};
NglInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglInputModule });
NglInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglInputModule_Factory(t) { return new (t || NglInputModule)(); }, imports: [[CommonModule, NglFormsModule, NglInternalOutletModule]] });

let NglDropdownItem = class NglDropdownItem {
    constructor(element) {
        this.element = element;
        this.isFocused = false;
    }
    onFocus() {
        this.isFocused = true;
    }
    onBlur() {
        this.isFocused = false;
    }
    hasFocus() {
        return this.isFocused;
    }
    focus() {
        this.element.nativeElement.focus();
    }
};
NglDropdownItem.ɵfac = function NglDropdownItem_Factory(t) { return new (t || NglDropdownItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglDropdownItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDropdownItem, selectors: [["", "nglDropdownItem", ""]], hostAttrs: ["tabindex", "0"], hostBindings: function NglDropdownItem_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function NglDropdownItem_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function NglDropdownItem_blur_HostBindingHandler() { return ctx.onBlur(); });
    } } });
NglDropdownItem.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownItem.prototype, "onFocus", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownItem.prototype, "onBlur", null);
NglDropdownItem = __decorate([ __metadata("design:paramtypes", [ElementRef])
], NglDropdownItem);

const openEventEmitter = new EventEmitter();
let NglDropdown = class NglDropdown {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.handlePageEvents = true;
        this.isOpenChange = new EventEmitter();
        this.triggerFocusEventEmitter = new EventEmitter();
        this._isOpen = false;
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    set isOpen(isOpen) {
        this._isOpen = toBoolean(isOpen);
        if (this.isOpen) {
            this.clearGlobalClickTimeout();
            this.globalClickTimeout = setTimeout(() => {
                if (this.handlePageEvents) {
                    this._subscribeToClickEvents();
                }
            });
            this.renderer.addClass(this.element.nativeElement, 'slds-is-open');
        }
        else {
            this._unsubscribeFromClickEvents();
            this.renderer.removeClass(this.element.nativeElement, 'slds-is-open');
        }
        this.renderer.setAttribute(this.element.nativeElement, 'aria-expanded', `${this.isOpen}`);
    }
    get isOpen() {
        return this._isOpen;
    }
    onKeydownClose(eventName) {
        this.toggle(false);
        if (eventName === 'esc') {
            this.triggerFocusEventEmitter.emit(null);
        }
    }
    onKeydownFocusNext($event, direction) {
        $event.preventDefault();
        this.focusItem(direction);
    }
    ngOnInit() {
        this.openEventSubscription = openEventEmitter.subscribe(this.handleDropdownOpenEvent.bind(this));
    }
    ngOnDestroy() {
        this.clearGlobalClickTimeout();
        if (this.openEventSubscription) {
            this.openEventSubscription.unsubscribe();
        }
        this._unsubscribeFromClickEvents();
    }
    toggle(toggle = !this.isOpen, focus = false) {
        if (toggle === this.isOpen) {
            return;
        }
        this.isOpenChange.emit(toggle);
        if (toggle) {
            openEventEmitter.emit(this);
            if (focus) {
                this.focusItem('next');
            }
        }
    }
    handleGlobalClickEvent($event) {
        if (!this.handlePageEvents || $event.$nglStop) {
            return;
        }
        this.toggle(false);
    }
    _subscribeToClickEvents() {
        this._unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    _unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
    focusItem(direction) {
        if (!this.items.length) {
            return;
        }
        const items = this.items.toArray();
        const activeElementIndex = items.findIndex(item => item.hasFocus()) + (direction === 'next' ? 1 : -1);
        if (activeElementIndex === items.length || activeElementIndex < 0) {
            return;
        }
        items[activeElementIndex].focus();
    }
    handleDropdownOpenEvent(dropdown) {
        if (dropdown !== this) {
            this.toggle(false);
        }
    }
};
NglDropdown.ɵfac = function NglDropdown_Factory(t) { return new (t || NglDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglDropdown.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDropdown, selectors: [["", "nglDropdown", ""]], contentQueries: function NglDropdown_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglDropdownItem, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostVars: 4, hostBindings: function NglDropdown_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function NglDropdown_keydown_esc_HostBindingHandler() { return ctx.onKeydownClose("esc"); })("keydown.tab", function NglDropdown_keydown_tab_HostBindingHandler() { return ctx.onKeydownClose("tab"); })("keydown.arrowdown", function NglDropdown_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownFocusNext($event, "next"); })("keydown.arrowup", function NglDropdown_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownFocusNext($event, "previous"); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-dropdown-trigger", true)("slds-dropdown-trigger_click", true);
    } }, inputs: { handlePageEvents: "handlePageEvents", isOpen: ["open", "isOpen"] }, outputs: { isOpenChange: "openChange" } });
NglDropdown.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('open'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglDropdown.prototype, "isOpen", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDropdown.prototype, "handlePageEvents", void 0);
__decorate([
    ContentChildren(NglDropdownItem, { descendants: true }),
    __metadata("design:type", QueryList)
], NglDropdown.prototype, "items", void 0);
__decorate([
    Output('openChange'),
    __metadata("design:type", Object)
], NglDropdown.prototype, "isOpenChange", void 0);
__decorate([
    HostListener('keydown.esc', ['"esc"']),
    HostListener('keydown.tab', ['"tab"']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NglDropdown.prototype, "onKeydownClose", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event', '"next"']),
    HostListener('keydown.arrowup', ['$event', '"previous"']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event, String]),
    __metadata("design:returntype", void 0)
], NglDropdown.prototype, "onKeydownFocusNext", null);
NglDropdown = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglDropdown);

let NglDropdownTrigger = class NglDropdownTrigger {
    constructor(element, dropdown) {
        this.element = element;
        this.dropdown = dropdown;
        this.parentFocusEventSubscription = this.dropdown.triggerFocusEventEmitter.subscribe(this.focus.bind(this));
    }
    ngOnDestroy() {
        this.parentFocusEventSubscription.unsubscribe();
    }
    toggleOpen() {
        this.dropdown.toggle();
    }
    onKeyDownOpen($event) {
        $event.preventDefault();
        this.dropdown.toggle(true);
    }
    focus() {
        this.element.nativeElement.focus();
    }
};
NglDropdownTrigger.ɵfac = function NglDropdownTrigger_Factory(t) { return new (t || NglDropdownTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NglDropdown)); };
NglDropdownTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglDropdownTrigger, selectors: [["", "nglDropdownTrigger", ""]], hostAttrs: ["aria-haspopup", "true"], hostBindings: function NglDropdownTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglDropdownTrigger_click_HostBindingHandler() { return ctx.toggleOpen(); })("keydown.arrowdown", function NglDropdownTrigger_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeyDownOpen($event); });
    } } });
NglDropdownTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: NglDropdown }
];
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownTrigger.prototype, "toggleOpen", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglDropdownTrigger.prototype, "onKeyDownOpen", null);
NglDropdownTrigger = __decorate([ __metadata("design:paramtypes", [ElementRef, NglDropdown])
], NglDropdownTrigger);

const NGL_DROPDOWN_DIRECTIVES = [
    NglDropdown,
    NglDropdownTrigger,
    NglDropdownItem,
];
let NglMenusModule = class NglMenusModule {
};
NglMenusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglMenusModule });
NglMenusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglMenusModule_Factory(t) { return new (t || NglMenusModule)(); }, imports: [[CommonModule]] });

let NglModalHeaderTemplate = class NglModalHeaderTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalHeaderTemplate.ɵfac = function NglModalHeaderTemplate_Factory(t) { return new (t || NglModalHeaderTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalHeaderTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglModalHeaderTemplate, selectors: [["", "nglModalHeader", ""]] });
NglModalHeaderTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalHeaderTemplate = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglModalHeaderTemplate);
let NglModalTaglineTemplate = class NglModalTaglineTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalTaglineTemplate.ɵfac = function NglModalTaglineTemplate_Factory(t) { return new (t || NglModalTaglineTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalTaglineTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglModalTaglineTemplate, selectors: [["", "nglModalTagline", ""]] });
NglModalTaglineTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalTaglineTemplate = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglModalTaglineTemplate);
let NglModalFooterTemplate = class NglModalFooterTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalFooterTemplate.ɵfac = function NglModalFooterTemplate_Factory(t) { return new (t || NglModalFooterTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglModalFooterTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglModalFooterTemplate, selectors: [["", "nglModalFooter", ""]] });
NglModalFooterTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalFooterTemplate = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglModalFooterTemplate);

let NglModal = class NglModal {
    constructor(focusTrapFactory, document, overlay, element) {
        this.focusTrapFactory = focusTrapFactory;
        this.document = document;
        this.overlay = overlay;
        this.element = element;
        this.header = '';
        this.directional = false;
        this.headingId = uniqueId('modal-heading');
        this.contentId = uniqueId('modal-content');
        this.open = true;
        this.closeButtonAssistiveText = 'Close';
        this.openChange = new EventEmitter();
        this.dismissOnClickOutside = true;
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this.elementFocusedBeforeDialogWasOpened = null;
        this.scrollStrategy = this.overlay.scrollStrategies.block();
    }
    get hasHeader() {
        return this.header || this.headerTpl;
    }
    close(evt) {
        if (evt) {
            evt.stopPropagation();
        }
        this.openChange.emit(false);
    }
    ngOnChanges(changes) {
        if ('open' in changes) {
            this.handleOpen();
        }
    }
    ngAfterContentInit() {
        this.handleOpen();
    }
    clickOutside(evt) {
        if (!this.dismissOnClickOutside) {
            return;
        }
        const { classList } = evt.target;
        if (classList.contains('slds-modal') || classList.contains('slds-modal__container')) {
            this.close();
        }
    }
    ngOnDestroy() {
        this.handleOpen(false);
        this.scrollStrategy = null;
    }
    modalClass() {
        return {
            [`slds-modal_${this.size}`]: !!this.size,
            [`slds-fade-in-open`]: this.open,
            [`slds-modal_prompt`]: !!this.prompt,
        };
    }
    modalHeaderClass() {
        return {
            [`slds-modal__header_empty`]: !this.hasHeader,
            [`slds-theme_${this.prompt}`]: !!this.prompt,
        };
    }
    modalFooterClass() {
        return {
            [`slds-modal__footer_directional`]: !!this.directional,
            [`slds-theme_default`]: !!this.prompt,
        };
    }
    handleOpen(open = this.open) {
        if (open) {
            if (this.document) {
                this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;
            }
            this.container = this.overlay.create();
            // Attach the dom to overlay, the view container is not changed
            this.container.overlayElement.appendChild(this.element.nativeElement);
            this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
            this.focusTrap.focusInitialElementWhenReady();
            this.scrollStrategy.enable();
        }
        else {
            if (this.elementFocusedBeforeDialogWasOpened && typeof this.elementFocusedBeforeDialogWasOpened.focus === 'function') {
                this.elementFocusedBeforeDialogWasOpened.focus();
            }
            if (this.container) {
                this.container.dispose();
                this.container = null;
            }
            if (this.focusTrap) {
                this.focusTrap.destroy();
            }
            this.scrollStrategy.disable();
        }
    }
};
NglModal.ɵfac = function NglModal_Factory(t) { return new (t || NglModal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NglModal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglModal, selectors: [["ngl-modal"]], contentQueries: function NglModal_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalHeaderTemplate, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalTaglineTemplate, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglModalFooterTemplate, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.taglineTpl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
    } }, hostBindings: function NglModal_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function NglModal_keydown_esc_HostBindingHandler($event) { return ctx.close($event); })("click", function NglModal_click_HostBindingHandler($event) { return ctx.clickOutside($event); });
    } }, inputs: { header: "header", directional: "directional", open: "open", closeButtonAssistiveText: "closeButtonAssistiveText", dismissOnClickOutside: "dismissOnClickOutside", size: "size", prompt: "prompt" }, outputs: { openChange: "openChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 12, vars: 14, consts: [["aria-modal", "true", "tabindex", "-1", 1, "slds-modal", 3, "ngClass"], [1, "slds-modal__container"], [1, "slds-modal__header", 3, "ngClass"], ["class", "slds-button slds-button_icon slds-button_icon-inverse slds-modal__close", "type", "button", 3, "click", 4, "ngIf"], ["localHeader", ""], [4, "ngIf", "ngIfElse"], ["class", "slds-m-top_x-small", 4, "ngIf"], ["cdkScrollable", "", 1, "slds-modal__content", 3, "id"], ["class", "slds-modal__footer", 3, "ngClass", 4, "ngIf"], [1, "slds-backdrop"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-button_icon-inverse", "slds-modal__close", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon", "slds-button__icon_large"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"], ["class", "slds-text-heading_medium slds-hyphenate", 3, "id", 4, "ngIf"], [1, "slds-text-heading_medium", "slds-hyphenate", 3, "id"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "slds-m-top_x-small"], [3, "ngTemplateOutlet"], [1, "slds-modal__footer", 3, "ngClass"]], template: function NglModal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "header", 2);
        ɵngcc0.ɵɵtemplate(3, NglModal_button_3_Template, 3, 1, "button", 3);
        ɵngcc0.ɵɵtemplate(4, NglModal_ng_template_4_Template, 1, 1, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, NglModal_6_Template, 1, 4, undefined, 5);
        ɵngcc0.ɵɵtemplate(7, NglModal_p_7_Template, 2, 1, "p", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglModal_footer_10_Template, 2, 2, "footer", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(11, "div", 9);
    } if (rf & 2) {
        const _r286 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵproperty("ngClass", ctx.modalClass());
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.open)("aria-labelledby", ctx.headingId)("aria-describedby", ctx.contentId)("role", ctx.prompt ? "alertdialog" : "dialog");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.modalHeaderClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClose);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerTpl)("ngIfElse", _r286);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasHeader && ctx.taglineTpl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.contentId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footer);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("slds-backdrop_open", ctx.open);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc5.CdkScrollable, NglIconSvg, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglModal.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Overlay },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglModal.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglModal.prototype, "size", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "directional", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "open", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglModal.prototype, "closeButtonAssistiveText", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglModal.prototype, "openChange", void 0);
__decorate([
    ContentChild(NglModalHeaderTemplate),
    __metadata("design:type", NglModalHeaderTemplate)
], NglModal.prototype, "headerTpl", void 0);
__decorate([
    ContentChild(NglModalTaglineTemplate),
    __metadata("design:type", NglModalTaglineTemplate)
], NglModal.prototype, "taglineTpl", void 0);
__decorate([
    ContentChild(NglModalFooterTemplate),
    __metadata("design:type", NglModalFooterTemplate)
], NglModal.prototype, "footer", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "dismissOnClickOutside", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglModal.prototype, "prompt", void 0);
__decorate([
    hasObservers('openChange'),
    __metadata("design:type", Boolean)
], NglModal.prototype, "showClose", void 0);
__decorate([
    HostListener('keydown.esc', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglModal.prototype, "close", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NglModal.prototype, "clickOutside", null);
NglModal = __decorate([ __param(1, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [FocusTrapFactory, Object, Overlay,
        ElementRef])
], NglModal);

const NGL_MODAL_DIRECTIVES = [
    NglModal,
    NglModalFooterTemplate,
    NglModalHeaderTemplate,
    NglModalTaglineTemplate,
];
let NglModalsModule = class NglModalsModule {
};
NglModalsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglModalsModule });
NglModalsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglModalsModule_Factory(t) { return new (t || NglModalsModule)(); }, imports: [[CommonModule, A11yModule, OverlayModule, NglIconsModule]] });

let NglToast = class NglToast extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'toast');
    }
};
NglToast.ɵfac = function NglToast_Factory(t) { return new (t || NglToast)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglToast.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglToast, selectors: [["ngl-toast"]], exportAs: ["nglToast"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 6, vars: 3, consts: [[1, "slds-assistive-text"], ["class", "slds-m-right_small slds-no-flex slds-align-top", "size", "small", "variant", "", 3, "iconName", 4, "ngIf"], [1, "slds-notify__content"], ["class", "slds-button slds-button_icon slds-notify__close slds-button_icon-inverse", "type", "button", 3, "click", 4, "ngIf"], ["size", "small", "variant", "", 1, "slds-m-right_small", "slds-no-flex", "slds-align-top", 3, "iconName"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-notify__close", "slds-button_icon-inverse", 3, "click"], ["nglIconName", "utility:close", 1, "slds-button__icon", "slds-button__icon_large"], ["class", "slds-assistive-text", 4, "ngIf"]], template: function NglToast_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NglToast_ngl_icon_2_Template, 1, 1, "ngl-icon", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglToast_button_5_Template, 3, 1, "button", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.assistiveText || ctx.variant);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconName);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dismissible);
    } }, directives: [ɵngcc1.NgIf, NglIcon,
        NglIconSvg], encapsulation: 2, changeDetection: 0 });
NglToast.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglToast = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglToast);

let NglToastClose = class NglToastClose extends NglCommonNotifyClose {
    constructor(toast) {
        super(toast);
    }
};
NglToastClose.ɵfac = function NglToastClose_Factory(t) { return new (t || NglToastClose)(ɵngcc0.ɵɵdirectiveInject(NglToast)); };
NglToastClose.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglToastClose, selectors: [["ngl-toast", "close", ""], ["ngl-toast", "nglClose", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NglToastClose.ctorParameters = () => [
    { type: NglToast }
];
NglToastClose = __decorate([ __metadata("design:paramtypes", [NglToast])
], NglToastClose);

const NGL_TOAST_DIRECTIVES = [
    NglToast,
    NglToastClose,
];
let NglToastModule = class NglToastModule {
};
NglToastModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglToastModule });
NglToastModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglToastModule_Factory(t) { return new (t || NglToastModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglPagination = class NglPagination {
    constructor() {
        this.pages = [];
        this.pageChange = new EventEmitter();
        this.perPage = 10;
        this.limit = 0;
        this.boundaryNumbers = 0;
        this.firstText = 'First';
        this.previousText = 'Previous';
        this.nextText = 'Next';
        this.lastText = 'Last';
        this.boundaryLinks = false;
    }
    set page(page) {
        this.current = +page;
    }
    hasPrevious() {
        return this.current > 1;
    }
    hasNext() {
        return this.current < this.totalPages;
    }
    goto(page) {
        if (page === this.current) {
            return;
        }
        this.pageChange.emit(+page);
    }
    ngOnChanges() {
        this.totalPages = Math.ceil(+this.total / +this.perPage);
        const { start, end } = this.limits();
        this.pages = this.getPageArray(start, end);
        if (this.boundaryNumbers > 0) {
            if (start > 1) {
                const preGap = this.getPageArray(1, Math.min(start - 1, this.boundaryNumbers));
                const lastGapNumber = +preGap[preGap.length - 1].number;
                if (lastGapNumber < start - 1) {
                    this.pages.unshift(this.getGapPage(lastGapNumber, start));
                }
                this.pages.unshift(...preGap);
            }
            if (end < this.totalPages) {
                const postGap = this.getPageArray(Math.max(this.totalPages - this.boundaryNumbers + 1, end + 1), this.totalPages);
                const firstGapNumber = +postGap[0].number;
                if (firstGapNumber > end + 1) {
                    this.pages.push(this.getGapPage(end, firstGapNumber));
                }
                this.pages.push(...postGap);
            }
        }
        if (this.current > this.totalPages) {
            setTimeout(() => this.goto(this.totalPages));
        }
        else if (!this.current && this.totalPages > 0) {
            setTimeout(() => this.goto(1));
        }
    }
    pageTrackBy(index, page) {
        return page.number;
    }
    get start() {
        return Math.min(Math.max(1 + (+this.current - 1) * +this.perPage, 0), +this.total);
    }
    get end() {
        return Math.min(this.start + (+this.perPage - 1), +this.total);
    }
    getPageArray(start, end) {
        return Array.apply(null, { length: end - start + 1 }).map((value, index) => this.getPage(start + index));
    }
    getPage(number, disabled = false) {
        return { number, disabled };
    }
    getGapPage(before, after) {
        const isConsecutive = before + 1 === after - 1;
        return this.getPage(isConsecutive ? before + 1 : '...', !isConsecutive);
    }
    /**
     * Calculate first and last visible page numbers
     */
    limits() {
        let start = 1, end = this.totalPages;
        if (this.limit < 1) {
            return { start, end };
        }
        // Current page is displayed in the middle of the visible ones
        start = Math.max(+this.current - Math.floor(+this.limit / 2), 1);
        end = start + +this.limit - 1;
        // Adjust if limit is exceeded
        if (end > this.totalPages) {
            end = this.totalPages;
            start = Math.max(end - +this.limit + 1, 1);
        }
        return { start, end };
    }
};
NglPagination.ɵfac = function NglPagination_Factory(t) { return new (t || NglPagination)(); };
NglPagination.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglPagination, selectors: [["ngl-pagination"]], inputs: { perPage: "perPage", limit: "limit", boundaryNumbers: "boundaryNumbers", firstText: "firstText", previousText: "previousText", nextText: "nextText", lastText: "lastText", boundaryLinks: "boundaryLinks", page: "page", total: "total" }, outputs: { pageChange: "pageChange" }, exportAs: ["nglPagination"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 8, consts: [["role", "group", 1, "slds-button-group"], ["class", "slds-button slds-button_neutral", 3, "disabled", "click", 4, "ngIf"], [1, "slds-button", "slds-button_neutral", 3, "disabled", "click"], ["class", "slds-button", 3, "ngClass", "disabled", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "slds-button", 3, "ngClass", "disabled", "click"]], template: function NglPagination_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NglPagination_button_1_Template, 2, 2, "button", 1);
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NglPagination_Template_button_click_2_listener() { return ctx.goto(ctx.current - 1); });
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, NglPagination_button_4_Template, 2, 3, "button", 3);
        ɵngcc0.ɵɵelementStart(5, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NglPagination_Template_button_click_5_listener() { return ctx.goto(ctx.current + 1); });
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NglPagination_button_7_Template, 2, 2, "button", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.boundaryLinks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", !ctx.hasPrevious());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.previousText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pages)("ngForTrackBy", ctx.pageTrackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", !ctx.hasNext());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.nextText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.boundaryLinks);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPagination.prototype, "page", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPagination.prototype, "pageChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "perPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "limit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryNumbers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "firstText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "previousText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "nextText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "lastText", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryLinks", void 0);

let NglPaginationsModule = class NglPaginationsModule {
};
NglPaginationsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglPaginationsModule });
NglPaginationsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglPaginationsModule_Factory(t) { return new (t || NglPaginationsModule)(); }, imports: [[CommonModule]] });

let NglPick = class NglPick {
    constructor() {
        this.values = new BehaviorSubject(null);
        this.nglPickChange = new EventEmitter();
        this.nglOptionDestroyed = new EventEmitter();
        this.isMultiple = false;
    }
    set setSelected(selected) {
        this.selected = selected;
        this.ngAfterContentInit();
    }
    ngAfterContentInit() {
        this.values.next(this.selected);
    }
    selectOption(value) {
        let next;
        if (this.isMultiple) {
            if (Array.isArray(this.selected)) {
                // Remove if already there or add to selection
                const index = this.selected.indexOf(value);
                next = index > -1
                    ? [...this.selected.slice(0, index), ...this.selected.slice(index + 1)]
                    : [...this.selected, value];
            }
            else {
                next = Object.assign({}, this.selected, { [value]: !this.selected[value] });
            }
        }
        else {
            next = value;
        }
        this.nglPickChange.emit(next);
    }
    optionRemoved(value) {
        if (this.isMultiple && !this.selected) {
            return;
        }
        let emit;
        if (this.isMultiple) {
            emit = Array.isArray(this.selected) ? this.selected.indexOf(value) > -1 : !!this.selected[value];
        }
        else {
            emit = this.selected === value;
        }
        if (emit) {
            setTimeout(() => this.nglOptionDestroyed.emit(value));
        }
    }
};
NglPick.ɵfac = function NglPick_Factory(t) { return new (t || NglPick)(); };
NglPick.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglPick, selectors: [["", "nglPick", ""]], inputs: { isMultiple: ["nglPickMultiple", "isMultiple"], setSelected: ["nglPick", "setSelected"], nglPickActiveClass: "nglPickActiveClass" }, outputs: { nglPickChange: "nglPickChange", nglOptionDestroyed: "nglOptionDestroyed" } });
__decorate([
    Input('nglPick'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglPick.prototype, "setSelected", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglPick.prototype, "nglPickActiveClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPick.prototype, "nglPickChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPick.prototype, "nglOptionDestroyed", void 0);
__decorate([
    Input('nglPickMultiple'), InputBoolean(),
    __metadata("design:type", Object)
], NglPick.prototype, "isMultiple", void 0);

let NglPickOption = class NglPickOption {
    constructor(element, renderer, nglPick) {
        this.element = element;
        this.renderer = renderer;
        this.nglPick = nglPick;
        this._active = false;
    }
    // Use a getter to prevent direct altering
    get active() {
        return this._active;
    }
    set setValue(value) {
        this._value = value;
    }
    pick(evt) {
        if (evt) {
            evt.preventDefault();
        }
        this.nglPick.selectOption(this._value);
    }
    ngOnInit() {
        this._subscription = this.nglPick.values.subscribe(value => {
            this._active = this._isActive(value);
            const activeClass = this.nglPickActiveClass || this.nglPick.nglPickActiveClass;
            if (activeClass) {
                if (this.active) {
                    this.renderer.addClass(this.element.nativeElement, activeClass);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, activeClass);
                }
            }
        });
    }
    ngOnDestroy() {
        this._subscription.unsubscribe();
        this.nglPick.optionRemoved(this._value);
    }
    _isActive(value) {
        if (this.nglPick.isMultiple) {
            if (!value) {
                return false;
            }
            return Array.isArray(value) ? value.indexOf(this._value) > -1 : !!value[this._value];
        }
        else {
            return this._value === value;
        }
    }
};
NglPickOption.ɵfac = function NglPickOption_Factory(t) { return new (t || NglPickOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NglPick)); };
NglPickOption.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglPickOption, selectors: [["", "nglPickOption", ""]], hostAttrs: ["role", "button"], hostBindings: function NglPickOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NglPickOption_click_HostBindingHandler() { return ctx.pick(); })("keydown.Space", function NglPickOption_keydown_Space_HostBindingHandler($event) { return ctx.pick($event); })("keydown.Enter", function NglPickOption_keydown_Enter_HostBindingHandler($event) { return ctx.pick($event); });
    } }, inputs: { setValue: ["nglPickOption", "setValue"], nglPickActiveClass: "nglPickActiveClass" }, exportAs: ["nglPickOption"] });
NglPickOption.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NglPick }
];
__decorate([
    Input('nglPickOption'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPickOption.prototype, "setValue", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglPickOption.prototype, "nglPickActiveClass", void 0);
__decorate([
    HostListener('click'),
    HostListener('keydown.Space', ['$event']),
    HostListener('keydown.Enter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglPickOption.prototype, "pick", null);
NglPickOption = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, NglPick])
], NglPickOption);

const NGL_PICK_DIRECTIVES = [
    NglPick,
    NglPickOption,
];
let NglPickModule = class NglPickModule {
};
NglPickModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglPickModule });
NglPickModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglPickModule_Factory(t) { return new (t || NglPickModule)(); }, imports: [[CommonModule]] });

let NglPill = class NglPill {
    constructor() {
        this.isTemplateRef = isTemplateRef;
        /**
           * Applies the error style to the component.
           */
        this.hasError = false;
        /**
           * Whether or not to override the remove button's visibility, if `remove` is set.
           */
        this.removable = true;
        /**
           * Remove button title (and assistive text).
           */
        this.removeTitle = 'Remove';
        /**
           * The event emitted when the remove button is clicked.
           */
        this.remove = new EventEmitter();
        this.linked = false;
    }
    ngOnInit() {
        this.canRemove = this.remove.observers.length > 0;
    }
    onRemove(e) {
        this.remove.emit(e);
    }
    get pillIcon() {
        return this.icon || this.avatar;
    }
};
NglPill.ɵfac = function NglPill_Factory(t) { return new (t || NglPill)(); };
NglPill.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglPill, selectors: [["ngl-pill"]], hostVars: 6, hostBindings: function NglPill_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-pill", true)("slds-has-error", ctx.hasError)("slds-pill_link", ctx.linked);
    } }, inputs: { hasError: "hasError", removable: "removable", removeTitle: "removeTitle", icon: "icon", avatar: "avatar" }, outputs: { remove: "remove" }, ngContentSelectors: _c28, decls: 5, vars: 4, consts: [["class", "slds-pill__icon_container", 4, "ngIf"], [4, "ngIf", "ngIfElse"], ["unlinked", ""], ["class", "slds-button slds-button_icon slds-pill__remove", "type", "button", 3, "title", "click", 4, "ngIf"], [1, "slds-pill__icon_container"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["defaultTpl", ""], [3, "ngTemplateOutlet"], [3, "iconName", 4, "ngIf", "ngIfElse"], ["avatarTpl", ""], [3, "iconName"], ["variant", "circle", 3, "src"], [1, "slds-pill__label"], ["type", "button", 1, "slds-button", "slds-button_icon", "slds-pill__remove", 3, "title", "click"], ["nglIconName", "close", 1, "slds-button__icon"], ["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-assistive-text"]], template: function NglPill_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c27);
        ɵngcc0.ɵɵtemplate(0, NglPill_span_0_Template, 4, 2, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NglPill_ng_container_1_Template, 2, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, NglPill_ng_template_2_Template, 2, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, NglPill_button_4_Template, 3, 2, "button", 3);
    } if (rf & 2) {
        const _r315 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pillIcon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.linked)("ngIfElse", _r315);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.canRemove && ctx.removable);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, NglIcon,
        NglAvatar,
        NglIconSvg], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "avatar", void 0);
__decorate([
    Input(), InputBoolean(), HostBinding('class.slds-has-error'),
    __metadata("design:type", Object)
], NglPill.prototype, "hasError", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglPill.prototype, "removable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "removeTitle", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPill.prototype, "remove", void 0);
__decorate([
    HostBinding('class.slds-pill_link'),
    __metadata("design:type", Object)
], NglPill.prototype, "linked", void 0);

let NglPillLink = class NglPillLink {
    constructor(pill) {
        pill.linked = true;
    }
};
NglPillLink.ɵfac = function NglPillLink_Factory(t) { return new (t || NglPillLink)(ɵngcc0.ɵɵdirectiveInject(NglPill)); };
NglPillLink.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglPillLink, selectors: [["a", "nglPillAction", ""]], hostVars: 2, hostBindings: function NglPillLink_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-pill__action", true);
    } }, attrs: _c29, ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, "slds-pill__label"]], template: function NglPillLink_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NglPillLink.ctorParameters = () => [
    { type: NglPill }
];
NglPillLink = __decorate([ __metadata("design:paramtypes", [NglPill])
], NglPillLink);

const NGL_PILL_DIRECTIVES = [
    NglPill,
    NglPillLink,
];
let NglPillsModule = class NglPillsModule {
};
NglPillsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglPillsModule });
NglPillsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglPillsModule_Factory(t) { return new (t || NglPillsModule)(); }, imports: [[CommonModule, NglIconsModule, NglAvatarModule]] });

let NglProgressBar = class NglProgressBar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-progress-bar');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'progressbar');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemin', '0');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemax', '100');
    }
    /**
     * The percentage value of the progress bar.
     */
    set value(value) {
        this._value = Math.max(0, Math.min(value, 100)); // Trap on [0, 100]
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuenow', `${this.value}`);
    }
    get value() {
        return this._value;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-progress-bar_${this.size}`]: !!this.size,
            [`slds-progress-bar_${this.variant}`]: !!this.variant,
        });
    }
};
NglProgressBar.ɵfac = function NglProgressBar_Factory(t) { return new (t || NglProgressBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglProgressBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglProgressBar, selectors: [["ngl-progress-bar"]], inputs: { value: "value", size: "size", variant: "variant" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 3, consts: [[1, "slds-progress-bar__value"], [1, "slds-assistive-text"]], template: function NglProgressBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.value, "%");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1("Progress: ", ctx.value, "%");
    } }, encapsulation: 2, changeDetection: 0 });
NglProgressBar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglProgressBar.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglProgressBar.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglProgressBar.prototype, "variant", void 0);
NglProgressBar = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglProgressBar);

let NglProgressBarModule = class NglProgressBarModule {
};
NglProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglProgressBarModule });
NglProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglProgressBarModule_Factory(t) { return new (t || NglProgressBarModule)(); }, imports: [[CommonModule]] });

let NglRadioGroup = class NglRadioGroup {
    constructor() {
        this.type = 'list';
        this.uid = uniqueId('radio-group');
        this.type$ = new BehaviorSubject(this.type);
        this.error$ = new BehaviorSubject(this.error);
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    ngOnChanges(changes) {
        if (changes.type) {
            this.type$.next(this.type);
        }
        if (changes.error) {
            this.error$.next(this.hasError ? this.errorId : null);
        }
    }
};
NglRadioGroup.ɵfac = function NglRadioGroup_Factory(t) { return new (t || NglRadioGroup)(); };
NglRadioGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglRadioGroup, selectors: [["ngl-radio-group"], ["", "ngl-radio-group", ""]], hostVars: 4, hostBindings: function NglRadioGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { type: "type", label: "label", error: "error", required: "required" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 8, vars: 5, consts: [[1, "slds-form-element__legend", "slds-form-element__label"], ["class", "slds-required", "title", "required", 4, "ngIf"], [3, "nglInternalOutlet"], [1, "slds-form-element__control"], ["class", "slds-radio_button-group", 4, "ngIf", "ngIfElse"], ["class", "slds-form-element__help", 3, "id", 4, "ngIf"], ["contentTpl", ""], ["title", "required", 1, "slds-required"], [1, "slds-radio_button-group"], [4, "ngTemplateOutlet"], [1, "slds-form-element__help", 3, "id"]], template: function NglRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "legend", 0);
        ɵngcc0.ɵɵtemplate(1, NglRadioGroup_abbr_1_Template, 2, 0, "abbr", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NglRadioGroup_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglRadioGroup_div_5_Template, 2, 2, "div", 5);
        ɵngcc0.ɵɵtemplate(6, NglRadioGroup_ng_template_6_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r330 = ɵngcc0.ɵɵreference(7);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.required);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("nglInternalOutlet", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button")("ngIfElse", _r330);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRadioGroup.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRadioGroup.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglRadioGroup.prototype, "hasError", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglRadioGroup.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRadioGroup.prototype, "type", void 0);

let NglRadioInput = class NglRadioInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('radio'));
        }
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglRadioInput.ɵfac = function NglRadioInput_Factory(t) { return new (t || NglRadioInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglRadioInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglRadioInput, selectors: [["input", "ngl", "", "type", "radio"]], hostVars: 2, hostBindings: function NglRadioInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("name", ctx.name)("aria-describedby", ctx.describedBy);
    } } });
NglRadioInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.name'),
    __metadata("design:type", String)
], NglRadioInput.prototype, "name", void 0);
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglRadioInput.prototype, "describedBy", void 0);
NglRadioInput = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglRadioInput);

let NglRadioOption = class NglRadioOption {
    constructor(radioGroup, cd) {
        this.radioGroup = radioGroup;
        this.cd = cd;
        this.subscriptions = [];
    }
    get isTypeList() {
        return this.type === 'list';
    }
    get isTypeButton() {
        return this.type === 'button';
    }
    ngOnInit() {
        this.subscriptions.push(this.radioGroup.type$.subscribe((type) => {
            this.type = type;
            this.cd.detectChanges();
        }), this.radioGroup.error$.subscribe((errorId) => {
            this.input.describedBy = errorId;
        }));
    }
    ngAfterContentInit() {
        this.input.name = this.radioGroup.uid;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
};
NglRadioOption.ɵfac = function NglRadioOption_Factory(t) { return new (t || NglRadioOption)(ɵngcc0.ɵɵdirectiveInject(NglRadioGroup), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglRadioOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglRadioOption, selectors: [["ngl-radio-option"]], contentQueries: function NglRadioOption_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglRadioInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 6, hostBindings: function NglRadioOption_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-radio", ctx.isTypeList)("slds-button", ctx.isTypeButton)("slds-radio_button", ctx.isTypeButton);
    } }, inputs: { label: "label" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "slds-radio__label", 4, "ngIf"], ["class", "slds-radio_button__label", 4, "ngIf"], [1, "slds-radio__label"], [1, "slds-radio_faux"], [1, "slds-form-element__label", 3, "nglInternalOutlet"], [1, "slds-radio_button__label"], [1, "slds-radio_faux", 3, "nglInternalOutlet"]], template: function NglRadioOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, NglRadioOption_label_1_Template, 3, 2, "label", 0);
        ɵngcc0.ɵɵtemplate(2, NglRadioOption_label_2_Template, 2, 2, "label", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "list");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "button");
    } }, directives: [ɵngcc1.NgIf, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglRadioOption.ctorParameters = () => [
    { type: NglRadioGroup },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRadioOption.prototype, "label", void 0);
__decorate([
    ContentChild(NglRadioInput, { static: true }),
    __metadata("design:type", NglRadioInput)
], NglRadioOption.prototype, "input", void 0);
__decorate([
    HostBinding('class.slds-radio'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRadioOption.prototype, "isTypeList", null);
__decorate([
    HostBinding('class.slds-button'),
    HostBinding('class.slds-radio_button'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRadioOption.prototype, "isTypeButton", null);
NglRadioOption = __decorate([ __metadata("design:paramtypes", [NglRadioGroup, ChangeDetectorRef])
], NglRadioOption);

const DIRECTIVES$9 = [
    NglRadioGroup,
    NglRadioOption,
    NglRadioInput,
];
let NglRadiosModule = class NglRadiosModule {
};
NglRadiosModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglRadiosModule });
NglRadiosModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglRadiosModule_Factory(t) { return new (t || NglRadiosModule)(); }, imports: [[CommonModule, NglInternalOutletModule]] });

let NglRatingIconTemplate = class NglRatingIconTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglRatingIconTemplate.ɵfac = function NglRatingIconTemplate_Factory(t) { return new (t || NglRatingIconTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NglRatingIconTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglRatingIconTemplate, selectors: [["", "nglRatingIcon", ""]] });
NglRatingIconTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglRatingIconTemplate = __decorate([ __metadata("design:paramtypes", [TemplateRef])
], NglRatingIconTemplate);

/** Injection token that can be used to specify default options. */
const NGL_RATING_CONFIG = new InjectionToken('ngl-rating-config');
/**
 * Configuration service for the NglRating component.
 */
class NglRatingConfig {
    constructor() {
        /**
         * The color of the icon when status is "on"
         */
        this.colorOn = '#FFB75D';
        /**
         * The color of the icon when status is "off"
         */
        this.colorOff = '54698D';
    }
}

let NglRating = class NglRating {
    constructor(defaultConfig) {
        this.range = [];
        this.icon = 'favorite';
        this.readonly = false;
        this.rateChange = new EventEmitter();
        this.hover = new EventEmitter();
        this._max = 5;
        const config = Object.assign(Object.assign({}, new NglRatingConfig()), defaultConfig);
        this.colorOn = config.colorOn;
        this.colorOff = config.colorOff;
    }
    set rate(rate) {
        this.inputRate = rate;
        this.currentRate = rate;
    }
    set max(max) {
        this._max = +max;
        this.setRange();
    }
    get max() {
        return this._max;
    }
    ngOnInit() {
        this.setRange();
    }
    ngAfterContentInit() {
        this._template = this.iconTemplate ? this.iconTemplate.templateRef : this.defaultTemplate;
    }
    update(value) {
        if (value < 1 || value > this.max || this.readonly || value === this.inputRate) {
            return;
        }
        this.rateChange.emit(value);
    }
    enter(value) {
        if (this.readonly) {
            return;
        }
        this.currentRate = value;
        this.hover.emit(value);
    }
    getFill(value) {
        if (value <= this.currentRate) {
            return 100;
        }
        if (Math.ceil(this.currentRate) < value) {
            return 0;
        }
        return Math.round(100 * (this.currentRate % 1));
    }
    reset() {
        this.currentRate = this.inputRate;
    }
    // Keyboard interactions
    keyboardIncrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate + 1);
    }
    keyboardDecrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate - 1);
    }
    // ARIA
    get ariaValuenow() {
        return this.inputRate;
    }
    setRange() {
        this.range = Array.apply(null, { length: this.max }).map((value, index) => index + 1);
    }
};
NglRating.ɵfac = function NglRating_Factory(t) { return new (t || NglRating)(ɵngcc0.ɵɵdirectiveInject(NGL_RATING_CONFIG, 8)); };
NglRating.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglRating, selectors: [["ngl-rating"]], contentQueries: function NglRating_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NglRatingIconTemplate, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
    } }, viewQuery: function NglRating_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c30, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
    } }, hostAttrs: ["tabindex", "0", "aria-valuemin", "0", 2, "white-space", "nowrap"], hostVars: 2, hostBindings: function NglRating_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function NglRating_mouseleave_HostBindingHandler() { return ctx.reset(); })("keydown.ArrowUp", function NglRating_keydown_ArrowUp_HostBindingHandler($event) { return ctx.keyboardIncrease($event); })("keydown.ArrowRight", function NglRating_keydown_ArrowRight_HostBindingHandler($event) { return ctx.keyboardIncrease($event); })("keydown.ArrowDown", function NglRating_keydown_ArrowDown_HostBindingHandler($event) { return ctx.keyboardDecrease($event); })("keydown.ArrowLeft", function NglRating_keydown_ArrowLeft_HostBindingHandler($event) { return ctx.keyboardDecrease($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max)("aria-valuenow", ctx.ariaValuenow);
    } }, inputs: { icon: "icon", readonly: ["isReadonly", "readonly"], colorOn: "colorOn", colorOff: "colorOff", rate: "rate", max: "max", size: "size" }, outputs: { rateChange: "rateChange", hover: "hover" }, decls: 3, vars: 1, consts: [["t", ""], ["class", "slds-show_inline-block", "style", "position: relative;", 3, "click", "mouseenter", 4, "ngFor", "ngForOf"], [1, "slds-icon", 3, "nglIconName", "ngClass"], ["class", "slds-icon", "style", "position:absolute; bottom:0;", 3, "nglIconName", "ngClass", "fill", "left", "xPos", 4, "ngIf"], [1, "slds-icon", 2, "position", "absolute", "bottom", "0", 3, "nglIconName", "ngClass", "xPos"], [1, "slds-show_inline-block", 2, "position", "relative", 3, "click", "mouseenter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NglRating_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglRating_ng_template_0_Template, 2, 5, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NglRating_div_2_Template, 2, 6, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.range);
    } }, directives: [ɵngcc1.NgForOf, NglIconSvg, ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
NglRating.ctorParameters = () => [
    { type: NglRatingConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_RATING_CONFIG,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRating.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "size", void 0);
__decorate([
    Input('isReadonly'), InputBoolean(),
    __metadata("design:type", Object)
], NglRating.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglRating.prototype, "rate", null);
__decorate([
    ViewChild('t', { static: true }),
    __metadata("design:type", TemplateRef)
], NglRating.prototype, "defaultTemplate", void 0);
__decorate([
    ContentChild(NglRatingIconTemplate),
    __metadata("design:type", NglRatingIconTemplate)
], NglRating.prototype, "iconTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglRating.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOff", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "rateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "hover", void 0);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "reset", null);
__decorate([
    HostListener('keydown.ArrowUp', ['$event']),
    HostListener('keydown.ArrowRight', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardIncrease", null);
__decorate([
    HostListener('keydown.ArrowDown', ['$event']),
    HostListener('keydown.ArrowLeft', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardDecrease", null);
__decorate([
    HostBinding('attr.aria-valuenow'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRating.prototype, "ariaValuenow", null);
NglRating = __decorate([ __param(0, Optional()), __param(0, Inject(NGL_RATING_CONFIG)),
    __metadata("design:paramtypes", [NglRatingConfig])
], NglRating);

const DIRECTIVES$a = [
    NglRating,
    NglRatingIconTemplate,
];
let NglRatingsModule = class NglRatingsModule {
};
NglRatingsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglRatingsModule });
NglRatingsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglRatingsModule_Factory(t) { return new (t || NglRatingsModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglExpandableSection = class NglExpandableSection {
    constructor() {
        this.collapsable = true;
        this.open = false;
        this.openChange = new EventEmitter();
        this._uid = uniqueId('expandable-section');
    }
    get expanded() {
        return this.collapsable ? this.open : true;
    }
    get uid() {
        return this.collapsable ? this._uid : undefined;
    }
    toggle(event) {
        event.preventDefault();
        this.openChange.emit(!this.open);
    }
};
NglExpandableSection.ɵfac = function NglExpandableSection_Factory(t) { return new (t || NglExpandableSection)(); };
NglExpandableSection.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglExpandableSection, selectors: [["ngl-expandable-section"]], hostVars: 4, hostBindings: function NglExpandableSection_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-section", true)("slds-is-open", ctx.expanded);
    } }, inputs: { collapsable: "collapsable", open: "open", title: "title" }, outputs: { openChange: "openChange" }, ngContentSelectors: _c0, decls: 6, vars: 6, consts: [[1, "slds-section__title"], ["class", "slds-button slds-section__title-action", "type", "button", 3, "click", 4, "ngIf", "ngIfElse"], ["simple_title", ""], [1, "slds-section__content"], ["type", "button", 1, "slds-button", "slds-section__title-action", 3, "click"], ["nglIconName", "switch", 1, "slds-section__title-action-icon", "slds-button__icon", "slds-button__icon_left"], [1, "slds-truncate", 3, "title"], [1, "slds-truncate", "slds-p-horizontal_small", 3, "title"]], template: function NglExpandableSection_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "h3", 0);
        ɵngcc0.ɵɵtemplate(1, NglExpandableSection_button_1_Template, 4, 4, "button", 1);
        ɵngcc0.ɵɵtemplate(2, NglExpandableSection_ng_template_2_Template, 2, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r348 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵclassProp("slds-theme_shade", !ctx.collapsable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapsable)("ngIfElse", _r348);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.expanded)("id", ctx.uid);
    } }, directives: [ɵngcc1.NgIf, NglIconSvg], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], NglExpandableSection.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "collapsable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "openChange", void 0);
__decorate([
    HostBinding('class.slds-is-open'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglExpandableSection.prototype, "expanded", null);

let NglSectionsModule = class NglSectionsModule {
};
NglSectionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglSectionsModule });
NglSectionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglSectionsModule_Factory(t) { return new (t || NglSectionsModule)(); }, imports: [[CommonModule, NglIconsModule]] });

let NglSelectInput = class NglSelectInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('select'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglSelectInput.ɵfac = function NglSelectInput_Factory(t) { return new (t || NglSelectInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglSelectInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglSelectInput, selectors: [["select", "ngl", ""]], hostVars: 3, hostBindings: function NglSelectInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-select", true);
    } }, inputs: { required: "required" } });
NglSelectInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglSelectInput.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglSelectInput.prototype, "required", null);
NglSelectInput = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglSelectInput);

let NglSelect = class NglSelect {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <select> with [ngl] attribute inside ngl-select`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
};
NglSelect.ɵfac = function NglSelect_Factory(t) { return new (t || NglSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglSelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglSelect, selectors: [["ngl-select"], ["", "ngl-select", ""]], contentQueries: function NglSelect_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglSelectInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglSelect_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", fieldLevelHelpTooltip: "fieldLevelHelpTooltip", error: "error" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 6, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-select_container"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglSelect_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglSelect_div_5_Template, 1, 2, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp,
        NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglSelect.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglSelectInput, { static: true }),
    __metadata("design:type", NglSelectInput)
], NglSelect.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglSelect.prototype, "hasError", null);
NglSelect = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglSelect);

const DIRECTIVES$b = [
    NglSelect,
    NglSelectInput,
];
let NglSelectModule = class NglSelectModule {
};
NglSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglSelectModule });
NglSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglSelectModule_Factory(t) { return new (t || NglSelectModule)(); }, imports: [[CommonModule, NglFormsModule, NglInternalOutletModule]] });

const NGL_SLIDER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglSlider),
    multi: true
};
let NglSlider = class NglSlider {
    constructor(element, renderer, cd) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * The minimum value that the slider can have.
         */
        this.min = 0;
        /**
         * The maximum value that the slider can have.
         */
        this.max = 100;
        /**
         * The granularity the slider can step through values.
         */
        this.step = 1;
        /**
         * Whether the slider will be displayed vertically.
         */
        this.vertical = false;
        this.valueChange = new EventEmitter();
        this.uid = uniqueId('slider');
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    get hasError() {
        return !!this.error;
    }
    set value(value) {
        if (value !== this._value) {
            this._value = this.limit(coerceNumberProperty(value));
        }
    }
    get value() {
        // If the value needs to be read and it is still uninitialized, initialize it to the min.
        if (this._value === null) {
            this._value = this.min;
        }
        return this._value;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onInput(value) {
        // Make sure we always emit number
        this.valueChange.emit(coerceNumberProperty(value));
        if (this.onChange) {
            this.value = value;
            this.onChange(this.value);
        }
    }
    sliderClass() {
        return {
            [`slds-size_${this.size}`]: !!this.size,
            [`slds-slider_vertical`]: this.vertical,
        };
    }
    limit(value) {
        return Math.min(Math.max(value, this.min), this.max);
    }
};
NglSlider.ɵfac = function NglSlider_Factory(t) { return new (t || NglSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglSlider.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglSlider, selectors: [["ngl-slider"]], hostVars: 2, hostBindings: function NglSlider_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-has-error", ctx.hasError);
    } }, inputs: { min: "min", max: "max", step: "step", vertical: "vertical", value: "value", disabled: "disabled", label: "label", size: "size", error: "error" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([NGL_SLIDER_VALUE_ACCESSOR])], decls: 11, vars: 14, consts: [[1, "slds-form-element__label"], [1, "slds-slider-label"], ["class", "slds-slider-label__label", 3, "nglInternalOutlet", 4, "ngIf"], [1, "slds-slider-label__range"], [1, "slds-form-element__control"], [1, "slds-slider", 3, "ngClass"], ["type", "range", 1, "slds-slider__range", 3, "id", "value", "min", "max", "step", "disabled", "input"], ["aria-hidden", "true", 1, "slds-slider__value"], ["class", "slds-form-element__help", 3, "id", "nglInternalOutlet", 4, "ngIf"], [1, "slds-slider-label__label", 3, "nglInternalOutlet"], [1, "slds-form-element__help", 3, "id", "nglInternalOutlet"]], template: function NglSlider_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, NglSlider_span_2_Template, 1, 1, "span", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵelementStart(7, "input", 6);
        ɵngcc0.ɵɵlistener("input", function NglSlider_Template_input_input_7_listener($event) { return ctx.onInput($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 7);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, NglSlider_div_10_Template, 1, 2, "div", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.uid);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.min, " - ", ctx.max, "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.sliderClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.uid)("value", ctx.value)("min", ctx.min)("max", ctx.max)("step", ctx.step)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.hasError ? ctx.uid + "-error" : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, NglInternalOutlet], encapsulation: 2, changeDetection: 0 });
NglSlider.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSlider.prototype, "label", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "min", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "max", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "step", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglSlider.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSlider.prototype, "size", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglSlider.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSlider.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglSlider.prototype, "hasError", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglSlider.prototype, "value", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglSlider.prototype, "valueChange", void 0);
NglSlider = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglSlider);

let NglSliderModule = class NglSliderModule {
};
NglSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglSliderModule });
NglSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglSliderModule_Factory(t) { return new (t || NglSliderModule)(); }, imports: [[CommonModule, NglInternalOutletModule]] });

let NglSpinner = class NglSpinner {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-spinner');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'status');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-spinner_${this.size || 'medium'}`]: true,
            [`slds-spinner_${this.variant}`]: !!this.variant,
        });
    }
};
NglSpinner.ɵfac = function NglSpinner_Factory(t) { return new (t || NglSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HostService)); };
NglSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglSpinner, selectors: [["ngl-spinner"]], inputs: { size: "size", variant: "variant", alternativeText: "alternativeText" }, features: [ɵngcc0.ɵɵProvidersFeature([HostService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 1, consts: [["class", "slds-assistive-text", 4, "ngIf"], [1, "slds-spinner__dot-a"], [1, "slds-spinner__dot-b"], [1, "slds-assistive-text"]], template: function NglSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NglSpinner_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.alternativeText);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
NglSpinner.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "alternativeText", void 0);
NglSpinner = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglSpinner);

let NglSpinnersModule = class NglSpinnersModule {
};
NglSpinnersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglSpinnersModule });
NglSpinnersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglSpinnersModule_Factory(t) { return new (t || NglSpinnersModule)(); }, imports: [[CommonModule]] });

let NglTextareaInput = class NglTextareaInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.ɵRequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('textarea'));
        }
    }
    set required(required) {
        this.ɵRequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglTextareaInput.ɵfac = function NglTextareaInput_Factory(t) { return new (t || NglTextareaInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NglTextareaInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NglTextareaInput, selectors: [["textarea", "ngl", ""]], hostVars: 3, hostBindings: function NglTextareaInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.describedBy);
        ɵngcc0.ɵɵclassProp("slds-textarea", true);
    } }, inputs: { required: "required" } });
NglTextareaInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglTextareaInput.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTextareaInput.prototype, "required", null);
NglTextareaInput = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglTextareaInput);

let NglTextarea = class NglTextarea {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <textarea> with [ngl] attribute inside ngl-textarea`);
        }
        this.ɵRequiredSubscription = this.input.ɵRequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.ɵRequiredSubscription) {
            this.ɵRequiredSubscription.unsubscribe();
            this.ɵRequiredSubscription = null;
        }
    }
};
NglTextarea.ɵfac = function NglTextarea_Factory(t) { return new (t || NglTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NglTextarea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NglTextarea, selectors: [["ngl-textarea"], ["", "ngl-textarea", ""]], contentQueries: function NglTextarea_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NglTextareaInput, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 4, hostBindings: function NglTextarea_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("slds-form-element", true)("slds-has-error", ctx.hasError);
    } }, inputs: { label: "label", fieldLevelHelpTooltip: "fieldLevelHelpTooltip", error: "error" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 6, vars: 5, consts: [[3, "nglFormLabel", "required"], [3, "content", 4, "ngIf"], [1, "slds-form-element__control"], [1, "slds-textarea_container"], ["class", "slds-form-element__help", 3, "id", 4, "ngIf"], [3, "content"], [1, "slds-form-element__help", 3, "id"]], template: function NglTextarea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "label", 0);
        ɵngcc0.ɵɵtemplate(1, NglTextarea_ngl_form_help_1_Template, 1, 1, "ngl-form-help", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NglTextarea_div_5_Template, 2, 2, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("nglFormLabel", ctx.label)("required", ctx.required);
        ɵngcc0.ɵɵattribute("for", ctx._uid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fieldLevelHelpTooltip);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error);
    } }, directives: [NglFormLabel, ɵngcc1.NgIf, NglFormHelp], encapsulation: 2, changeDetection: 0 });
NglTextarea.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglTextareaInput, { static: true }),
    __metadata("design:type", NglTextareaInput)
], NglTextarea.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTextarea.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTextarea.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglTextarea.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglTextarea.prototype, "hasError", null);
NglTextarea = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef])
], NglTextarea);

const DIRECTIVES$c = [
    NglTextarea,
    NglTextareaInput,
];
let NglTextareaModule = class NglTextareaModule {
};
NglTextareaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglTextareaModule });
NglTextareaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglTextareaModule_Factory(t) { return new (t || NglTextareaModule)(); }, imports: [[CommonModule, NglFormsModule]] });

const MODULES = [
    NglAccordionModule,
    NglAlertModule,
    NglAvatarModule,
    NglBadgesModule,
    NglBreadcrumbsModule,
    NglButtonIconsModule,
    NglButtonsModule,
    NglCarouselModule,
    NglCheckboxesModule,
    NglColorpickerModule,
    NglComboboxesModule,
    NglDatatablesModule,
    NglDatepickersModule,
    NglDynamicIconsModule,
    NglFilesModule,
    NglFileUploadModule,
    NglIconsModule,
    NglInputModule,
    NglMenusModule,
    NglModalsModule,
    NglToastModule,
    NglPaginationsModule,
    NglPickModule,
    NglPillsModule,
    NglPopoversModule,
    NglProgressBarModule,
    NglRadiosModule,
    NglRatingsModule,
    NglSectionsModule,
    NglSelectModule,
    NglSliderModule,
    NglSpinnersModule,
    NglTabsModule,
    NglTextareaModule,
    NglTooltipsModule,
];
let NglModule = class NglModule {
};
NglModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NglModule });
NglModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NglModule_Factory(t) { return new (t || NglModule)(); }, imports: [NglAccordionModule,
        NglAlertModule,
        NglAvatarModule,
        NglBadgesModule,
        NglBreadcrumbsModule,
        NglButtonIconsModule,
        NglButtonsModule,
        NglCarouselModule,
        NglCheckboxesModule,
        NglColorpickerModule,
        NglComboboxesModule,
        NglDatatablesModule,
        NglDatepickersModule,
        NglDynamicIconsModule,
        NglFilesModule,
        NglFileUploadModule,
        NglIconsModule,
        NglInputModule,
        NglMenusModule,
        NglModalsModule,
        NglToastModule,
        NglPaginationsModule,
        NglPickModule,
        NglPillsModule,
        NglPopoversModule,
        NglProgressBarModule,
        NglRadiosModule,
        NglRatingsModule,
        NglSectionsModule,
        NglSelectModule,
        NglSliderModule,
        NglSpinnersModule,
        NglTabsModule,
        NglTextareaModule,
        NglTooltipsModule] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HostService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.RendererFactory2 }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglIcon, [{
        type: Component,
        args: [{
                selector: 'ngl-icon, [ngl-icon]',
                template: "\n<svg class=\"slds-icon\" [nglIconName]=\"iconName\" [ngClass]=\"svgClasses()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }]; }, { variant: [{
            type: Input
        }], iconName: [{
            type: Input
        }], size: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }], svgClass: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglIconSvg, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'svg[nglIconName]',
                template: "\n<svg:use [attr.xlink:href]=\"iconPath\" [attr.x]=\"xPos\"></svg:use>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NglIconConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_ICON_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { xPos: [{
            type: Input
        }], iconName: [{
            type: Input,
            args: ['nglIconName']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglIconsModule, { declarations: function () { return [NglIcon,
        NglIconSvg]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglIcon,
        NglIconSvg]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_ICON_DIRECTIVES,
                exports: NGL_ICON_DIRECTIVES,
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInternalOutlet, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglInternalOutlet]',
                template: `
    <ng-template [ngIf]="isTemplate()" [ngIfElse]="str">
      <ng-template [ngTemplateOutlet]="nglInternalOutlet" [ngTemplateOutletContext]="nglInternalOutletContext"></ng-template>
    </ng-template>
    <ng-template #str>{{nglInternalOutlet}}</ng-template>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { nglInternalOutlet: [{
            type: Input
        }], nglInternalOutletContext: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglInternalOutletModule, { declarations: function () { return [NglInternalOutlet]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglInternalOutlet]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInternalOutletModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [NglInternalOutlet],
                exports: [NglInternalOutlet]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAccordionSection, [{
        type: Directive,
        args: [{
                selector: '[nglAccordionSection]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, { name: [{
            type: Input
        }], label: [{
            type: Input
        }], labelContext: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAccordion, [{
        type: Component,
        args: [{
                selector: 'ngl-accordion,[ngl-accordion]',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<li *ngFor=\"let section of sections\" nglAccordionItem [isActive]=\"isActive(section)\" [section]=\"section\" (toggle)=\"toggle(section)\"></li>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { activeNameChange: [{
            type: Output
        }], multiple: [{
            type: Input
        }], activeName: [{
            type: Input
        }], sections: [{
            type: ContentChildren,
            args: [NglAccordionSection]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAccordionItem, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'li[nglAccordionItem]',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<section class=\"slds-accordion__section\" [class.slds-is-open]=\"isActive\">\n  <div class=\"slds-accordion__summary\">\n    <h3 class=\"slds-accordion__summary-heading\" (click)=\"onToggle()\">\n      <button class=\"slds-button slds-button_reset slds-accordion__summary-action\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"isActive\">\n        <svg class=\"slds-accordion__summary-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"utility:switch\"></svg><span class=\"slds-truncate\" [nglInternalOutlet]=\"section.label\" [nglInternalOutletContext]=\"{$implicit: section.labelContext}\"></span>\n      </button>\n    </h3>\n  </div>\n  <div class=\"slds-accordion__content\" [attr.hidden]=\"isActive ? null : ''\" [id]=\"uid\">\n    <ng-container *ngIf=\"isActive\">\n      <ng-template [ngTemplateOutlet]=\"section.templateRef\"></ng-template>\n    </ng-container>\n  </div>\n</section>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { toggle: [{
            type: Output
        }], isActive: [{
            type: Input
        }], section: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAccordionModule, { declarations: function () { return [NglAccordion,
        NglAccordionSection,
        NglAccordionItem]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglAccordion,
        NglAccordionSection]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAccordionModule, [{
        type: NgModule,
        args: [{
                declarations: [...DIRECTIVES, NglAccordionItem],
                exports: DIRECTIVES,
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();

/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAlert, [{
        type: Component,
        args: [{
                selector: 'ngl-alert',
                template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_x-small\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"x-small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nglAlert'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAlertClose, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-alert[close]'
            }]
    }], function () { return [{ type: NglAlert }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAlertModule, { declarations: function () { return [NglAlert,
        NglAlertClose]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglAlert,
        NglAlertClose]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAlertModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_ALERT_DIRECTIVES],
                exports: [NGL_ALERT_DIRECTIVES],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAvatar, [{
        type: Component,
        args: [{
                selector: 'ngl-avatar',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<img *ngIf=\"shouldShowImage; else template_initials\" [src]=\"src\" [alt]=\"alternativeText\" (error)=\"onImgError()\">\n<ng-template #template_initials><abbr class=\"slds-avatar__initials\" [ngClass]=\"fallbackIconClass()\">{{ initials }}</abbr></ng-template>",
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { src: [{
            type: Input
        }], alternativeText: [{
            type: HostBinding,
            args: ['attr.title']
        }, {
            type: Input
        }], fallbackIconName: [{
            type: Input
        }], error: [{
            type: Output
        }], size: [{
            type: Input
        }], variant: [{
            type: Input
        }], initials: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglAvatarModule, { declarations: function () { return [NglAvatar]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglAvatar]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglAvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [NglAvatar],
                exports: [NglAvatar],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglBadge, [{
        type: Component,
        args: [{
                selector: 'ngl-badge',
                template: "<span class=\"slds-badge\" [ngClass]=\"theme ? 'slds-theme_' + theme : ''\">\n  <ng-content></ng-content></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { theme: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglBadgesModule, { declarations: function () { return [NglBadge]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglBadge]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglBadgesModule, [{
        type: NgModule,
        args: [{
                declarations: [NglBadge],
                exports: [NglBadge],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglBreadcrumb, [{
        type: Directive,
        args: [{
                selector: '[nglBreadcrumb]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglBreadcrumbs, [{
        type: Component,
        args: [{
                selector: 'ngl-breadcrumbs',
                template: "\n<nav role=\"navigation\" [attr.aria-label]=\"assistiveText\">\n  <ol class=\"slds-breadcrumb slds-list_horizontal slds-wrap\">\n    <li class=\"slds-breadcrumb__item\" *ngFor=\"let b of breadcrumbs\">\n      <ng-template [ngTemplateOutlet]=\"b.templateRef\"></ng-template>\n    </li>\n  </ol>\n</nav>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { assistiveText: [{
            type: Input
        }], breadcrumbs: [{
            type: ContentChildren,
            args: [NglBreadcrumb]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglBreadcrumbsModule, { declarations: function () { return [NglBreadcrumbs,
        NglBreadcrumb]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglBreadcrumbs,
        NglBreadcrumb]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglBreadcrumbsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_BREADCRUMB_DIRECTIVES],
                exports: [NGL_BREADCRUMB_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonIcon, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButtonIcon]',
                template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\" [ngClass]=\"iconClass()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }, { type: ɵngcc0.Renderer2 }]; }, { variant: [{
            type: Input
        }], iconName: [{
            type: Input
        }], title: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }], size: [{
            type: Input
        }], svgClass: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonIconStateful, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButtonIconStateful]',
                template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HostService }, { type: ɵngcc0.Renderer2 }]; }, { selected: [{
            type: HostBinding,
            args: ['class.slds-is-selected']
        }, {
            type: HostBinding,
            args: ['attr.aria-pressed']
        }, {
            type: Input
        }], selectedChange: [{
            type: Output
        }], variant: [{
            type: Input
        }], size: [{
            type: Input
        }], onclick: [{
            type: HostListener,
            args: ['click']
        }], iconName: [{
            type: Input
        }], title: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglButtonIconsModule, { declarations: function () { return [NglButtonIcon,
        NglButtonIconStateful]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglButtonIcon,
        NglButtonIconStateful]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_BUTTON_ICON_DIRECTIVES,
                exports: NGL_BUTTON_ICON_DIRECTIVES,
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButton, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglButton]',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_left\" *ngIf=\"hasLeftIcon()\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>\n<svg class=\"slds-button__icon slds-button__icon_right\" *ngIf=\"hasRightIcon()\" [nglIconName]=\"iconName\"></svg>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { variant: [{
            type: Input
        }], iconPosition: [{
            type: Input
        }], iconName: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonStateful, [{
        type: Directive,
        args: [{
                selector: '[nglButtonStateful]',
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { stateChange: [{
            type: Output
        }], variant: [{
            type: Input
        }], onSelectChange: [{
            type: HostListener,
            args: ['click']
        }], onFocusToggle: [{
            type: HostListener,
            args: ['focus', ['1']]
        }, {
            type: HostListener,
            args: ['blur', ['0']]
        }], state: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonStateOn, [{
        type: Component,
        args: [{
                selector: 'ngl-state-on',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { iconName: [{
            type: Input
        }] }); })();
const ɵNglButtonStateOff_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglButtonStateOff);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonStateOff, [{
        type: Component,
        args: [{
                selector: 'ngl-state-off',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
const ɵNglButtonStateHover_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglButtonStateHover);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonStateHover, [{
        type: Component,
        args: [{
                selector: 'ngl-state-hover',
                template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglButtonsModule, { declarations: function () { return [NglButton,
        NglButtonStateful,
        NglButtonStateOn,
        NglButtonStateOff,
        NglButtonStateHover]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglButton,
        NglButtonStateful,
        NglButtonStateOn,
        NglButtonStateOff,
        NglButtonStateHover]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglButtonsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_BUTTON_DIRECTIVES,
                exports: NGL_BUTTON_DIRECTIVES,
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCarouselImage, [{
        type: Component,
        args: [{
                selector: 'ngl-carousel-image',
                template: "<a class=\"slds-carousel__panel-action slds-text-link_reset\" href=\"javascript:void(0);\" [attr.tabindex]=\"active ? 0 : -1\">\n  <div class=\"slds-carousel__image\"><img [src]=\"src\" [attr.alt]=\"alternativeText || null\"></div>\n  <div class=\"slds-carousel__content\">\n    <h2 class=\"slds-carousel__content-title\" [nglInternalOutlet]=\"header\"></h2>\n    <p [nglInternalOutlet]=\"description\"></p>\n  </div></a>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { src: [{
            type: Input
        }], header: [{
            type: Input
        }], description: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCarouselIndicator, [{
        type: Directive,
        args: [{
                selector: '[nglCarouselIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { uid: [{
            type: HostBinding,
            args: ['attr.id']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], isActive: [{
            type: HostBinding,
            args: ['class.slds-is-active']
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: Input
        }], image: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCarousel, [{
        type: Component,
        args: [{
                selector: 'ngl-carousel',
                template: "\n<div class=\"slds-carousel__stage\"><span class=\"slds-carousel__autoplay\" *ngIf=\"autoScroll\">\n    <button class=\"slds-button slds-button_icon slds-button_icon-border-filled slds-button_icon-x-small\" [attr.aria-pressed]=\"!playing\" [title]=\"playLabel()\" (click)=\"togglePlay()\">\n      <svg class=\"slds-button__icon\" [nglIconName]=\"playing ? 'utility:pause' : 'utility:right'\"></svg><span class=\"slds-assistive-text\">{{ playLabel() }}</span>\n    </button></span>\n  <div class=\"slds-carousel__panels\" [style.transform]=\"'translateX(' + (-active * 100) + '%)'\">\n    <ng-content></ng-content>\n  </div>\n  <ul class=\"slds-carousel__indicators\" #indicatorsEl role=\"tablist\" (keydown)=\"onKeyboard($event)\">\n    <li class=\"slds-carousel__indicator\" *ngFor=\"let image of images; let i = index\" role=\"presentation\"><a class=\"slds-carousel__indicator-action\" nglCarouselIndicator href=\"javascript:void(0);\" role=\"tab\" [isActive]=\"isActive(i)\" [image]=\"getImage(i)\" [attr.aria-controls]=\"image.uid\" [title]=\"image.header\" (click)=\"onIndicatorClick(i)\"><span class=\"slds-assistive-text\">{{ image.header }}</span></a></li>\n  </ul>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-carousel]': 'true'
                }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { activeChange: [{
            type: Output
        }], scrollDuration: [{
            type: Input
        }], autoScroll: [{
            type: Input
        }], autoRefresh: [{
            type: Input
        }], labels: [{
            type: Input
        }], active: [{
            type: Input
        }], images: [{
            type: ContentChildren,
            args: [NglCarouselImage]
        }], indicators: [{
            type: ViewChildren,
            args: [NglCarouselIndicator]
        }], indicatorsEl: [{
            type: ViewChild,
            args: ['indicatorsEl', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglCarouselModule, { declarations: function () { return [NglCarousel,
        NglCarouselImage,
        NglCarouselIndicator]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglCarousel,
        NglCarouselImage]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCarouselModule, [{
        type: NgModule,
        args: [{
                declarations: [...DIRECTIVES$1, NglCarouselIndicator],
                exports: DIRECTIVES$1,
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxInput, [{
        type: Directive,
        args: [{
                selector: 'input[ngl][type=checkbox]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxButton, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-button',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox_faux\" [attr.for]=\"_uid\"><span class=\"slds-assistive-text\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-checkbox_add-button]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckbox, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox,[ngl-checkbox]',
                template: "\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox\" [class.slds-checkbox_stacked]=\"stacked\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr>\n    <ng-content></ng-content>\n    <label class=\"slds-checkbox__label\" [attr.for]=\"_uid\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], stacked: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxToggle, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-toggle',
                template: "\n<label class=\"slds-checkbox_toggle slds-grid\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span class=\"slds-form-element__label slds-m-bottom_none\" [nglInternalOutlet]=\"label\"></span>\n  <ng-content></ng-content><span class=\"slds-checkbox_faux_container\" [id]=\"uid\" aria-live=\"assertive\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-checkbox_on\">{{enabledText}}</span><span class=\"slds-checkbox_off\">{{disabledText}}</span></span>\n</label>\n<div class=\"slds-form-element__help\" *ngIf=\"error\">{{error}}</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { enabledText: [{
            type: Input
        }], disabledText: [{
            type: Input
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxOption, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-option',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-checkbox_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: HostService }]; }, { label: [{
            type: Input
        }], input: [{
            type: ContentChild,
            args: [NglCheckboxInput, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxGroup, [{
        type: Component,
        args: [{
                selector: 'ngl-checkbox-group,[ngl-checkbox-group]',
                template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return []; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], type: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NglCheckboxOption]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], required: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglCheckboxesModule, { declarations: function () { return [NglCheckboxButton,
        NglCheckbox,
        NglCheckboxToggle,
        NglCheckboxInput,
        NglCheckboxGroup,
        NglCheckboxOption]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule]; }, exports: function () { return [NglCheckboxButton,
        NglCheckbox,
        NglCheckboxToggle,
        NglCheckboxInput,
        NglCheckboxGroup,
        NglCheckboxOption]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCheckboxesModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$2,
                exports: DIRECTIVES$2,
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTab, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[ngl-tab]',
                exportAs: 'nglTab'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], id: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTabs, [{
        type: Component,
        args: [{
                selector: 'ngl-tabset',
                template: "\n<ul [ngClass]=\"'slds-tabs_' + variant + '__nav'\" role=\"tablist\" (keydown.ArrowLeft)=\"move($event, -1)\" (keydown.ArrowRight)=\"move($event, 1)\">\n  <li *ngFor=\"let tab of tabs; trackBy: trackByTab\" [ngClass]=\"'slds-tabs_' + variant + '__item'\" [class.slds-is-active]=\"tab.active\" [id]=\"tab.uid + '__item'\" [attr.aria-controls]=\"tab.uid\" (click)=\"select(tab)\" role=\"presentation\"><a [nglInternalOutlet]=\"tab.label\" [ngClass]=\"'slds-tabs_' + variant + '__link'\" role=\"tab\" [attr.aria-selected]=\"tab.active\" [attr.tabindex]=\"tab.active ? 0 : -1\"></a></li>\n</ul>\n<div *ngFor=\"let tab of tabs; trackBy: trackByTab\" [id]=\"tab.uid\" [attr.aria-labelledby]=\"tab.uid + '__item'\" [ngClass]=\"tabClass(tab)\" role=\"tabpanel\">\n  <ng-container *ngIf=\"!lazy || tab.active\">\n    <ng-template [ngTemplateOutlet]=\"tab?.templateRef\"></ng-template>\n  </ng-container>\n</div>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { selectedChange: [{
            type: Output
        }], lazy: [{
            type: Input
        }], variant: [{
            type: Input
        }], setSelected: [{
            type: Input,
            args: ['selected']
        }], tabs: [{
            type: ContentChildren,
            args: [NglTab]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTabLabel, [{
        type: Directive,
        args: [{ selector: '[ngl-tab-label]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTabContent, [{
        type: Directive,
        args: [{ selector: '[ngl-tab-content]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
const ɵNglTabVerbose_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglTabVerbose);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTabVerbose, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-tab',
                providers: [{ provide: NglTab, useExisting: NglTabVerbose_1 }]
            }]
    }], null, { contentTemplate: [{
            type: ContentChild,
            args: [NglTabContent]
        }], labelTemplate: [{
            type: ContentChild,
            args: [NglTabLabel]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTabsModule, { declarations: function () { return [NglTabs,
        NglTab,
        NglTabVerbose,
        NglTabContent,
        NglTabLabel]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule]; }, exports: function () { return [NglTabs,
        NglTab,
        NglTabVerbose,
        NglTabContent,
        NglTabLabel]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTabsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_TAB_DIRECTIVES],
                exports: [NGL_TAB_DIRECTIVES],
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPopover, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'section[ngl-popover]',
                template: "\n<button class=\"slds-button slds-button_icon slds-button_icon-small slds-float_right slds-popover__close\" *ngIf=\"canClose &amp;&amp; closeVisible\" [title]=\"closeTitle\" [class.slds-button_icon-inverse]=\"inverseCloseButton\" (click)=\"onClose()\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeTitle\">{{closeTitle}}</span>\n</button>\n<header class=\"slds-popover__header\" *ngIf=\"header\">\n  <div *ngIf=\"isTemplateRef(header); else defaultTpl\" [id]=\"labelledby\">\n    <ng-container [ngTemplateOutlet]=\"header\"></ng-container>\n  </div>\n  <ng-template #defaultTpl>\n    <h2 class=\"slds-text-heading_small\" [id]=\"labelledby\">{{header}}</h2>\n  </ng-template>\n</header>\n<div class=\"slds-popover__body\" [id]=\"uid\" [nglInternalOutlet]=\"template\"></div>\n<footer class=\"slds-popover__footer\" *ngIf=\"footer\" [nglInternalOutlet]=\"footer\"></footer>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService],
                host: {
                    'role': 'dialog',
                    '[class.slds-popover]': 'true'
                }
            }]
    }], function () { return [{ type: HostService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.FocusTrapFactory }, { type: ɵngcc0.ChangeDetectorRef }]; }, { labelledby: [{
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }], describedby: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPopoverTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglPopover]',
                exportAs: 'nglPopover'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc3.Overlay }]; }, { closeTitle: [{
            type: Input,
            args: ['nglPopoverCloseTitle']
        }], closeVisible: [{
            type: Input,
            args: ['nglPopoverCloseVisible']
        }], nglPopoverOpenChange: [{
            type: Output
        }], placement: [{
            type: Input,
            args: ['nglPopoverPlacement']
        }], nglOpen: [{
            type: Input,
            args: ['nglPopoverOpen']
        }], onclick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], template: [{
            type: Input,
            args: ['nglPopover']
        }], header: [{
            type: Input,
            args: ['nglPopoverHeader']
        }], footer: [{
            type: Input,
            args: ['nglPopoverFooter']
        }], variant: [{
            type: Input,
            args: ['nglPopoverVariant']
        }], size: [{
            type: Input,
            args: ['nglPopoverSize']
        }], popoverClass: [{
            type: Input,
            args: ['nglPopoverClass']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPopoversModule, { declarations: function () { return [NglPopover,
        NglPopoverTrigger]; }, imports: function () { return [CommonModule, OverlayModule, A11yModule,
        NglInternalOutletModule,
        NglIconsModule]; }, exports: function () { return [NglPopover,
        NglPopoverTrigger]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPopoversModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_POPOVER_DIRECTIVES],
                exports: [NGL_POPOVER_DIRECTIVES],
                imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule],
                entryComponents: [NglPopover]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTooltip, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'div[ngl-tooltip]',
                template: "\n<div class=\"slds-popover__body\" [nglInternalOutlet]=\"template\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTooltipTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglTooltip]',
                exportAs: 'nglTooltip'
            }]
    }], function () { return [{ type: NglTooltipConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_TOOLTIP_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc3.Overlay }]; }, { nglTooltipOpenChange: [{
            type: Output
        }], openAuto: [{
            type: Input,
            args: ['nglTooltipOpenAuto']
        }], interactive: [{
            type: Input,
            args: ['nglTooltipInteractive']
        }], delay: [{
            type: Input,
            args: ['nglTooltipDelay']
        }], placement: [{
            type: Input,
            args: ['nglTooltipPlacement']
        }], nglOpen: [{
            type: Input,
            args: ['nglTooltipOpen']
        }], onMouseOver: [{
            type: HostListener,
            args: ['mouseenter']
        }, {
            type: HostListener,
            args: ['focus']
        }], onMouseOut: [{
            type: HostListener,
            args: ['mouseleave']
        }, {
            type: HostListener,
            args: ['blur']
        }], template: [{
            type: Input,
            args: ['nglTooltip']
        }], tooltipClass: [{
            type: Input,
            args: ['nglTooltipClass']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTooltipsModule, { declarations: function () { return [NglTooltip,
        NglTooltipTrigger]; }, imports: function () { return [CommonModule, OverlayModule, A11yModule,
        NglInternalOutletModule]; }, exports: function () { return [NglTooltipTrigger]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTooltipsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglTooltip, NglTooltipTrigger],
                exports: [NglTooltipTrigger],
                imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule],
                entryComponents: [NglTooltip]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFormLabel, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'label[nglFormLabel]',
                template: "<abbr class=\"slds-required\" *ngIf=\"required\" title=\"Required\">*</abbr><span [nglInternalOutlet]=\"label\"></span>\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { klass: [{
            type: Input,
            args: ['nglFormLabelClass']
        }], label: [{
            type: Input,
            args: ['nglFormLabel']
        }], required: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFormHelp, [{
        type: Component,
        args: [{
                selector: 'ngl-form-help',
                template: "\n<button class=\"slds-button slds-button_icon\" [nglTooltip]=\"content\" [(nglTooltipOpen)]=\"isOpen\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:info\"></svg><span class=\"slds-assistive-text\">Help</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element__icon]': 'true'
                }
            }]
    }], function () { return []; }, { content: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFormsModule, { declarations: function () { return [NglFormLabel,
        NglFormHelp]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule,
        NglIconsModule,
        NglTooltipsModule]; }, exports: function () { return [NglFormLabel,
        NglFormHelp]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFormsModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$3,
                exports: DIRECTIVES$3,
                imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpicker, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker',
                template: "\n<div class=\"slds-color-picker__summary slds-form-element\" [class.slds-has-error]=\"!isValidInput\">\n  <label class=\"slds-form-element__label slds-color-picker__summary-label\" [nglFormLabel]=\"label\" [attr.for]=\"uid + '-summary-input'\" [required]=\"required\">\n    <ngl-form-help class=\"slds-m-horizontal_xx-small\" *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n  </label>\n  <div class=\"slds-form-element__control\">\n    <button class=\"slds-button slds-color-picker__summary-button slds-button_icon slds-button_icon-more\" [title]=\"label\" [nglPopover]=\"tip\" nglPopoverPlacement=\"bottom-left\" [nglPopoverOpen]=\"open\" (nglPopoverOpenChange)=\"openChange($event)\" nglPopoverClass=\"slds-color-picker__selector\" [nglPopoverFooter]=\"footer\" nglPopoverCloseVisible=\"false\" [disabled]=\"disabled\"><span class=\"slds-swatch\" nglColorpickerSwatch [color]=\"isValidInput ? color : hexCurrent\"></span>\n      <svg class=\"slds-button__icon slds-button__icon_small slds-m-left_xx-small\" *ngIf=\"!disabled\" nglIconName=\"utility:down\"></svg><span class=\"slds-assistive-text\">{{ label }}: {{ color }}</span>\n    </button>\n    <div class=\"slds-color-picker__summary-input\">\n      <input class=\"slds-input\" [id]=\"uid + '-summary-input'\" type=\"text\" [value]=\"color\" (input)=\"onInput($event.target.value)\" [disabled]=\"disabled\" [readOnly]=\"readonlyInput\" maxlength=\"7\" [placeholder]=\"placeholder || ''\">\n    </div>\n    <p class=\"slds-form-error\" *ngIf=\"!isValidInput\" [nglInternalOutlet]=\"invalidColorLabel\"></p>\n  </div>\n</div>\n<ng-template #tip>\n  <ng-container [ngSwitch]=\"variant\">\n    <ng-container *ngSwitchCase=\"'swatches'\">\n      <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"'custom'\">\n      <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n    </ng-container>\n    <ngl-tabset *ngSwitchDefault [selected]=\"defaultSelectedTab\" (selectedChange)=\"defaultSelectedTab = $event.id\">\n      <ng-template ngl-tab id=\"swatches\" [label]=\"swatchTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n      </ng-template>\n      <ng-template ngl-tab id=\"custom\" [label]=\"customTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n      </ng-template>\n    </ngl-tabset>\n  </ng-container>\n</ng-template>\n<ng-template #swatches>\n  <ngl-colorpicker-swatches [hex]=\"hexCurrent\" (hexChange)=\"onSwatchSelection($event)\" [swatchColors]=\"swatchColors\"></ngl-colorpicker-swatches>\n</ng-template>\n<ng-template #custom>\n  <ngl-colorpicker-custom [hsv]=\"hsvCurrent\" (hsvChange)=\"onCustomSelection($event)\"></ngl-colorpicker-custom>\n</ng-template>\n<ng-template #footer>\n  <div class=\"slds-color-picker__selector-footer\">\n    <button class=\"slds-button slds-button_neutral\" type=\"button\" (click)=\"cancel()\">{{ cancelButtonLabel }}</button>\n    <button class=\"slds-button slds-button_brand\" type=\"button\" (click)=\"done()\" [disabled]=\"!canApply()\">{{ submitButtonLabel }}</button>\n  </div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_COLORPICKER_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: NglColorpickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_COLORPICKER_CONFIG]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], submitButtonLabel: [{
            type: Input
        }], required: [{
            type: Input
        }], invalidColorLabel: [{
            type: Input
        }], swatchTabLabel: [{
            type: Input
        }], customTabLabel: [{
            type: Input
        }], readonlyInput: [{
            type: Input
        }], defaultSelectedTab: [{
            type: Input
        }], swatchColors: [{
            type: Input
        }], variant: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatch, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglColorpickerSwatch]',
                template: "<span class=\"slds-assistive-text\" aria-hidden=\"true\">{{ color }}</span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { color: [{
            type: HostBinding,
            args: ['style.background']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerCustom, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-custom',
                template: "\n<ngl-colorpicker-range [hsv]=\"hsv\" (hsvChange)=\"onHsvChange($event)\"></ngl-colorpicker-range>\n<ngl-colorpicker-inputs [hex]=\"hex\" (hexChange)=\"onHexChange($event)\"></ngl-colorpicker-inputs>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hsvChange: [{
            type: Output
        }], hsv: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerRange, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-range',
                template: "\n<p class=\"slds-assistive-text\" [attr.id]=\"uid + '-instructions'\">Use arrow keys to select a saturation and brightness, on an x and y axis.</p>\n<div class=\"slds-color-picker__custom-range\" #rangeIndicatorContainer [style.background]=\"'hsl(' + hsv.hue + ', 100%, 50%)'\"><a class=\"slds-color-picker__range-indicator\" #rangeIndicator href=\"javascript:void(0);\" aria-live=\"assertive\" aria-atomic=\"true\" [attr.aria-describedby]=\"uid + '-instructions'\" [ngStyle]=\"indicatorStyle()\" (keydown)=\"rangeIndicatorKeyboard($event)\"><span class=\"slds-assistive-text\">Saturation: {{hsv.saturation}}%. Brightness: {{hsv.value}}%.</span></a></div>\n<div class=\"slds-color-picker__hue-and-preview\">\n  <label class=\"slds-assistive-text\" [attr.for]=\"uid + '-hue'\">Select Hue</label>\n  <input class=\"slds-color-picker__hue-slider\" #hueSlider type=\"range\" min=\"0\" max=\"360\" [id]=\"uid + '-hue'\" [value]=\"hsv.hue\" (input)=\"hueSliderChange($event.target.value)\"><span nglColorpickerSwatch [color]=\"hex\"></span>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { hsvChange: [{
            type: Output
        }], hsv: [{
            type: Input
        }], rangeIndicator: [{
            type: ViewChild,
            args: ['rangeIndicator']
        }], rangeIndicatorContainer: [{
            type: ViewChild,
            args: ['rangeIndicatorContainer']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerInputs, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-inputs',
                template: "\n<div class=\"slds-color-picker__custom-inputs\">\n  <div class=\"slds-form-element slds-color-picker__input-custom-hex\" [class.slds-has-error]=\"isHexInvalid\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'hex'\">Hex</label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'hex'\" type=\"text\" maxlength=\"7\" [value]=\"hex\" (input)=\"updateHex($event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('red')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'red'\"><abbr title=\"red\">R</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'red'\" type=\"text\" maxlength=\"3\" [value]=\"red\" (input)=\"onRGB('red', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('green')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'green'\"><abbr title=\"green\">G</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'green'\" type=\"text\" maxlength=\"3\" [value]=\"green\" (input)=\"onRGB('green', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('blue')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'blue'\"><abbr title=\"blue\">B</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'blue'\" type=\"text\" maxlength=\"3\" [value]=\"blue\" (input)=\"onRGB('blue', $event.target.value)\">\n    </div>\n  </div>\n</div>\n<div class=\"slds-color-picker\">\n  <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"isHexInvalid; else rgbError\">The color entered is invalid</p>\n  <ng-template #rgbError>\n    <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"!isRGBValid()\">The value needs to be an integer from 0-255</p>\n  </ng-template>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { hexChange: [{
            type: Output
        }], hex: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatchTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglColorpickerSwatchTrigger]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { selectedChange: [{
            type: Output
        }], onSelect: [{
            type: HostListener,
            args: ['click']
        }], selected: [{
            type: HostBinding,
            args: ['class.ngl-color-picker__swatch-selected']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerSwatches, [{
        type: Component,
        args: [{
                selector: 'ngl-colorpicker-swatches',
                template: "\n<li class=\"slds-color-picker__swatch\" *ngFor=\"let color of swatchColors; let i = index\" role=\"presentation\"><a nglColorpickerSwatchTrigger href=\"javascript:void(0);\" [selected]=\"isSelected(color)\" [attr.tabindex]=\"activeIndex === i ? 0 : -1\" (selectedChange)=\"onSelect(color)\"><span nglColorpickerSwatch [color]=\"color\"></span></a></li>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .ngl-color-picker__swatch-selected {
      box-shadow: rgb(117, 112, 112) 1px 1px 1px;
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hexChange: [{
            type: Output
        }], swatchColors: [{
            type: Input
        }], onSelectViaInteraction: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], hex: [{
            type: Input
        }], triggers: [{
            type: ViewChildren,
            args: [NglColorpickerSwatchTrigger]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglColorpickerModule, { declarations: function () { return [NglColorpicker,
        NglColorpickerSwatch,
        NglColorpickerCustom,
        NglColorpickerRange,
        NglColorpickerInputs,
        NglColorpickerSwatches,
        NglColorpickerSwatchTrigger]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglTabsModule,
        NglPopoversModule,
        NglFormsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglColorpicker]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglColorpickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ...DIRECTIVES$4,
                    NglColorpickerSwatch,
                    NglColorpickerCustom,
                    NglColorpickerRange,
                    NglColorpickerInputs,
                    NglColorpickerSwatches,
                    NglColorpickerSwatchTrigger,
                ],
                exports: DIRECTIVES$4,
                imports: [
                    CommonModule,
                    NglIconsModule,
                    NglTabsModule,
                    NglPopoversModule,
                    NglFormsModule,
                    NglInternalOutletModule,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglOverlaynglOverlayScrolledOutsideViewDirective, [{
        type: Directive,
        args: [{
                selector: '[nglOverlayScrolledOutsideView]'
            }]
    }], function () { return [{ type: ɵngcc3.CdkConnectedOverlay, decorators: [{
                type: Self
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.ScrollDispatcher }]; }, { overlayOutside: [{
            type: Output,
            args: ['nglOverlayScrolledOutsideView']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglOverlayModule, { declarations: function () { return [NglOverlaynglOverlayScrolledOutsideViewDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglOverlaynglOverlayScrolledOutsideViewDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglOverlayModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: DIRECTIVES$5,
                exports: DIRECTIVES$5
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglComboboxService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglComboboxOption, [{
        type: Component,
        args: [{
                selector: 'ngl-combobox-option, [nglComboboxOption]',
                template: "\n<div class=\"slds-media slds-listbox__option slds-listbox__option_plain slds-media_small slds-media_center\" role=\"option\" [attr.id]=\"uid\" [class.slds-has-focus]=\"active\" [class.slds-is-selected]=\"selected\" [attr.aria-selected]=\"selected || null\" [attr.aria-disabled]=\"disabled || null\"><span class=\"slds-media__figure slds-listbox__option-icon\"><span class=\"slds-icon_container slds-icon-utility-check slds-current-color\" *ngIf=\"selected\">\n      <svg class=\"slds-icon slds-icon_x-small\" nglIconName=\"utility:check\"></svg></span></span><span class=\"slds-media__body\"><span class=\"slds-truncate\"><span class=\"slds-assistive-text\" *ngIf=\"selected\">Current Selection:</span>{{ label }}</span></span></div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NglComboboxService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { disabled: [{
            type: Input
        }], onSelectViaInteraction: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], hover: [{
            type: HostListener,
            args: ['mouseenter']
        }], value: [{
            type: Input
        }], label: [{
            type: Input
        }], selected: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglComboboxInput, [{
        type: Directive,
        args: [{
                selector: 'input[nglCombobox]'
            }]
    }], function () { return [{ type: NglComboboxService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { isReadonly: [{
            type: HostBinding,
            args: ['readOnly']
        }], ariaAutocomplete: [{
            type: HostBinding,
            args: ['attr.aria-autocomplete']
        }], hasReadonlyValue: [{
            type: HostBinding,
            args: ['class.slds-combobox__input-value']
        }], onMouseInteraction: [{
            type: HostListener,
            args: ['click']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onKeyboard: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglCombobox, [{
        type: Component,
        args: [{
                selector: 'ngl-combobox',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"inputEl.id\"></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-combobox_container\" [class.slds-has-selection]=\"hasLookupSingleSelection\">\n    <div class=\"slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click\" [attr.aria-expanded]=\"open\" aria-haspopup=\"listbox\" role=\"combobox\" [class.slds-is-open]=\"open\" [attr.aria-owns]=\"uid\">\n      <div class=\"slds-combobox__form-element slds-input-has-icon\" role=\"none\" cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [class.slds-input-has-icon_group-right]=\"loading\" [class.slds-input-has-icon_right]=\"!loading\">\n        <ng-content select=\"input\"></ng-content>\n        <div class=\"slds-input__icon-group slds-input__icon-group_right\" *ngIf=\"loading; else iconRight\">\n          <div class=\"slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner\" role=\"status\"><span class=\"slds-assistive-text\">Loading</span>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n          <ng-template [ngTemplateOutlet]=\"iconRight\"></ng-template>\n        </div>\n        <ng-template #iconRight>\n          <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" *ngIf=\"hasLookupSingleSelection; else iconTpl\" type=\"button\" (click)=\"onClearSelection()\" title=\"Remove selected option\">\n            <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\">Remove selected option</span>\n          </button>\n        </ng-template>\n        <ng-template #iconTpl><span class=\"slds-icon_container slds-input__icon slds-input__icon_right\">\n            <svg class=\"slds-icon slds-icon_x-small slds-icon-text-default\" [nglIconName]=\"inputIconRight()\"></svg></span></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayMinWidth]=\"overlayWidth\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"close()\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <div class=\"slds-dropdown slds-dropdown_fluid\" #dropdown [attr.id]=\"uid\" role=\"listbox\" [ngClass]=\"dropdownClass()\" (mousedown)=\"$event.preventDefault()\">\n    <ul class=\"slds-listbox slds-listbox_vertical\" role=\"presentation\">\n      <li *ngFor=\"let d of data; trackBy: trackByOption\" nglComboboxOption [value]=\"d.value\" [label]=\"d.label\" [disabled]=\"d.disabled\" [selected]=\"isSelected(d.value)\"></li>\n      <li class=\"slds-listbox__item\" *ngIf=\"loadingMore\" role=\"presentation\">\n        <div class=\"slds-align_absolute-center slds-p-top_medium\">\n          <div class=\"slds-spinner slds-spinner_x-small slds-spinner_inline\" role=\"status\">\n            <div class=\"slds-assistive-text\">Loading</div>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n        </div>\n      </li>\n      <li class=\"slds-listbox__item\" *ngIf=\"hasNoMatches()\" role=\"presentation\" aria-live=\"polite\">\n        <div class=\"slds-align_absolute-center\"><span role=\"status\">No matches found.</span></div>\n      </li>\n    </ul>\n  </div>\n</ng-template>",
                host: {
                    'class.slds-form-element': 'true'
                },
                providers: [NglComboboxService]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: NglComboboxService }]; }, { variant: [{
            type: Input
        }], open: [{
            type: Input
        }], openChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], multiple: [{
            type: Input
        }], visibleLength: [{
            type: Input
        }], closeOnSelection: [{
            type: Input
        }], selectionValueFn: [{
            type: Input
        }], data: [{
            type: Input,
            args: ['options']
        }], label: [{
            type: Input
        }], selection: [{
            type: Input
        }], inputEl: [{
            type: ContentChild,
            args: [NglComboboxInput, { static: true }]
        }], loading: [{
            type: Input
        }], loadingMore: [{
            type: Input
        }], options: [{
            type: ViewChildren,
            args: [NglComboboxOption]
        }], overlayOrigin: [{
            type: ViewChild,
            args: ['overlayOrigin', { static: true }]
        }], cdkOverlay: [{
            type: ViewChild,
            args: ['cdkOverlay']
        }], dropdownElementRef: [{
            type: ViewChild,
            args: ['dropdown']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglComboboxesModule, { declarations: function () { return [NglCombobox,
        NglComboboxOption,
        NglComboboxInput]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule,
        NglIconsModule,
        NglFormsModule,
        OverlayModule,
        NglOverlayModule]; }, exports: function () { return [NglCombobox,
        NglComboboxOption,
        NglComboboxInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglComboboxesModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$6,
                exports: DIRECTIVES$6,
                imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatableCell, [{
        type: Directive,
        args: [{ selector: '[nglDatatableCell]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatableHeadingTemplate, [{
        type: Directive,
        args: [{ selector: '[nglDatatableHeading]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatableColumn, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'ngl-datatable-column'
            }]
    }], function () { return []; }, { sortable: [{
            type: Input
        }], truncate: [{
            type: Input
        }], heading: [{
            type: Input
        }], key: [{
            type: Input
        }], headClass: [{
            type: Input
        }], cellClass: [{
            type: Input
        }], cellTpl: [{
            type: ContentChild,
            args: [NglDatatableCell]
        }], headingTpl: [{
            type: ContentChild,
            args: [NglDatatableHeadingTemplate]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatableLoadingOverlay, [{
        type: Directive,
        args: [{ selector: '[nglLoadingOverlay]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatableNoRowsOverlay, [{
        type: Directive,
        args: [{ selector: '[nglNoRowsOverlay]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatable, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'table[ngl-datatable]',
                template: "\n<thead>\n  <tr class=\"slds-line-height_reset\">\n    <th *ngFor=\"let col of columns; trackBy:columnTrackBy\" nglDatatableHead scope=\"col\" [heading]=\"col.heading\" [headingTpl]=\"col.headingTpl?.templateRef\" [sortable]=\"col.sortable\" [sortOrder]=\"getColumnSortOrder(col)\" (sort)=\"onColumnSort(col, $event)\" [ngClass]=\"col.headClass\"></th>\n  </tr>\n</thead>\n<tbody>\n  <ng-template #noData>\n    <tr>\n      <td [attr.colspan]=\"columns.length\">\n        <ng-template [ngTemplateOutlet]=\"noRowsOverlay?.templateRef\"></ng-template>\n      </td>\n    </tr>\n  </ng-template>\n  <ng-container *ngIf=\"data &amp;&amp; data.length &gt; 0; else noData\">\n    <tr *ngFor=\"let d of data; let i = index; trackBy:dataTrackBy\" (click)=\"onRowClick($event, d)\">\n      <td *ngFor=\"let col of columns; trackBy:columnTrackBy\" [ngClass]=\"col.cellClass\" nglDatatatableCell_ [row]=\"d\" [column]=\"col\" [index]=\"i\"></td>\n    </tr>\n  </ng-container>\n</tbody>\n<div class=\"ngl-datatable-loading slds-align_absolute-center\" *ngIf=\"showLoading\">\n  <ng-template [ngTemplateOutlet]=\"loadingOverlay.templateRef\"></ng-template>\n</div>",
                host: {
                    '[class.slds-table]': 'true'
                },
                styles: [`
    .ngl-datatable-loading {
      position: absolute;
      z-index: 1;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.5)
    }
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { data: [{
            type: Input
        }], sortChange: [{
            type: Output
        }], loading: [{
            type: HostBinding,
            args: ['class.slds-is-relative']
        }, {
            type: Input
        }], rowClick: [{
            type: Output
        }], trackByKey: [{
            type: Input
        }], sort: [{
            type: Input
        }], loadingOverlay: [{
            type: ContentChild,
            args: [NglDatatableLoadingOverlay]
        }], noRowsOverlay: [{
            type: ContentChild,
            args: [NglDatatableNoRowsOverlay]
        }], columns: [{
            type: ContentChildren,
            args: [NglDatatableColumn]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInternalDatatableHeadCell, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'th[nglDatatableHead]',
                template: "<a class=\"slds-th__action slds-text-link_reset\" *ngIf=\"sortable; else baseTpl\" (click)=\"sortChange()\" role=\"button\" tabindex=\"0\"><span class=\"slds-assistive-text\">Sort by:</span>\n  <div class=\"slds-grid slds-grid_vertical-align-center slds-has-flexi-truncate\"><span class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></span><span class=\"slds-icon_container slds-icon-utility-arrowdown\">\n      <svg class=\"slds-icon slds-icon-text-default slds-is-sortable__icon\" nglIconName=\"arrowdown\"></svg></span></div></a>\n<ng-template #baseTpl>\n  <div class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-is-sorted_asc]': `sortOrder === 'asc'`,
                    '[class.slds-is-sorted_desc]': `sortOrder === 'desc'`,
                    '[class.slds-is-sorted]': `!!sortOrder`
                }
            }]
    }], function () { return []; }, { sort: [{
            type: Output
        }], ariaSort: [{
            type: HostBinding,
            args: ['attr.aria-sort']
        }], heading: [{
            type: Input
        }], headingTpl: [{
            type: Input
        }], sortable: [{
            type: HostBinding,
            args: ['class.slds-is-sortable']
        }, {
            type: Input
        }], sortOrder: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInternalDatatableCell, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'td[nglDatatatableCell_]',
                template: "\n<div [class.slds-truncate]=\"column.truncate\" [attr.title]=\"column.truncate ? value : null\">\n  <ng-container *ngIf=\"column.cellTpl; else stringTpl\" [ngTemplateOutlet]=\"column.cellTpl.templateRef\" [ngTemplateOutletContext]=\"context\"></ng-container>\n  <ng-template #stringTpl>{{ value }}</ng-template>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { dataLabel: [{
            type: HostBinding,
            args: ['attr.data-label']
        }], row: [{
            type: Input
        }], column: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDatatablesModule, { declarations: function () { return [NglDatatable,
        NglDatatableColumn,
        NglDatatableCell,
        NglDatatableHeadingTemplate,
        NglDatatableLoadingOverlay,
        NglDatatableNoRowsOverlay,
        NglInternalDatatableHeadCell,
        NglInternalDatatableCell]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglDatatable,
        NglDatatableColumn,
        NglDatatableCell,
        NglDatatableHeadingTemplate,
        NglDatatableLoadingOverlay,
        NglDatatableNoRowsOverlay]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatatablesModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_DATATABLE_DIRECTIVES, NglInternalDatatableHeadCell, NglInternalDatatableCell],
                exports: [NGL_DATATABLE_DIRECTIVES],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglClickOutsideDirective, [{
        type: Directive,
        args: [{
                selector: '[nglClickOutside]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ElementRef }]; }, { clickOutside: [{
            type: Output,
            args: ['nglClickOutside']
        }], ignore: [{
            type: Input,
            args: ['nglClickOutsideIgnore']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglClickOutsideModule, { declarations: function () { return [NglClickOutsideDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglClickOutsideDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglClickOutsideModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: DIRECTIVES$7,
                exports: DIRECTIVES$7
            }]
    }], null, null); })();
const ɵNglDateAdapter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDateAdapter);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDateAdapter, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepickerInput, [{
        type: Component,
        args: [{
                selector: 'ngl-datepicker-input',
                template: "\n<label class=\"slds-form-element__label\" *ngIf=\"label\" [attr.for]=\"uid\" [nglInternalOutlet]=\"label\"></label>\n<div class=\"slds-form-element__control slds-input-has-icon slds-input-has-icon_right\" #formEl>\n  <input class=\"slds-input\" #inputEl cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [id]=\"uid\" type=\"text\" autocomplete=\"off\" [placeholder]=\"placeholder\" [disabled]=\"disabled\" [readOnly]=\"readonlyInput\" (click)=\"onTriggerClick('input')\" (keydown)=\"onKeyboardInput($event)\" (input)=\"onInputChange($event.target.value)\" (blur)=\"onBlur()\">\n  <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" type=\"button\" [title]=\"selectDateLabel\" [disabled]=\"disabled\" (click)=\"onTriggerClick('button')\">\n    <svg class=\"slds-button__icon\" nglIconName=\"utility:event\"></svg><span class=\"slds-assistive-text\">{{ selectDateLabel }}</span>\n  </button>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"closeCalendar(false)\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <ngl-datepicker class=\"slds-dropdown\" [attr.aria-hidden]=\"!open\" [date]=\"date\" [monthNames]=\"monthNames\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\" [firstDayOfWeek]=\"firstDayOfWeek\" [showToday]=\"showToday\" [min]=\"min\" [max]=\"max\" [relativeYearFrom]=\"relativeYearFrom\" [relativeYearTo]=\"relativeYearTo\" [todayLabel]=\"todayLabel\" [previousMonthLabel]=\"previousMonthLabel\" [nextMonthLabel]=\"nextMonthLabel\" [dateDisabled]=\"dateDisabled\" (dateChange)=\"pickerSelection($event)\" (nglClickOutside)=\"closeCalendar(false)\" [nglClickOutsideIgnore]=\"formEl\"></ngl-datepicker>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_DATEPICKER_INPUT_VALUE_ACCESSOR, NGL_DATEPICKER_INPUT_VALIDATOR, HostService]
            }]
    }], function () { return [{ type: NglDatepickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_DATEPICKER_CONFIG]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: HostService }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.FocusTrapFactory }, { type: NglDateAdapter }]; }, { placeholder: [{
            type: Input
        }], readonlyInput: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], selectDateLabel: [{
            type: Input
        }], dateDisabled: [{
            type: Input
        }], format: [{
            type: Input
        }], delimiter: [{
            type: Input
        }], monthNames: [{
            type: Input
        }], dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], showToday: [{
            type: Input
        }], relativeYearFrom: [{
            type: Input
        }], relativeYearTo: [{
            type: Input
        }], openOnInputClick: [{
            type: Input
        }], todayLabel: [{
            type: Input
        }], previousMonthLabel: [{
            type: Input
        }], nextMonthLabel: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], label: [{
            type: Input
        }], dropdownAlign: [{
            type: Input
        }], inputEl: [{
            type: ViewChild,
            args: ['inputEl', { static: true }]
        }], cdkOverlay: [{
            type: ViewChild,
            args: ['cdkOverlay']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDay, [{
        type: Directive,
        args: [{
                selector: 'td[nglDay]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], date: [{
            type: Input,
            args: ['nglDay']
        }], nglDayDisabled: [{
            type: HostBinding,
            args: ['class.slds-disabled-text']
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: Input
        }], nglDaySelected: [{
            type: HostBinding,
            args: ['class.slds-is-selected']
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: Input
        }], isActive: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepickerMonth, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nglDatepickerMonth]',
                template: "\n<tr *ngFor=\"let week of weeks; trackBy:indexTrackBy\">\n  <td *ngFor=\"let date of week; trackBy:dateTrackBy\" [class.slds-is-today]=\"date.today\" [isActive]=\"date.active\" [nglDay]=\"date\" [nglDaySelected]=\"date.selected\" [nglDayDisabled]=\"date.disabled\" (click)=\"onSelect(date)\" role=\"gridcell\"><span class=\"slds-day\">{{ date.day }}</span></td>\n</tr>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { dateDisabled: [{
            type: Input
        }], selectDate: [{
            type: Output
        }], selected: [{
            type: Input
        }], year: [{
            type: Input
        }], month: [{
            type: Input
        }], day: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], minDate: [{
            type: Input
        }], maxDate: [{
            type: Input
        }], days: [{
            type: ViewChildren,
            args: [NglDay]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepicker, [{
        type: Component,
        args: [{
                selector: 'ngl-datepicker',
                template: "\n<div class=\"slds-datepicker__filter slds-grid\">\n  <div class=\"slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\">\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(-1)\" [disabled]=\"previousDisabled()\" [title]=\"previousMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"left\"></svg><span class=\"slds-assistive-text\">{{ previousMonthLabel }}</span>\n      </button>\n    </div>\n    <h2 class=\"slds-align-middle\" [id]=\"uid + '_month'\" aria-live=\"assertive\" aria-atomic=\"true\">{{ monthLabel }}</h2>\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(1)\" [disabled]=\"nextDisabled()\" [title]=\"nextMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"right\"></svg><span class=\"slds-assistive-text\">{{ nextMonthLabel }}</span>\n      </button>\n    </div>\n  </div>\n  <ngl-date-year class=\"slds-shrink-none\" [year]=\"current.year\" [from]=\"minDate\" [to]=\"maxDate\" (yearChange)=\"moveYear($event)\"></ngl-date-year>\n</div>\n<table class=\"datepicker__month\" role=\"grid\" [attr.aria-labelledby]=\"uid + '_month'\" (keydown)=\"keyboardHandler($event)\">\n  <thead>\n    <tr nglWeekdays [firstDayOfWeek]=\"firstDayOfWeek\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\"></tr>\n  </thead>\n  <tbody *ngIf=\"current\" nglDatepickerMonth [year]=\"current.year\" [month]=\"current.month\" [day]=\"current.day\" [selected]=\"_date\" [firstDayOfWeek]=\"firstDayOfWeek\" [minDate]=\"minDate\" [maxDate]=\"maxDate\" [dateDisabled]=\"dateDisabled\" (selectDate)=\"select($event)\"></tbody>\n</table>\n<button class=\"slds-button slds-align_absolute-center slds-text-link\" *ngIf=\"showToday\" (click)=\"selectToday()\">{{ todayLabel }}</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-datepicker]': 'true'
                },
                styles: [`:host { display: block; }`]
            }]
    }], function () { return [{ type: NglDatepickerInput, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NglDatepickerInput]
            }] }, { type: NglDatepickerConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_DATEPICKER_CONFIG]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { dateDisabled: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], monthNames: [{
            type: Input
        }], dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }], showToday: [{
            type: Input
        }], relativeYearFrom: [{
            type: Input
        }], relativeYearTo: [{
            type: Input
        }], todayLabel: [{
            type: Input
        }], previousMonthLabel: [{
            type: Input
        }], nextMonthLabel: [{
            type: Input
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], monthView: [{
            type: ViewChild,
            args: [NglDatepickerMonth]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepickerWeekdays, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'tr[nglWeekdays]',
                template: "\n<th *ngFor=\"let day of weekdays\" [id]=\"day.id\" scope=\"col\"><abbr [title]=\"day.title\">{{day.label}}</abbr></th>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { dayNamesShort: [{
            type: Input
        }], dayNamesLong: [{
            type: Input
        }], firstDayOfWeek: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepickerYear, [{
        type: Component,
        args: [{
                selector: 'ngl-date-year',
                template: "\n<label class=\"slds-assistive-text\" [attr.for]=\"uid\">Pick a Year</label>\n<div class=\"slds-select_container\">\n  <select class=\"slds-select\" [id]=\"uid\" [ngModel]=\"year\" (ngModelChange)=\"change($event)\">\n    <option *ngFor=\"let yr of range\" [value]=\"yr\">{{yr}}</option>\n  </select>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { yearChange: [{
            type: Output
        }], from: [{
            type: Input
        }], to: [{
            type: Input
        }], year: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDatepickersModule, { declarations: function () { return [NglDatepicker,
        NglDatepickerInput,
        NglDay,
        NglDatepickerWeekdays,
        NglDatepickerYear,
        NglDatepickerMonth]; }, imports: function () { return [CommonModule,
        FormsModule,
        NglIconsModule,
        NglInternalOutletModule,
        OverlayModule,
        NglClickOutsideModule,
        NglOverlayModule]; }, exports: function () { return [NglDatepicker,
        NglDatepickerInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDatepickersModule, [{
        type: NgModule,
        args: [{
                declarations: [...EXPORTS, NglDay, NglDatepickerWeekdays, NglDatepickerYear, NglDatepickerMonth],
                exports: EXPORTS,
                imports: [
                    CommonModule,
                    FormsModule,
                    NglIconsModule,
                    NglInternalOutletModule,
                    OverlayModule,
                    NglClickOutsideModule,
                    NglOverlayModule,
                ],
                providers: [NglDateAdapter]
            }]
    }], null, null); })();

const ɵNglDynamicIcon_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIcon);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIcon, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon',
                template: "\n<ng-container [ngSwitch]=\"type\">\n  <ngl-dynamic-icon-ellie *ngSwitchCase=\"'ellie'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-ellie>\n  <ngl-dynamic-icon-eq *ngSwitchCase=\"'eq'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-eq>\n  <ngl-dynamic-icon-score *ngSwitchCase=\"'score'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-score>\n  <ngl-dynamic-icon-waffle *ngSwitchCase=\"'waffle'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-waffle>\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { type: [{
            type: Input
        }], option: [{
            type: Input
        }] }); })();
const ɵNglDynamicIconEllie_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconEllie);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIconEllie, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-ellie',
                template: "<span class=\"slds-icon-ellie slds-is-animated\">\n  <svg viewbox=\"0 0 280 14\" aria-hidden=\"true\">\n    <circle cx=\"7\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"7\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"3\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
const ɵNglDynamicIconEq_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconEq);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIconEq, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-eq',
                template: "\n<div class=\"slds-icon-eq\" [class.slds-is-animated]=\"isAnimated()\">\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { option: [{
            type: Input
        }] }); })();
const ɵNglDynamicIconScore_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconScore);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIconScore, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-score',
                template: "<span class=\"slds-icon-score\" [attr.data-slds-state]=\"option\">\n  <svg class=\"slds-icon-score__positive\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg>\n  <svg class=\"slds-icon-score__negative\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { option: [{
            type: Input
        }] }); })();
const ɵNglDynamicIconWaffle_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NglDynamicIconWaffle);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIconWaffle, [{
        type: Component,
        args: [{
                selector: 'ngl-dynamic-icon-waffle',
                template: "\n<button class=\"slds-button slds-icon-waffle_container\" type=\"button\"><span class=\"slds-icon-waffle\"><span class=\"slds-r1\"></span><span class=\"slds-r2\"></span><span class=\"slds-r3\"></span><span class=\"slds-r4\"></span><span class=\"slds-r5\"></span><span class=\"slds-r6\"></span><span class=\"slds-r7\"></span><span class=\"slds-r8\"></span><span class=\"slds-r9\"></span></span><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></button>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglDynamicIconsModule, { declarations: function () { return [NglDynamicIcon,
        NglDynamicIconEllie,
        NglDynamicIconEq,
        NglDynamicIconScore,
        NglDynamicIconWaffle]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglDynamicIcon,
        NglDynamicIconEllie,
        NglDynamicIconEq,
        NglDynamicIconScore,
        NglDynamicIconWaffle]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDynamicIconsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_DYNAMIC_ICON_DIRECTIVES,
                exports: NGL_DYNAMIC_ICON_DIRECTIVES,
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFile, [{
        type: Component,
        args: [{
                selector: 'ngl-file',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<figure>\n  <ng-content></ng-content>\n  <figcaption class=\"slds-file__title slds-file__title_card\" *ngIf=\"text\">\n    <div class=\"slds-media slds-media_small slds-media_center\">\n      <div class=\"slds-media__figure slds-line-height_reset\" *ngIf=\"iconName\">\n        <ngl-icon [iconName]=\"iconName\"></ngl-icon>\n      </div>\n      <div class=\"slds-media__body\"><span class=\"slds-file__text slds-truncate\" [title]=\"text\" [nglInternalOutlet]=\"text\"></span></div>\n    </div>\n  </figcaption>\n</figure>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { text: [{
            type: HostBinding,
            args: ['class.slds-has-title']
        }, {
            type: Input
        }], iconName: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFileCrop, [{
        type: Directive,
        args: [{
                selector: '[nglFileCrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { nglFileCrop: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFilesModule, { declarations: function () { return [NglFile,
        NglFileCrop]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglFile,
        NglFileCrop]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFilesModule, [{
        type: NgModule,
        args: [{
                declarations: [NglFile, NglFileCrop],
                exports: [NglFile, NglFileCrop],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFileUpload, [{
        type: Component,
        args: [{
                selector: 'ngl-file-upload',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<span class=\"slds-form-element__label\" *ngIf=\"label\" [id]=\"uid + '-primary-label'\" [nglInternalOutlet]=\"label\"></span>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-file-selector slds-file-selector_files\">\n    <div class=\"slds-file-selector__dropzone\" [class.slds-has-drag-over]=\"isDragOver\" (dragover)=\"onDropZone($event)\" (dragleave)=\"onDropZone($event)\" (drop)=\"onDropZone($event)\">\n      <input class=\"slds-file-selector__input slds-assistive-text\" type=\"file\" [id]=\"uid\" [attr.accept]=\"accept\" [disabled]=\"disabled\" [multiple]=\"maxFiles !== 1\" [attr.aria-describedby]=\"error ? uid + '-error' : null\" [attr.aria-labelledby]=\"uid + '-primary-label ' + uid + '-secondary-label'\" (change)=\"onInputChange($event.target.files)\">\n      <label class=\"slds-file-selector__body\" [attr.for]=\"uid\" [id]=\"uid + '-secondary-label'\"><span class=\"slds-file-selector__button slds-button slds-button_neutral\">\n          <svg class=\"slds-button__icon slds-button__icon_left\" nglIconName=\"utility:upload\"></svg>{{ uploadButtonLabel }}</span><span class=\"slds-file-selector__text slds-medium-show\">{{ dropZoneLabel }}</span></label>\n    </div>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NglFileUpload_1,
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: NglFileUpload_1,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { accept: [{
            type: Input
        }], disabled: [{
            type: Input
        }], maxFiles: [{
            type: Input
        }], maxFilesize: [{
            type: Input
        }], error: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }, {
            type: Input
        }], uploadButtonLabel: [{
            type: Input
        }], dropZoneLabel: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglFileUploadModule, { declarations: function () { return [NglFileUpload]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglFileUpload]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglFileUploadModule, [{
        type: NgModule,
        args: [{
                declarations: [NglFileUpload],
                exports: [NglFileUpload],
                imports: [CommonModule, NglIconsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInputElement, [{
        type: Directive,
        args: [{
                selector: 'input[ngl]:not([type=checkbox]):not([type=radio])',
                host: {
                    '[class.slds-input]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInput, [{
        type: Component,
        args: [{
                selector: 'ngl-input,[ngl-input]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <ng-content></ng-content>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglInputElement, { static: true }]
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], stacked: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglInputModule, { declarations: function () { return [NglInput,
        NglInputElement]; }, imports: function () { return [CommonModule,
        NglFormsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglInput,
        NglInputElement]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglInputModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$8,
                exports: DIRECTIVES$8,
                imports: [CommonModule, NglFormsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDropdownItem, [{
        type: Directive,
        args: [{
                selector: '[nglDropdownItem]',
                host: {
                    'tabindex': '0'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDropdown, [{
        type: Directive,
        args: [{
                selector: '[nglDropdown]',
                host: {
                    '[class.slds-dropdown-trigger]': 'true',
                    '[class.slds-dropdown-trigger_click]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { handlePageEvents: [{
            type: Input
        }], isOpenChange: [{
            type: Output,
            args: ['openChange']
        }], isOpen: [{
            type: Input,
            args: ['open']
        }], onKeydownClose: [{
            type: HostListener,
            args: ['keydown.esc', ['"esc"']]
        }, {
            type: HostListener,
            args: ['keydown.tab', ['"tab"']]
        }], onKeydownFocusNext: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event', '"next"']]
        }, {
            type: HostListener,
            args: ['keydown.arrowup', ['$event', '"previous"']]
        }], items: [{
            type: ContentChildren,
            args: [NglDropdownItem, { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglDropdownTrigger, [{
        type: Directive,
        args: [{
                selector: '[nglDropdownTrigger]',
                host: {
                    'aria-haspopup': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NglDropdown }]; }, { toggleOpen: [{
            type: HostListener,
            args: ['click']
        }], onKeyDownOpen: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglMenusModule, { declarations: function () { return [NglDropdown,
        NglDropdownTrigger,
        NglDropdownItem]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglDropdown,
        NglDropdownTrigger,
        NglDropdownItem]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglMenusModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_DROPDOWN_DIRECTIVES],
                exports: [NGL_DROPDOWN_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModalHeaderTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalHeader]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModalTaglineTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalTagline]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModalFooterTemplate, [{
        type: Directive,
        args: [{ selector: '[nglModalFooter]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModal, [{
        type: Component,
        args: [{
                selector: 'ngl-modal',
                template: "\n<section class=\"slds-modal\" [ngClass]=\"modalClass()\" [attr.aria-hidden]=\"!open\" [attr.aria-labelledby]=\"headingId\" [attr.aria-describedby]=\"contentId\" aria-modal=\"true\" [attr.role]=\"prompt ? 'alertdialog' : 'dialog'\" tabindex=\"-1\">\n  <div class=\"slds-modal__container\">\n    <header class=\"slds-modal__header\" [ngClass]=\"modalHeaderClass()\">\n      <button class=\"slds-button slds-button_icon slds-button_icon-inverse slds-modal__close\" *ngIf=\"showClose\" type=\"button\" (click)=\"close()\">\n        <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n      </button>\n      <ng-template #localHeader>\n        <h2 class=\"slds-text-heading_medium slds-hyphenate\" *ngIf=\"header\" [id]=\"headingId\">{{header}}</h2>\n      </ng-template>\n      <ng-template *ngIf=\"headerTpl; else localHeader\" [ngTemplateOutlet]=\"headerTpl.templateRef\" [ngTemplateOutletContext]=\"{id: headingId}\"></ng-template>\n      <p class=\"slds-m-top_x-small\" *ngIf=\"hasHeader &amp;&amp; taglineTpl\">\n        <ng-template [ngTemplateOutlet]=\"taglineTpl.templateRef\"></ng-template>\n      </p>\n    </header>\n    <div class=\"slds-modal__content\" [id]=\"contentId\" cdkScrollable>\n      <ng-content></ng-content>\n    </div>\n    <footer class=\"slds-modal__footer\" *ngIf=\"footer\" [ngClass]=\"modalFooterClass()\">\n      <ng-template [ngTemplateOutlet]=\"footer.templateRef\"></ng-template>\n    </footer>\n  </div>\n</section>\n<div class=\"slds-backdrop\" [class.slds-backdrop_open]=\"open\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc2.FocusTrapFactory }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc3.Overlay }, { type: ɵngcc0.ElementRef }]; }, { header: [{
            type: Input
        }], directional: [{
            type: Input
        }], open: [{
            type: Input
        }], closeButtonAssistiveText: [{
            type: Input
        }], openChange: [{
            type: Output
        }], dismissOnClickOutside: [{
            type: Input
        }], close: [{
            type: HostListener,
            args: ['keydown.esc', ['$event']]
        }], clickOutside: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], size: [{
            type: Input
        }], headerTpl: [{
            type: ContentChild,
            args: [NglModalHeaderTemplate]
        }], taglineTpl: [{
            type: ContentChild,
            args: [NglModalTaglineTemplate]
        }], footer: [{
            type: ContentChild,
            args: [NglModalFooterTemplate]
        }], prompt: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglModalsModule, { declarations: function () { return [NglModal,
        NglModalFooterTemplate,
        NglModalHeaderTemplate,
        NglModalTaglineTemplate]; }, imports: function () { return [CommonModule, A11yModule, OverlayModule,
        NglIconsModule]; }, exports: function () { return [NglModal,
        NglModalFooterTemplate,
        NglModalHeaderTemplate,
        NglModalTaglineTemplate]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModalsModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_MODAL_DIRECTIVES],
                exports: [NGL_MODAL_DIRECTIVES],
                imports: [CommonModule, A11yModule, OverlayModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglToast, [{
        type: Component,
        args: [{
                selector: 'ngl-toast',
                template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_small slds-no-flex slds-align-top\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nglToast'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglToastClose, [{
        type: Directive,
        args: [{
                selector: 'ngl-toast[close],ngl-toast[nglClose]'
            }]
    }], function () { return [{ type: NglToast }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglToastModule, { declarations: function () { return [NglToast,
        NglToastClose]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglToast,
        NglToastClose]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglToastModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_TOAST_DIRECTIVES],
                exports: [NGL_TOAST_DIRECTIVES],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPagination, [{
        type: Component,
        args: [{
                selector: 'ngl-pagination',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<div class=\"slds-button-group\" role=\"group\">\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasPrevious()\" (click)=\"goto(1)\">{{firstText}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasPrevious()\" (click)=\"goto(current - 1)\">{{previousText}}</button>\n  <button class=\"slds-button\" *ngFor=\"let page of pages; trackBy:pageTrackBy\" [ngClass]=\"'slds-button_' + (page.number === current ? 'brand' : 'neutral')\" (click)=\"goto(page.number)\" [disabled]=\"page.disabled\">{{page.number}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasNext()\" (click)=\"goto(current + 1)\">{{nextText}}</button>\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasNext()\" (click)=\"goto(totalPages)\">{{lastText}}</button>\n</div>",
                exportAs: 'nglPagination'
            }]
    }], function () { return []; }, { pageChange: [{
            type: Output
        }], perPage: [{
            type: Input
        }], limit: [{
            type: Input
        }], boundaryNumbers: [{
            type: Input
        }], firstText: [{
            type: Input
        }], previousText: [{
            type: Input
        }], nextText: [{
            type: Input
        }], lastText: [{
            type: Input
        }], boundaryLinks: [{
            type: Input
        }], page: [{
            type: Input
        }], total: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPaginationsModule, { declarations: function () { return [NglPagination]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglPagination]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPaginationsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglPagination],
                exports: [NglPagination],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPick, [{
        type: Directive,
        args: [{
                selector: '[nglPick]'
            }]
    }], function () { return []; }, { nglPickChange: [{
            type: Output
        }], nglOptionDestroyed: [{
            type: Output
        }], isMultiple: [{
            type: Input,
            args: ['nglPickMultiple']
        }], setSelected: [{
            type: Input,
            args: ['nglPick']
        }], nglPickActiveClass: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPickOption, [{
        type: Directive,
        args: [{
                selector: '[nglPickOption]',
                exportAs: 'nglPickOption',
                host: {
                    'role': 'button'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NglPick }]; }, { setValue: [{
            type: Input,
            args: ['nglPickOption']
        }], pick: [{
            type: HostListener,
            args: ['click']
        }, {
            type: HostListener,
            args: ['keydown.Space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Enter', ['$event']]
        }], nglPickActiveClass: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPickModule, { declarations: function () { return [NglPick,
        NglPickOption]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglPick,
        NglPickOption]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPickModule, [{
        type: NgModule,
        args: [{
                declarations: [NGL_PICK_DIRECTIVES],
                exports: [NGL_PICK_DIRECTIVES],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPill, [{
        type: Component,
        args: [{
                selector: 'ngl-pill',
                template: "<span class=\"slds-pill__icon_container\" *ngIf=\"pillIcon\">\n  <ng-container *ngIf=\"isTemplateRef(pillIcon); else defaultTpl\" [ngTemplateOutlet]=\"pillIcon\"></ng-container>\n  <ng-template #defaultTpl>\n    <ngl-icon *ngIf=\"icon; else avatarTpl\" [iconName]=\"icon\"></ngl-icon>\n    <ng-template #avatarTpl>\n      <ngl-avatar [src]=\"avatar\" variant=\"circle\"></ngl-avatar>\n    </ng-template>\n  </ng-template></span>\n<ng-container *ngIf=\"linked; else unlinked\">\n  <ng-content select=\"a\"></ng-content>\n</ng-container>\n<ng-template #unlinked><span class=\"slds-pill__label\">\n    <ng-content></ng-content></span></ng-template>\n<button class=\"slds-button slds-button_icon slds-pill__remove\" *ngIf=\"canRemove &amp;&amp; removable\" type=\"button\" [title]=\"removeTitle\" (click)=\"onRemove($event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"removeTitle\">{{removeTitle}}</span>\n</button>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-pill]': 'true'
                }
            }]
    }], function () { return []; }, { hasError: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.slds-has-error']
        }], removable: [{
            type: Input
        }], removeTitle: [{
            type: Input
        }], remove: [{
            type: Output
        }], linked: [{
            type: HostBinding,
            args: ['class.slds-pill_link']
        }], icon: [{
            type: Input
        }], avatar: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPillLink, [{
        type: Component,
        args: [{
                //  tslint:disable-next-line:component-selector
                selector: 'a[nglPillAction]',
                template: "<span class=\"slds-pill__label\">\n  <ng-content></ng-content></span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-pill__action]': 'true'
                }
            }]
    }], function () { return [{ type: NglPill }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglPillsModule, { declarations: function () { return [NglPill,
        NglPillLink]; }, imports: function () { return [CommonModule,
        NglIconsModule,
        NglAvatarModule]; }, exports: function () { return [NglPill,
        NglPillLink]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglPillsModule, [{
        type: NgModule,
        args: [{
                declarations: NGL_PILL_DIRECTIVES,
                exports: NGL_PILL_DIRECTIVES,
                imports: [CommonModule, NglIconsModule, NglAvatarModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglProgressBar, [{
        type: Component,
        args: [{
                selector: 'ngl-progress-bar',
                template: "<span class=\"slds-progress-bar__value\" [style.width.%]=\"value\"><span class=\"slds-assistive-text\">Progress: {{value}}%</span></span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { value: [{
            type: Input
        }], size: [{
            type: Input
        }], variant: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglProgressBarModule, { declarations: function () { return [NglProgressBar]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglProgressBar]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: [NglProgressBar],
                exports: [NglProgressBar],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRadioGroup, [{
        type: Component,
        args: [{
                selector: 'ngl-radio-group,[ngl-radio-group]',
                template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-radio_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], label: [{
            type: Input
        }], error: [{
            type: Input
        }], required: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRadioInput, [{
        type: Directive,
        args: [{
                selector: 'input[ngl][type=radio]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { name: [{
            type: HostBinding,
            args: ['attr.name']
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRadioOption, [{
        type: Component,
        args: [{
                selector: 'ngl-radio-option',
                template: "\n<ng-content></ng-content>\n<label class=\"slds-radio__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-radio_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\" [nglInternalOutlet]=\"label\"></span></label>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NglRadioGroup }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isTypeList: [{
            type: HostBinding,
            args: ['class.slds-radio']
        }], isTypeButton: [{
            type: HostBinding,
            args: ['class.slds-button']
        }, {
            type: HostBinding,
            args: ['class.slds-radio_button']
        }], label: [{
            type: Input
        }], input: [{
            type: ContentChild,
            args: [NglRadioInput, { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglRadiosModule, { declarations: function () { return [NglRadioGroup,
        NglRadioOption,
        NglRadioInput]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule]; }, exports: function () { return [NglRadioGroup,
        NglRadioOption,
        NglRadioInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRadiosModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$9,
                exports: DIRECTIVES$9,
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRatingIconTemplate, [{
        type: Directive,
        args: [{ selector: '[nglRatingIcon]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRating, [{
        type: Component,
        args: [{
                selector: 'ngl-rating',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<ng-template #t let-fill=\"fill\">\n  <svg class=\"slds-icon\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"fill === 100 ? colorOn : colorOff\"></svg>\n  <svg class=\"slds-icon\" *ngIf=\"fill &gt; 0 &amp;&amp; fill &lt; 100\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"colorOn\" style=\"position:absolute; bottom:0;\" [style.left.%]=\"fill - 100\" [xPos]=\"(100 - fill) + '%'\"></svg>\n</ng-template>\n<div class=\"slds-show_inline-block\" *ngFor=\"let r of range; let i = index\" (click)=\"update(r)\" (mouseenter)=\"enter(r)\" style=\"position: relative;\">\n  <ng-template [ngTemplateOutlet]=\"_template\" [ngTemplateOutletContext]=\"{$implicit: r &lt;= currentRate, index: i, fill: getFill(r)}\"></ng-template>\n</div>",
                host: {
                    'style': 'white-space: nowrap;',
                    'tabindex': '0',
                    'aria-valuemin': '0',
                    '[attr.aria-valuemax]': 'max'
                }
            }]
    }], function () { return [{ type: NglRatingConfig, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGL_RATING_CONFIG]
            }] }]; }, { icon: [{
            type: Input
        }], readonly: [{
            type: Input,
            args: ['isReadonly']
        }], rateChange: [{
            type: Output
        }], hover: [{
            type: Output
        }], colorOn: [{
            type: Input
        }], colorOff: [{
            type: Input
        }], rate: [{
            type: Input
        }], max: [{
            type: Input
        }], reset: [{
            type: HostListener,
            args: ['mouseleave']
        }], keyboardIncrease: [{
            type: HostListener,
            args: ['keydown.ArrowUp', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowRight', ['$event']]
        }], keyboardDecrease: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowLeft', ['$event']]
        }], ariaValuenow: [{
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }], size: [{
            type: Input
        }], defaultTemplate: [{
            type: ViewChild,
            args: ['t', { static: true }]
        }], iconTemplate: [{
            type: ContentChild,
            args: [NglRatingIconTemplate]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglRatingsModule, { declarations: function () { return [NglRating,
        NglRatingIconTemplate]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglRating,
        NglRatingIconTemplate]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglRatingsModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NglIconsModule],
                declarations: [...DIRECTIVES$a],
                exports: [...DIRECTIVES$a]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglExpandableSection, [{
        type: Component,
        args: [{
                selector: 'ngl-expandable-section',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "\n<h3 class=\"slds-section__title\" [class.slds-theme_shade]=\"!collapsable\">\n  <button class=\"slds-button slds-section__title-action\" *ngIf=\"collapsable; else simple_title\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"expanded\" type=\"button\" (click)=\"toggle($event)\">\n    <svg class=\"slds-section__title-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"switch\"></svg><span class=\"slds-truncate\" [title]=\"title\">{{title}}</span>\n  </button>\n  <ng-template #simple_title><span class=\"slds-truncate slds-p-horizontal_small\" [title]=\"title\">{{title}}</span>\n  </ng-template>\n</h3>\n<div class=\"slds-section__content\" [attr.aria-hidden]=\"!expanded\" [attr.id]=\"uid\">\n  <ng-content></ng-content>\n</div>",
                host: {
                    '[class.slds-section]': 'true'
                }
            }]
    }], function () { return []; }, { collapsable: [{
            type: Input
        }], open: [{
            type: Input
        }], openChange: [{
            type: Output
        }], expanded: [{
            type: HostBinding,
            args: ['class.slds-is-open']
        }], title: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSectionsModule, { declarations: function () { return [NglExpandableSection]; }, imports: function () { return [CommonModule,
        NglIconsModule]; }, exports: function () { return [NglExpandableSection]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSectionsModule, [{
        type: NgModule,
        args: [{
                declarations: [NglExpandableSection],
                exports: [NglExpandableSection],
                imports: [CommonModule, NglIconsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSelectInput, [{
        type: Directive,
        args: [{
                selector: 'select[ngl]',
                host: {
                    '[class.slds-select]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSelect, [{
        type: Component,
        args: [{
                selector: 'ngl-select,[ngl-select]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-select_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglSelectInput, { static: true }]
        }], label: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSelectModule, { declarations: function () { return [NglSelect,
        NglSelectInput]; }, imports: function () { return [CommonModule,
        NglFormsModule,
        NglInternalOutletModule]; }, exports: function () { return [NglSelect,
        NglSelectInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSelectModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$b,
                exports: DIRECTIVES$b,
                imports: [CommonModule, NglFormsModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSlider, [{
        type: Component,
        args: [{
                selector: 'ngl-slider',
                template: "\n<label class=\"slds-form-element__label\" [attr.for]=\"uid\"><span class=\"slds-slider-label\"><span class=\"slds-slider-label__label\" *ngIf=\"label\" [nglInternalOutlet]=\"label\"></span><span class=\"slds-slider-label__range\">{{min}} - {{max}}</span></span></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-slider\" [ngClass]=\"sliderClass()\">\n    <input class=\"slds-slider__range\" [id]=\"uid\" type=\"range\" [value]=\"value\" [min]=\"min\" [max]=\"max\" [step]=\"step\" [disabled]=\"disabled\" [attr.aria-describedby]=\"hasError ? uid + '-error' : null\" (input)=\"onInput($event.target.value)\"><span class=\"slds-slider__value\" aria-hidden=\"true\">{{value}}</span>\n  </div>\n  <div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NGL_SLIDER_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], vertical: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], label: [{
            type: Input
        }], size: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSliderModule, { declarations: function () { return [NglSlider]; }, imports: function () { return [CommonModule,
        NglInternalOutletModule]; }, exports: function () { return [NglSlider]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [NglSlider],
                exports: [NglSlider],
                imports: [CommonModule, NglInternalOutletModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSpinner, [{
        type: Component,
        args: [{
                selector: 'ngl-spinner',
                template: "<span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{ alternativeText }}</span>\n<div class=\"slds-spinner__dot-a\"></div>\n<div class=\"slds-spinner__dot-b\"></div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [HostService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HostService }]; }, { size: [{
            type: Input
        }], variant: [{
            type: Input
        }], alternativeText: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglSpinnersModule, { declarations: function () { return [NglSpinner]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NglSpinner]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglSpinnersModule, [{
        type: NgModule,
        args: [{
                declarations: [NglSpinner],
                exports: [NglSpinner],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTextareaInput, [{
        type: Directive,
        args: [{
                selector: 'textarea[ngl]',
                host: {
                    '[class.slds-textarea]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { required: [{
            type: Input
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTextarea, [{
        type: Component,
        args: [{
                selector: 'ngl-textarea,[ngl-textarea]',
                template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-textarea_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.slds-form-element]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hasError: [{
            type: HostBinding,
            args: ['class.slds-has-error']
        }], input: [{
            type: ContentChild,
            args: [NglTextareaInput, { static: true }]
        }], label: [{
            type: Input
        }], fieldLevelHelpTooltip: [{
            type: Input
        }], error: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglTextareaModule, { declarations: function () { return [NglTextarea,
        NglTextareaInput]; }, imports: function () { return [CommonModule,
        NglFormsModule]; }, exports: function () { return [NglTextarea,
        NglTextareaInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglTextareaModule, [{
        type: NgModule,
        args: [{
                declarations: DIRECTIVES$c,
                exports: DIRECTIVES$c,
                imports: [CommonModule, NglFormsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NglModule, { exports: [NglAccordionModule,
        NglAlertModule,
        NglAvatarModule,
        NglBadgesModule,
        NglBreadcrumbsModule,
        NglButtonIconsModule,
        NglButtonsModule,
        NglCarouselModule,
        NglCheckboxesModule,
        NglColorpickerModule,
        NglComboboxesModule,
        NglDatatablesModule,
        NglDatepickersModule,
        NglDynamicIconsModule,
        NglFilesModule,
        NglFileUploadModule,
        NglIconsModule,
        NglInputModule,
        NglMenusModule,
        NglModalsModule,
        NglToastModule,
        NglPaginationsModule,
        NglPickModule,
        NglPillsModule,
        NglPopoversModule,
        NglProgressBarModule,
        NglRadiosModule,
        NglRatingsModule,
        NglSectionsModule,
        NglSelectModule,
        NglSliderModule,
        NglSpinnersModule,
        NglTabsModule,
        NglTextareaModule,
        NglTooltipsModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NglModule, [{
        type: NgModule,
        args: [{
                exports: MODULES
            }]
    }], null, null); })();

/*
 * Public API Surface of ng-lightning
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NGL_COLORPICKER_CONFIG, NGL_DATEPICKER_CONFIG, NGL_ICON_CONFIG, NGL_RATING_CONFIG, NGL_TOOLTIP_CONFIG, NglAccordion, NglAccordionModule, NglAccordionSection, NglAlert, NglAlertClose, NglAlertModule, NglAvatar, NglAvatarModule, NglBadge, NglBadgesModule, NglBreadcrumb, NglBreadcrumbs, NglBreadcrumbsModule, NglButton, NglButtonIcon, NglButtonIconStateful, NglButtonIconsModule, NglButtonStateHover, NglButtonStateOff, NglButtonStateOn, NglButtonStateful, NglButtonsModule, NglCarousel, NglCarouselImage, NglCarouselModule, NglCheckbox, NglCheckboxButton, NglCheckboxGroup, NglCheckboxInput, NglCheckboxOption, NglCheckboxToggle, NglCheckboxesModule, NglColorpicker, NglColorpickerConfig, NglColorpickerModule, NglCombobox, NglComboboxInput, NglComboboxOption, NglComboboxesModule, NglDatatable, NglDatatableCell, NglDatatableColumn, NglDatatableHeadingTemplate, NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay, NglDatatablesModule, NglDatepicker, NglDatepickerConfig, NglDatepickerInput, NglDatepickersModule, NglDropdown, NglDropdownItem, NglDropdownTrigger, NglDynamicIcon, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle, NglDynamicIconsModule, NglExpandableSection, NglFile, NglFileCrop, NglFileUpload, NglFileUploadModule, NglFilesModule, NglIcon, NglIconConfig, NglIconSvg, NglIconsModule, NglInput, NglInputElement, NglInputModule, NglMenusModule, NglModal, NglModalFooterTemplate, NglModalHeaderTemplate, NglModalTaglineTemplate, NglModalsModule, NglModule, NglPagination, NglPaginationsModule, NglPick, NglPickModule, NglPickOption, NglPill, NglPillLink, NglPillsModule, NglPopover, NglPopoverTrigger, NglPopoversModule, NglProgressBar, NglProgressBarModule, NglRadioGroup, NglRadioInput, NglRadioOption, NglRadiosModule, NglRating, NglRatingConfig, NglRatingIconTemplate, NglRatingsModule, NglSectionsModule, NglSelect, NglSelectInput, NglSelectModule, NglSlider, NglSliderModule, NglSpinner, NglSpinnersModule, NglTab, NglTabContent, NglTabLabel, NglTabVerbose, NglTabs, NglTabsModule, NglTextarea, NglTextareaInput, NglTextareaModule, NglToast, NglToastClose, NglToastModule, NglTooltipConfig, NglTooltipTrigger, NglTooltipsModule, InputBoolean as ɵa, InputNumber as ɵb, NglDatepickerMonth as ɵba, NglDay as ɵbb, NglDateAdapter as ɵbc, NglDateAdapterBase as ɵbd, NglDatepickerWeekdays as ɵbe, NglDatepickerYear as ɵbf, NglClickOutsideModule as ɵbg, NglClickOutsideDirective as ɵbh, BaseDynamicIconComponent as ɵbi, NglAccordionItem as ɵc, HostService as ɵd, NglInternalOutletModule as ɵe, NglInternalOutlet as ɵf, NglCommonNotify as ɵg, NglCommonNotifyClose as ɵh, NglCarouselIndicator as ɵi, NglColorpickerSwatch as ɵj, NglColorpickerCustom as ɵk, NglColorpickerRange as ɵl, NglColorpickerInputs as ɵm, NglColorpickerSwatches as ɵn, NglColorpickerSwatchTrigger as ɵo, OnChange as ɵp, hasObservers as ɵq, NglFormsModule as ɵr, NglFormLabel as ɵs, NglFormHelp as ɵt, NglTooltip as ɵu, NglComboboxService as ɵv, NglOverlayModule as ɵw, NglOverlaynglOverlayScrolledOutsideViewDirective as ɵx, NglInternalDatatableHeadCell as ɵy, NglInternalDatatableCell as ɵz };

//# sourceMappingURL=ng-lightning.js.map