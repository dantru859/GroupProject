import { __decorate, __metadata } from "tslib";
import { Component, Input, ElementRef, Renderer2, ChangeDetectionStrategy, OnInit, OnChanges, Output, EventEmitter, HostListener, HostBinding } from '@angular/core';
import { HostService } from '../common/host/host.service';
import { InputBoolean } from '../util/convert';
var DEFAULT_VARIANT = 'border';
var NglButtonIconStateful = /** @class */ (function () {
    function NglButtonIconStateful(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * Specifies whether button is in selected state or not.
         */
        this.selected = false;
        this.selectedChange = new EventEmitter();
        /**
         * The variant changes the appearance of the button.
         */
        this.variant = DEFAULT_VARIANT;
        /**
         *  The size of the button.
         */
        this.size = null;
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    Object.defineProperty(NglButtonIconStateful.prototype, "altText", {
        get: function () {
            return this.alternativeText || this.title;
        },
        enumerable: true,
        configurable: true
    });
    NglButtonIconStateful.prototype.onclick = function () {
        this.selectedChange.emit(!this.selected);
    };
    NglButtonIconStateful.prototype.ngOnInit = function () {
        this.setHostClass();
    };
    NglButtonIconStateful.prototype.ngOnChanges = function () {
        this.setHostClass();
    };
    NglButtonIconStateful.prototype.setHostClass = function () {
        var _a;
        this.hostService.updateClass(this.el, (_a = {},
            _a["slds-button_icon-" + (this.variant || DEFAULT_VARIANT)] = true,
            _a["slds-button_icon-" + this.size] = !!this.size,
            _a));
    };
    NglButtonIconStateful.ctorParameters = function () { return [
        { type: ElementRef },
        { type: HostService },
        { type: Renderer2 }
    ]; };
    __decorate([
        HostBinding('class.slds-is-selected'),
        HostBinding('attr.aria-pressed'),
        Input(), InputBoolean(),
        __metadata("design:type", Object)
    ], NglButtonIconStateful.prototype, "selected", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglButtonIconStateful.prototype, "selectedChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglButtonIconStateful.prototype, "iconName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglButtonIconStateful.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglButtonIconStateful.prototype, "alternativeText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglButtonIconStateful.prototype, "variant", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglButtonIconStateful.prototype, "size", void 0);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], NglButtonIconStateful.prototype, "onclick", null);
    NglButtonIconStateful = __decorate([
        Component({
            // tslint:disable-next-line:component-selector
            selector: '[nglButtonIconStateful]',
            template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [HostService]
        }),
        __metadata("design:paramtypes", [ElementRef, HostService, Renderer2])
    ], NglButtonIconStateful);
    return NglButtonIconStateful;
}());
export { NglButtonIconStateful };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9uLWljb24tc3RhdGVmdWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1saWdodG5pbmcvIiwic291cmNlcyI6WyJsaWIvYnV0dG9uLWljb25zL2J1dHRvbi1pY29uLXN0YXRlZnVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQ25GLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRS9DLElBQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQztBQVNqQztJQTJDRSwrQkFBb0IsRUFBYyxFQUFVLFdBQXdCLEVBQUUsUUFBbUI7UUFBckUsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUFVLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBekNwRTs7V0FFRztRQUdzQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWhDLG1CQUFjLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQW9CdkQ7O1dBRUc7UUFDTSxZQUFPLEdBQWtELGVBQWUsQ0FBQztRQUVsRjs7V0FFRztRQUNNLFNBQUksR0FBNEMsSUFBSSxDQUFDO1FBTzVELFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDeEQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFQRCxzQkFBSSwwQ0FBTzthQUFYO1lBQ0UsT0FBTyxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDNUMsQ0FBQzs7O09BQUE7SUFRRCx1Q0FBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELHdDQUFRLEdBQVI7UUFDRSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVELDJDQUFXLEdBQVg7UUFDRSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVPLDRDQUFZLEdBQXBCOztRQUNFLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2xDLEdBQUMsdUJBQW9CLElBQUksQ0FBQyxPQUFPLElBQUksZUFBZSxDQUFFLElBQUcsSUFBSTtZQUM3RCxHQUFDLHNCQUFvQixJQUFJLENBQUMsSUFBTSxJQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSTtnQkFDOUMsQ0FBQztJQUNMLENBQUM7O2dCQXZCdUIsVUFBVTtnQkFBdUIsV0FBVztnQkFBWSxTQUFTOztJQXBDaEU7UUFGeEIsV0FBVyxDQUFDLHdCQUF3QixDQUFDO1FBQ3JDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQztRQUNoQyxLQUFLLEVBQUUsRUFBRSxZQUFZLEVBQUU7OzJEQUFrQjtJQUVoQztRQUFULE1BQU0sRUFBRTs7aUVBQThDO0lBTzlDO1FBQVIsS0FBSyxFQUFFOzsyREFBa0I7SUFLakI7UUFBUixLQUFLLEVBQUU7O3dEQUFlO0lBTWQ7UUFBUixLQUFLLEVBQUU7O2tFQUFpQjtJQUtoQjtRQUFSLEtBQUssRUFBRTs7MERBQTBFO0lBS3pFO1FBQVIsS0FBSyxFQUFFOzt1REFBc0Q7SUFZOUQ7UUFEQyxZQUFZLENBQUMsT0FBTyxDQUFDOzs7O3dEQUdyQjtJQW5EVSxxQkFBcUI7UUFQakMsU0FBUyxDQUFDO1lBQ1QsOENBQThDO1lBQzlDLFFBQVEsRUFBRSx5QkFBeUI7WUFDbkMsNk1BQTBDO1lBQzFDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1lBQy9DLFNBQVMsRUFBRSxDQUFDLFdBQVcsQ0FBQztTQUN6QixDQUFDO3lDQTRDd0IsVUFBVSxFQUF1QixXQUFXLEVBQVksU0FBUztPQTNDOUUscUJBQXFCLENBbUVqQztJQUFELDRCQUFDO0NBQUEsQUFuRUQsSUFtRUM7U0FuRVkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgT25Jbml0LCBPbkNoYW5nZXMsXG4gICAgICAgICBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSG9zdFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaG9zdC9ob3N0LnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5wdXRCb29sZWFuIH0gZnJvbSAnLi4vdXRpbC9jb252ZXJ0JztcblxuY29uc3QgREVGQVVMVF9WQVJJQU5UID0gJ2JvcmRlcic7XG5cbkBDb21wb25lbnQoe1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnW25nbEJ1dHRvbkljb25TdGF0ZWZ1bF0nLFxuICB0ZW1wbGF0ZVVybDogJy4vYnV0dG9uLWljb24tc3RhdGVmdWwuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtIb3N0U2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIE5nbEJ1dHRvbkljb25TdGF0ZWZ1bCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoZXRoZXIgYnV0dG9uIGlzIGluIHNlbGVjdGVkIHN0YXRlIG9yIG5vdC5cbiAgICovXG4gIEBIb3N0QmluZGluZygnY2xhc3Muc2xkcy1pcy1zZWxlY3RlZCcpXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXByZXNzZWQnKVxuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqXG4gICAqIExEUyBuYW1lIG9mIHRoZSBpY29uLlxuICAgKiBOYW1lcyBhcmUgd3JpdHRlbiBpbiB0aGUgZm9ybWF0ICd1dGlsaXR5OmRvd24nIHdoZXJlICd1dGlsaXR5JyBpcyB0aGUgY2F0ZWdvcnksIGFuZCAnZG93bicgaXMgdGhlIHNwZWNpZmljIGljb24gdG8gYmUgZGlzcGxheWVkLlxuICAgKiBPbmx5IHV0aWxpdHkgaWNvbnMgY2FuIGJlIHVzZWQgaW4gdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBASW5wdXQoKSBpY29uTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGYWxsYmFjayB2YWx1ZSBmb3IgYGFsdGVybmF0aXZlVGV4dGAuXG4gICAqL1xuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYWx0ZXJuYXRpdmUgdGV4dCB1c2VkIHRvIGRlc2NyaWJlIHRoZSBpY29uLlxuICAgKiBUaGlzIHRleHQgc2hvdWxkIGRlc2NyaWJlIHdoYXQgaGFwcGVucywgbm90IHdoYXQgdGhlIGljb24gbG9va3MgbGlrZS5cbiAgICovXG4gIEBJbnB1dCgpIGFsdGVybmF0aXZlVGV4dDtcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgY2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlxuICAgKi9cbiAgQElucHV0KCkgdmFyaWFudDogJ2JvcmRlcicgfCAnYm9yZGVyLWZpbGxlZCcgfCAnYm9yZGVyLWludmVyc2UnID0gREVGQVVMVF9WQVJJQU5UO1xuXG4gIC8qKlxuICAgKiAgVGhlIHNpemUgb2YgdGhlIGJ1dHRvbi5cbiAgICovXG4gIEBJbnB1dCgpIHNpemU6ICd4eC1zbWFsbCcgfCAneC1zbWFsbCcgfCAnc21hbGwnIHwgbnVsbCA9IG51bGw7XG5cbiAgZ2V0IGFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmVUZXh0IHx8IHRoaXMudGl0bGU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIGhvc3RTZXJ2aWNlOiBIb3N0U2VydmljZSwgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIHJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3NsZHMtYnV0dG9uJyk7XG4gICAgcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnc2xkcy1idXR0b25faWNvbicpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICBvbmNsaWNrKCkge1xuICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCghdGhpcy5zZWxlY3RlZCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnNldEhvc3RDbGFzcygpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy5zZXRIb3N0Q2xhc3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0SG9zdENsYXNzKCkge1xuICAgIHRoaXMuaG9zdFNlcnZpY2UudXBkYXRlQ2xhc3ModGhpcy5lbCwge1xuICAgICAgW2BzbGRzLWJ1dHRvbl9pY29uLSR7dGhpcy52YXJpYW50IHx8IERFRkFVTFRfVkFSSUFOVH1gXTogdHJ1ZSxcbiAgICAgIFtgc2xkcy1idXR0b25faWNvbi0ke3RoaXMuc2l6ZX1gXTogISF0aGlzLnNpemUsXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==