var _a;
import { __assign, __decorate, __metadata, __param, __read } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy, ElementRef, OnInit, OnChanges, AfterViewInit, Optional, Inject, ViewChild, SimpleChanges, LOCALE_ID } from '@angular/core';
import { ENTER, UP_ARROW, LEFT_ARROW, DOWN_ARROW, RIGHT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END } from '@angular/cdk/keycodes';
import { uniqueId, trapEvent } from '../util/util';
import { InputBoolean, InputNumber } from '../util/convert';
import { NglDatepickerInput } from './input/datepicker-input';
import { NGL_DATEPICKER_CONFIG, NglDatepickerConfig } from './config';
import { numberOfDaysInMonth, getToday, isDisabled, compareDate, isSameMonth, parseDate } from './util';
import { NglDatepickerMonth } from './month';
var KEYBOARD_MOVES = (_a = {},
    _a[UP_ARROW] = ['Move', -7],
    _a[LEFT_ARROW] = ['Move', -1],
    _a[DOWN_ARROW] = ['Move', 7],
    _a[RIGHT_ARROW] = ['Move', 1],
    _a[PAGE_UP] = ['MoveMonth', -1],
    _a[PAGE_DOWN] = ['MoveMonth', 1],
    _a[HOME] = ['MoveTo', 1],
    _a[END] = ['MoveTo', 31],
    _a);
var NglDatepicker = /** @class */ (function () {
    function NglDatepicker(dtInput, defaultConfig, locale, element) {
        this.dtInput = dtInput;
        this.element = element;
        this.dateDisabled = null;
        this.dateChange = new EventEmitter();
        this.uid = uniqueId('datepicker');
        var config = __assign(__assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.monthNames = config.monthNames;
        this.dayNamesShort = config.dayNamesShort;
        this.dayNamesLong = config.dayNamesLong;
        this.firstDayOfWeek = config.firstDayOfWeek;
        this.showToday = config.showToday;
        this.relativeYearFrom = config.relativeYearFrom;
        this.relativeYearTo = config.relativeYearTo;
        this.todayLabel = config.todayLabel;
        this.previousMonthLabel = config.previousMonthLabel;
        this.nextMonthLabel = config.nextMonthLabel;
    }
    Object.defineProperty(NglDatepicker.prototype, "date", {
        set: function (date) {
            this._date = parseDate(date);
        },
        enumerable: true,
        configurable: true
    });
    NglDatepicker.prototype.ngOnInit = function () {
        this.setMinMaxDates();
        this.setCurrent(this._date || getToday());
    };
    NglDatepicker.prototype.ngOnChanges = function (changes) {
        if ((changes.date && changes.date.isFirstChange()) ||
            changes.relativeYearFrom || changes.relativeYearTo ||
            changes.min || changes.max) {
            this.setMinMaxDates();
        }
        if (changes.date) {
            this.setCurrent(this._date);
        }
    };
    NglDatepicker.prototype.moveYear = function (year) {
        this.setCurrent({ year: +year });
    };
    NglDatepicker.prototype.moveMonth = function (diff) {
        this.moveCalendar('MoveMonth', diff);
    };
    NglDatepicker.prototype.keyboardHandler = function (evt) {
        var keyCode = evt.keyCode;
        if (keyCode === ENTER) {
            trapEvent(evt);
            if (!this.isDisabledDate(this.current)) {
                this.select(this.current);
            }
            return;
        }
        var move = KEYBOARD_MOVES[keyCode];
        if (!move) {
            return;
        }
        // Handle keyboard event inside datepicker
        trapEvent(evt);
        var _a = __read(move, 2), code = _a[0], param = _a[1];
        this.moveCalendar(code, param);
        this.focusActiveDay();
    };
    NglDatepicker.prototype.select = function (date) {
        if (date.disabled) {
            return;
        }
        var year = date.year, month = date.month, day = date.day;
        this.dateChange.emit(new Date(year, month, day));
    };
    NglDatepicker.prototype.selectToday = function () {
        var today = getToday();
        if (this.isDisabledDate(today)) {
            this.setCurrent(today);
        }
        else {
            this.dateChange.emit(new Date());
        }
    };
    NglDatepicker.prototype.ngAfterViewInit = function () {
        if (this.dtInput) {
            var el = this.element.nativeElement;
            this.dtInput.updateDatepickerSize(el.offsetWidth, el.offsetHeight);
            this.focusActiveDay();
        }
    };
    /** Whether the previous period button is disabled. */
    NglDatepicker.prototype.previousDisabled = function () {
        return this.minDate && isSameMonth(this.current, this.minDate);
    };
    /** Whether the next period button is disabled. */
    NglDatepicker.prototype.nextDisabled = function () {
        return this.maxDate && isSameMonth(this.current, this.maxDate);
    };
    NglDatepicker.prototype.focusActiveDay = function () {
        this.monthView.focusActiveDay();
    };
    NglDatepicker.prototype.moveCalendar = function (code, param) {
        var _a = this.current, year = _a.year, month = _a.month, day = _a.day;
        var date = new Date(year, month, day, 12);
        if (code === 'Move') {
            date.setDate(day + (+param));
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day: date.getDate() });
        }
        else if (code === 'MoveMonth') {
            date.setMonth(month + (+param), 1);
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day: day });
        }
        else if (code === 'MoveTo') {
            this.setCurrent({ day: +param });
        }
    };
    NglDatepicker.prototype.setCurrent = function (d, doRender) {
        if (doRender === void 0) { doRender = true; }
        this.current = __assign(__assign({}, this.current), d);
        // Keep current inside minimum/maximum range
        if (compareDate(this.current, this.minDate) < 0) {
            this.current = this.minDate;
        }
        else if (compareDate(this.current, this.maxDate) > 0) {
            this.current = this.maxDate;
        }
        if (doRender) {
            this.render();
        }
    };
    NglDatepicker.prototype.render = function () {
        var _a = this.current, year = _a.year, month = _a.month, day = _a.day;
        this.monthLabel = this.monthNames[month];
        // Keep current day inside limits of this month
        this.setCurrent({ day: Math.min(day, numberOfDaysInMonth(year, month)) }, false);
    };
    /** Date filter for the month */
    NglDatepicker.prototype.isDisabledDate = function (date) {
        return isDisabled(date, this.dateDisabled, this.minDate, this.maxDate);
    };
    NglDatepicker.prototype.setMinMaxDates = function () {
        var year = getToday().year;
        this.minDate = this.min ? parseDate(this.min) : { year: year + this.relativeYearFrom, month: 0, day: 1 };
        this.maxDate = this.max ? parseDate(this.max) : { year: year + this.relativeYearTo, month: 11, day: 31 };
    };
    NglDatepicker.ctorParameters = function () { return [
        { type: NglDatepickerInput, decorators: [{ type: Optional }, { type: Inject, args: [NglDatepickerInput,] }] },
        { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
        { type: ElementRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NglDatepicker.prototype, "monthNames", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NglDatepicker.prototype, "dayNamesShort", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NglDatepicker.prototype, "dayNamesLong", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], NglDatepicker.prototype, "dateDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Date),
        __metadata("design:paramtypes", [Date])
    ], NglDatepicker.prototype, "date", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglDatepicker.prototype, "dateChange", void 0);
    __decorate([
        Input(), InputBoolean(),
        __metadata("design:type", Boolean)
    ], NglDatepicker.prototype, "showToday", void 0);
    __decorate([
        Input(), InputNumber(),
        __metadata("design:type", Number)
    ], NglDatepicker.prototype, "firstDayOfWeek", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NglDatepicker.prototype, "relativeYearFrom", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NglDatepicker.prototype, "relativeYearTo", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Date)
    ], NglDatepicker.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Date)
    ], NglDatepicker.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglDatepicker.prototype, "todayLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglDatepicker.prototype, "previousMonthLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglDatepicker.prototype, "nextMonthLabel", void 0);
    __decorate([
        ViewChild(NglDatepickerMonth),
        __metadata("design:type", NglDatepickerMonth)
    ], NglDatepicker.prototype, "monthView", void 0);
    NglDatepicker = __decorate([
        Component({
            selector: 'ngl-datepicker',
            template: "\n<div class=\"slds-datepicker__filter slds-grid\">\n  <div class=\"slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\">\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(-1)\" [disabled]=\"previousDisabled()\" [title]=\"previousMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"left\"></svg><span class=\"slds-assistive-text\">{{ previousMonthLabel }}</span>\n      </button>\n    </div>\n    <h2 class=\"slds-align-middle\" [id]=\"uid + '_month'\" aria-live=\"assertive\" aria-atomic=\"true\">{{ monthLabel }}</h2>\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(1)\" [disabled]=\"nextDisabled()\" [title]=\"nextMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"right\"></svg><span class=\"slds-assistive-text\">{{ nextMonthLabel }}</span>\n      </button>\n    </div>\n  </div>\n  <ngl-date-year class=\"slds-shrink-none\" [year]=\"current.year\" [from]=\"minDate\" [to]=\"maxDate\" (yearChange)=\"moveYear($event)\"></ngl-date-year>\n</div>\n<table class=\"datepicker__month\" role=\"grid\" [attr.aria-labelledby]=\"uid + '_month'\" (keydown)=\"keyboardHandler($event)\">\n  <thead>\n    <tr nglWeekdays [firstDayOfWeek]=\"firstDayOfWeek\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\"></tr>\n  </thead>\n  <tbody *ngIf=\"current\" nglDatepickerMonth [year]=\"current.year\" [month]=\"current.month\" [day]=\"current.day\" [selected]=\"_date\" [firstDayOfWeek]=\"firstDayOfWeek\" [minDate]=\"minDate\" [maxDate]=\"maxDate\" [dateDisabled]=\"dateDisabled\" (selectDate)=\"select($event)\"></tbody>\n</table>\n<button class=\"slds-button slds-align_absolute-center slds-text-link\" *ngIf=\"showToday\" (click)=\"selectToday()\">{{ todayLabel }}</button>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            host: {
                '[class.slds-datepicker]': 'true',
            },
            styles: [":host { display: block; }"]
        }),
        __param(0, Optional()), __param(0, Inject(NglDatepickerInput)),
        __param(1, Optional()), __param(1, Inject(NGL_DATEPICKER_CONFIG)),
        __param(2, Inject(LOCALE_ID)),
        __metadata("design:paramtypes", [NglDatepickerInput,
            NglDatepickerConfig, String, ElementRef])
    ], NglDatepicker);
    return NglDatepicker;
}());
export { NglDatepicker };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi9kYXRlcGlja2Vycy9kYXRlcGlja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSx1QkFBdUIsRUFBRSxVQUFVLEVBQzNFLE1BQU0sRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEgsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUgsT0FBTyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDbkQsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDdEUsT0FBTyxFQUFtQixtQkFBbUIsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3pILE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUU3QyxJQUFNLGNBQWM7SUFDbEIsR0FBQyxRQUFRLElBQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDM0IsR0FBQyxVQUFVLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDM0Is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LFdBQUEsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUE7UUFDdEMsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUE7UUFDekMsV0FBQSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7eUNBRnVDLGtCQUFrQjtZQUNqQixtQkFBbUIsVUFFNUQsVUFBVTtPQWxFNUIsYUFBYSxDQXdOekI7SUFBRCxvQkFBQztDQUFBLEFBeE5ELElBd05DO1NBeE5ZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIEVsZW1lbnRSZWYsXG4gICAgICAgICBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT3B0aW9uYWwsIEluamVjdCwgVmlld0NoaWxkLCBTaW1wbGVDaGFuZ2VzLCBMT0NBTEVfSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVOVEVSLCBVUF9BUlJPVywgTEVGVF9BUlJPVywgRE9XTl9BUlJPVywgUklHSFRfQVJST1csIFBBR0VfVVAsIFBBR0VfRE9XTiwgSE9NRSwgRU5EIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IHVuaXF1ZUlkLCB0cmFwRXZlbnQgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgSW5wdXRCb29sZWFuLCBJbnB1dE51bWJlciB9IGZyb20gJy4uL3V0aWwvY29udmVydCc7XG5pbXBvcnQgeyBOZ2xEYXRlcGlja2VySW5wdXQgfSBmcm9tICcuL2lucHV0L2RhdGVwaWNrZXItaW5wdXQnO1xuaW1wb3J0IHsgTkdMX0RBVEVQSUNLRVJfQ09ORklHLCBOZ2xEYXRlcGlja2VyQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgTmdsSW50ZXJuYWxEYXRlLCBudW1iZXJPZkRheXNJbk1vbnRoLCBnZXRUb2RheSwgaXNEaXNhYmxlZCwgY29tcGFyZURhdGUsIGlzU2FtZU1vbnRoLCBwYXJzZURhdGUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgTmdsRGF0ZXBpY2tlck1vbnRoIH0gZnJvbSAnLi9tb250aCc7XG5cbmNvbnN0IEtFWUJPQVJEX01PVkVTID0ge1xuICBbVVBfQVJST1ddOiAgICBbJ01vdmUnLCAtN10sXG4gIFtMRUZUX0FSUk9XXTogIFsnTW92ZScsIC0xXSxcbiAgW0RPV05fQVJST1ddOiAgWydNb3ZlJywgN10sXG4gIFtSSUdIVF9BUlJPV106IFsnTW92ZScsIDFdLFxuICBbUEFHRV9VUF06ICAgICBbJ01vdmVNb250aCcsIC0xXSxcbiAgW1BBR0VfRE9XTl06ICAgWydNb3ZlTW9udGgnLCAxXSxcbiAgW0hPTUVdOiAgICAgICAgWydNb3ZlVG8nLCAxXSxcbiAgW0VORF06ICAgICAgICAgWydNb3ZlVG8nLCAzMV0sXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ2wtZGF0ZXBpY2tlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlcGlja2VyLmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3Muc2xkcy1kYXRlcGlja2VyXSc6ICd0cnVlJyxcbiAgfSxcbiAgc3R5bGVzOiBbYDpob3N0IHsgZGlzcGxheTogYmxvY2s7IH1gXSxcbn0pXG5leHBvcnQgY2xhc3MgTmdsRGF0ZXBpY2tlciBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KCkgcmVhZG9ubHkgbW9udGhOYW1lczogc3RyaW5nW107XG4gIEBJbnB1dCgpIHJlYWRvbmx5IGRheU5hbWVzU2hvcnQ6IHN0cmluZ1tdO1xuICBASW5wdXQoKSByZWFkb25seSBkYXlOYW1lc0xvbmc6IHN0cmluZ1tdO1xuICBASW5wdXQoKSBkYXRlRGlzYWJsZWQ6IChkYXRlOiBEYXRlKSA9PiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5cbiAgX2RhdGU6IE5nbEludGVybmFsRGF0ZTtcbiAgY3VycmVudDogTmdsSW50ZXJuYWxEYXRlO1xuICBASW5wdXQoKSBzZXQgZGF0ZShkYXRlOiBEYXRlKSB7XG4gICAgdGhpcy5fZGF0ZSA9IHBhcnNlRGF0ZShkYXRlKTtcbiAgfVxuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgcmVhZG9ubHkgc2hvd1RvZGF5OiBib29sZWFuO1xuXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIHJlYWRvbmx5IGZpcnN0RGF5T2ZXZWVrOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9mZnNldCBvZiB5ZWFyIGZyb20gY3VycmVudCB5ZWFyLCB0aGF0IGNhbiBiZSB0aGUgbWluaW11bSBvcHRpb24gaW4gdGhlIHllYXIgc2VsZWN0aW9uIGRyb3Bkb3duLlxuICAgKi9cbiAgQElucHV0KCkgcmVhZG9ubHkgcmVsYXRpdmVZZWFyRnJvbTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBPZmZzZXQgb2YgeWVhciBmcm9tIGN1cnJlbnQgeWVhciwgdGhhdCBjYW4gYmUgdGhlIG1heGltdW0gb3B0aW9uIGluIHRoZSB5ZWFyIHNlbGVjdGlvbiBkcm9wZG93bi5cbiAgICovXG4gIEBJbnB1dCgpIHJlYWRvbmx5IHJlbGF0aXZlWWVhclRvOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSBtaW46IERhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSBtYXg6IERhdGU7XG5cbiAgLyoqXG4gICAqIExhYmVsIG9mIHNob3J0Y3V0IHRvIHNlbGVjdCBjdXJyZW50IGRhdGUuXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSB0b2RheUxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExhYmVsIGZvciBidXR0b24gdG8gZ28gdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgQElucHV0KCkgcmVhZG9ubHkgcHJldmlvdXNNb250aExhYmVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExhYmVsIGZvciBidXR0b24gdG8gZ28gdG8gdGhlIG5leHQgbW9udGguXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSBuZXh0TW9udGhMYWJlbDogc3RyaW5nO1xuXG5cbiAgd2Vla3M6IE5nbEludGVybmFsRGF0ZVtdO1xuICB1aWQgPSB1bmlxdWVJZCgnZGF0ZXBpY2tlcicpO1xuICBtb250aExhYmVsOiBzdHJpbmc7XG5cbiAgbWluRGF0ZTogTmdsSW50ZXJuYWxEYXRlO1xuXG4gIG1heERhdGU6IE5nbEludGVybmFsRGF0ZTtcblxuICBAVmlld0NoaWxkKE5nbERhdGVwaWNrZXJNb250aCkgbW9udGhWaWV3OiBOZ2xEYXRlcGlja2VyTW9udGg7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChOZ2xEYXRlcGlja2VySW5wdXQpIHByaXZhdGUgZHRJbnB1dDogTmdsRGF0ZXBpY2tlcklucHV0LFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE5HTF9EQVRFUElDS0VSX0NPTkZJRykgZGVmYXVsdENvbmZpZzogTmdsRGF0ZXBpY2tlckNvbmZpZyxcbiAgICAgICAgICAgICAgQEluamVjdChMT0NBTEVfSUQpIGxvY2FsZTogc3RyaW5nLFxuICAgICAgICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4ubmV3IE5nbERhdGVwaWNrZXJDb25maWcobG9jYWxlKSwgLi4uZGVmYXVsdENvbmZpZyB9O1xuICAgIHRoaXMubW9udGhOYW1lcyA9IGNvbmZpZy5tb250aE5hbWVzO1xuICAgIHRoaXMuZGF5TmFtZXNTaG9ydCA9IGNvbmZpZy5kYXlOYW1lc1Nob3J0O1xuICAgIHRoaXMuZGF5TmFtZXNMb25nID0gY29uZmlnLmRheU5hbWVzTG9uZztcbiAgICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gY29uZmlnLmZpcnN0RGF5T2ZXZWVrO1xuICAgIHRoaXMuc2hvd1RvZGF5ID0gY29uZmlnLnNob3dUb2RheTtcbiAgICB0aGlzLnJlbGF0aXZlWWVhckZyb20gPSBjb25maWcucmVsYXRpdmVZZWFyRnJvbTtcbiAgICB0aGlzLnJlbGF0aXZlWWVhclRvID0gY29uZmlnLnJlbGF0aXZlWWVhclRvO1xuICAgIHRoaXMudG9kYXlMYWJlbCA9IGNvbmZpZy50b2RheUxhYmVsO1xuICAgIHRoaXMucHJldmlvdXNNb250aExhYmVsID0gY29uZmlnLnByZXZpb3VzTW9udGhMYWJlbDtcbiAgICB0aGlzLm5leHRNb250aExhYmVsID0gY29uZmlnLm5leHRNb250aExhYmVsO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zZXRNaW5NYXhEYXRlcygpO1xuICAgIHRoaXMuc2V0Q3VycmVudCh0aGlzLl9kYXRlIHx8IGdldFRvZGF5KCkpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmICgoY2hhbmdlcy5kYXRlICYmIGNoYW5nZXMuZGF0ZS5pc0ZpcnN0Q2hhbmdlKCkpIHx8XG4gICAgICAgIGNoYW5nZXMucmVsYXRpdmVZZWFyRnJvbSB8fCBjaGFuZ2VzLnJlbGF0aXZlWWVhclRvIHx8XG4gICAgICAgIGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4KSB7XG4gICAgICB0aGlzLnNldE1pbk1heERhdGVzKCk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VzLmRhdGUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudCh0aGlzLl9kYXRlKTtcbiAgICB9XG4gIH1cblxuICBtb3ZlWWVhcih5ZWFyOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICB0aGlzLnNldEN1cnJlbnQoeyB5ZWFyOiAreWVhciB9KTtcbiAgfVxuXG4gIG1vdmVNb250aChkaWZmOiBudW1iZXIpIHtcbiAgICB0aGlzLm1vdmVDYWxlbmRhcignTW92ZU1vbnRoJywgZGlmZik7XG4gIH1cblxuICBrZXlib2FyZEhhbmRsZXIoZXZ0OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2dC5rZXlDb2RlO1xuXG4gICAgaWYgKGtleUNvZGUgPT09IEVOVEVSKSB7XG4gICAgICB0cmFwRXZlbnQoZXZ0KTtcbiAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkRGF0ZSh0aGlzLmN1cnJlbnQpKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbW92ZSA9IEtFWUJPQVJEX01PVkVTW2tleUNvZGVdO1xuICAgIGlmICghbW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXlib2FyZCBldmVudCBpbnNpZGUgZGF0ZXBpY2tlclxuICAgIHRyYXBFdmVudChldnQpO1xuXG4gICAgY29uc3QgW2NvZGUsIHBhcmFtXSA9IG1vdmU7XG4gICAgdGhpcy5tb3ZlQ2FsZW5kYXIoY29kZSwgcGFyYW0pO1xuICAgIHRoaXMuZm9jdXNBY3RpdmVEYXkoKTtcbiAgfVxuXG4gIHNlbGVjdChkYXRlOiBOZ2xJbnRlcm5hbERhdGUpIHtcbiAgICBpZiAoZGF0ZS5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IHt5ZWFyLCBtb250aCwgZGF5fSA9IGRhdGU7XG4gICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgc2VsZWN0VG9kYXkoKSB7XG4gICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheSgpO1xuICAgIGlmICh0aGlzLmlzRGlzYWJsZWREYXRlKHRvZGF5KSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50KHRvZGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IERhdGUoKSk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmICh0aGlzLmR0SW5wdXQpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICB0aGlzLmR0SW5wdXQudXBkYXRlRGF0ZXBpY2tlclNpemUoZWwub2Zmc2V0V2lkdGgsIGVsLm9mZnNldEhlaWdodCk7XG5cbiAgICAgIHRoaXMuZm9jdXNBY3RpdmVEYXkoKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cbiAgcHJldmlvdXNEaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5taW5EYXRlICYmIGlzU2FtZU1vbnRoKHRoaXMuY3VycmVudCwgdGhpcy5taW5EYXRlKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBuZXh0IHBlcmlvZCBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gIG5leHREaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tYXhEYXRlICYmIGlzU2FtZU1vbnRoKHRoaXMuY3VycmVudCwgdGhpcy5tYXhEYXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9jdXNBY3RpdmVEYXkoKSB7XG4gICAgdGhpcy5tb250aFZpZXcuZm9jdXNBY3RpdmVEYXkoKTtcbiAgfVxuXG4gIHByaXZhdGUgbW92ZUNhbGVuZGFyKGNvZGU6ICdNb3ZlJyB8ICdNb3ZlTW9udGgnIHwgJ01vdmVUbycsIHBhcmFtOiBudW1iZXIpIHtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgMTIpO1xuXG4gICAgaWYgKGNvZGUgPT09ICdNb3ZlJykge1xuICAgICAgZGF0ZS5zZXREYXRlKGRheSArICgrcGFyYW0pKTtcbiAgICAgIHRoaXMuc2V0Q3VycmVudCh7IHllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGg6IGRhdGUuZ2V0TW9udGgoKSwgZGF5OiBkYXRlLmdldERhdGUoKSB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09ICdNb3ZlTW9udGgnKSB7XG4gICAgICBkYXRlLnNldE1vbnRoKG1vbnRoICsgKCtwYXJhbSksIDEpO1xuICAgICAgdGhpcy5zZXRDdXJyZW50KHsgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aDogZGF0ZS5nZXRNb250aCgpLCBkYXkgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAnTW92ZVRvJykge1xuICAgICAgdGhpcy5zZXRDdXJyZW50KHsgZGF5OiArcGFyYW0gfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRDdXJyZW50KGQ6IFBhcnRpYWw8TmdsSW50ZXJuYWxEYXRlPiwgZG9SZW5kZXIgPSB0cnVlKSB7XG4gICAgdGhpcy5jdXJyZW50ID0geyAuLi50aGlzLmN1cnJlbnQsIC4uLmQgfTtcblxuICAgIC8vIEtlZXAgY3VycmVudCBpbnNpZGUgbWluaW11bS9tYXhpbXVtIHJhbmdlXG4gICAgaWYgKGNvbXBhcmVEYXRlKHRoaXMuY3VycmVudCwgdGhpcy5taW5EYXRlKSA8IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMubWluRGF0ZTtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmVEYXRlKHRoaXMuY3VycmVudCwgdGhpcy5tYXhEYXRlKSA+IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMubWF4RGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZG9SZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5tb250aExhYmVsID0gdGhpcy5tb250aE5hbWVzW21vbnRoXTtcblxuICAgIC8vIEtlZXAgY3VycmVudCBkYXkgaW5zaWRlIGxpbWl0cyBvZiB0aGlzIG1vbnRoXG4gICAgdGhpcy5zZXRDdXJyZW50KHsgZGF5OiBNYXRoLm1pbihkYXksIG51bWJlck9mRGF5c0luTW9udGgoeWVhciwgbW9udGgpKSB9LCBmYWxzZSk7XG4gIH1cblxuICAvKiogRGF0ZSBmaWx0ZXIgZm9yIHRoZSBtb250aCAqL1xuICBwcml2YXRlIGlzRGlzYWJsZWREYXRlKGRhdGU6IE5nbEludGVybmFsRGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0Rpc2FibGVkKGRhdGUsIHRoaXMuZGF0ZURpc2FibGVkLCB0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIHNldE1pbk1heERhdGVzKCkge1xuICAgIGNvbnN0IHsgeWVhciB9ID0gZ2V0VG9kYXkoKTtcbiAgICB0aGlzLm1pbkRhdGUgPSB0aGlzLm1pbiA/IHBhcnNlRGF0ZSh0aGlzLm1pbikgOiB7IHllYXI6IHllYXIgKyB0aGlzLnJlbGF0aXZlWWVhckZyb20sIG1vbnRoOiAwLCBkYXk6IDEgfTtcbiAgICB0aGlzLm1heERhdGUgPSB0aGlzLm1heCA/IHBhcnNlRGF0ZSh0aGlzLm1heCkgOiB7IHllYXI6IHllYXIgKyB0aGlzLnJlbGF0aXZlWWVhclRvLCBtb250aDogMTEsIGRheTogMzEgfTtcbiAgfVxufVxuIl19