import { __decorate, __metadata } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { uniqueId } from '../util/util';
import { InputNumber } from '../util/convert';
var NglDatepickerYear = /** @class */ (function () {
    function NglDatepickerYear() {
        this.uid = uniqueId('datepicker_year');
        this.yearChange = new EventEmitter();
    }
    NglDatepickerYear.prototype.change = function ($event) {
        this.yearChange.emit($event);
    };
    NglDatepickerYear.prototype.ngOnChanges = function () {
        this.range = this.getRange();
    };
    NglDatepickerYear.prototype.getRange = function () {
        var minYear = Math.min(this.from.year, this.year);
        var maxYear = Math.max(this.to.year, this.year);
        var size = maxYear - minYear;
        return Array.apply(null, { length: size + 1 }).map(function (value, index) { return minYear + index; });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglDatepickerYear.prototype, "from", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglDatepickerYear.prototype, "to", void 0);
    __decorate([
        Input(), InputNumber(),
        __metadata("design:type", Number)
    ], NglDatepickerYear.prototype, "year", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglDatepickerYear.prototype, "yearChange", void 0);
    NglDatepickerYear = __decorate([
        Component({
            selector: 'ngl-date-year',
            template: "\n<label class=\"slds-assistive-text\" [attr.for]=\"uid\">Pick a Year</label>\n<div class=\"slds-select_container\">\n  <select class=\"slds-select\" [id]=\"uid\" [ngModel]=\"year\" (ngModelChange)=\"change($event)\">\n    <option *ngFor=\"let yr of range\" [value]=\"yr\">{{yr}}</option>\n  </select>\n</div>",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], NglDatepickerYear);
    return NglDatepickerYear;
}());
export { NglDatepickerYear };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi9kYXRlcGlja2Vycy95ZWFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLHVCQUF1QixFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzNHLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDeEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBUTlDO0lBQUE7UUFFRSxRQUFHLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFNeEIsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7SUFtQjVDLENBQUM7SUFmQyxrQ0FBTSxHQUFOLFVBQU8sTUFBYztRQUNuQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsdUNBQVcsR0FBWDtRQUNFLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFTyxvQ0FBUSxHQUFoQjtRQUNFLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xELElBQU0sSUFBSSxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDL0IsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQyxLQUFVLEVBQUUsS0FBYSxJQUFLLE9BQUEsT0FBTyxHQUFHLEtBQUssRUFBZixDQUFlLENBQUMsQ0FBQztJQUNyRyxDQUFDO0lBckJRO1FBQVIsS0FBSyxFQUFFOzttREFBdUI7SUFDdEI7UUFBUixLQUFLLEVBQUU7O2lEQUFxQjtJQUVMO1FBQXZCLEtBQUssRUFBRSxFQUFFLFdBQVcsRUFBRTs7bURBQWM7SUFDM0I7UUFBVCxNQUFNLEVBQUU7O3lEQUFpQztJQVIvQixpQkFBaUI7UUFMN0IsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGVBQWU7WUFDekIsaVVBQTBCO1lBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1NBQ2hELENBQUM7T0FDVyxpQkFBaUIsQ0EyQjdCO0lBQUQsd0JBQUM7Q0FBQSxBQTNCRCxJQTJCQztTQTNCWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgSW5wdXROdW1iZXIgfSBmcm9tICcuLi91dGlsL2NvbnZlcnQnO1xuaW1wb3J0IHsgTmdsSW50ZXJuYWxEYXRlIH0gZnJvbSAnLi91dGlsJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmdsLWRhdGUteWVhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi95ZWFyLmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTmdsRGF0ZXBpY2tlclllYXIgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gIHVpZCA9IHVuaXF1ZUlkKCdkYXRlcGlja2VyX3llYXInKTtcblxuICBASW5wdXQoKSBmcm9tOiBOZ2xJbnRlcm5hbERhdGU7XG4gIEBJbnB1dCgpIHRvOiBOZ2xJbnRlcm5hbERhdGU7XG5cbiAgQElucHV0KCkgQElucHV0TnVtYmVyKCkgeWVhcjogbnVtYmVyO1xuICBAT3V0cHV0KCkgeWVhckNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICByYW5nZTogbnVtYmVyW107XG5cbiAgY2hhbmdlKCRldmVudDogc3RyaW5nKSB7XG4gICAgdGhpcy55ZWFyQ2hhbmdlLmVtaXQoJGV2ZW50KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmdlKCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtaW5ZZWFyID0gTWF0aC5taW4odGhpcy5mcm9tLnllYXIsIHRoaXMueWVhcik7XG4gICAgY29uc3QgbWF4WWVhciA9IE1hdGgubWF4KHRoaXMudG8ueWVhciwgdGhpcy55ZWFyKTtcbiAgICBjb25zdCBzaXplID0gbWF4WWVhciAtIG1pblllYXI7XG4gICAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIHsgbGVuZ3RoOiBzaXplICsgMSB9KS5tYXAoKHZhbHVlOiBhbnksIGluZGV4OiBudW1iZXIpID0+IG1pblllYXIgKyBpbmRleCk7XG4gIH1cblxufVxuIl19