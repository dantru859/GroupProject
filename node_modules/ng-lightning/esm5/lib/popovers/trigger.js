import { __decorate, __metadata, __read, __spread } from "tslib";
import { Directive, Input, ElementRef, TemplateRef, ViewContainerRef, OnDestroy, OnChanges, SimpleChanges, Output, EventEmitter, Renderer2, HostListener } from '@angular/core';
import { OverlayRef, Overlay, FlexibleConnectedPositionStrategy } from '@angular/cdk/overlay';
import { ESCAPE } from '@angular/cdk/keycodes';
import { ComponentPortal } from '@angular/cdk/portal';
import { Subject, merge } from 'rxjs';
import { map, filter, mapTo, distinctUntilChanged } from 'rxjs/operators';
import { NglPopover } from './popover';
import { POSITION_MAP, DEFAULT_POPOVER_POSITIONS, getPlacementName } from '../util/overlay-position';
import { hasObservers } from '../util/hasObservers';
import { toBoolean, InputBoolean } from '../util/convert';
var NglPopoverTrigger = /** @class */ (function () {
    function NglPopoverTrigger(element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Close button title (and assistive text).
         */
        this.closeTitle = 'Close dialog';
        /**
           * Whether or not to override the close button's visibility, if `nglPopoverOpenChange` is set.
           */
        this.closeVisible = true;
        /** Emit an event when actual popover is shown or hidden */
        this.nglPopoverOpenChange = new EventEmitter();
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'header',
            'footer',
            'placement',
            'variant',
            'size',
            'closeTitle',
            'canClose',
            'popoverClass',
            'closeVisible',
        ]);
        this._placement = 'top';
        this.backdrop = new Subject();
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    Object.defineProperty(NglPopoverTrigger.prototype, "placement", {
        get: function () {
            return this._placement;
        },
        /**
         * Position relative to host element.
         */
        set: function (_placement) {
            _placement = _placement || 'top';
            if (_placement === this._placement) {
                return;
            }
            this._placement = _placement;
            if (this.overlayRef) {
                this.updatePosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglPopoverTrigger.prototype, "nglOpen", {
        get: function () {
            return this._open;
        },
        /**
         * Whether the floating popover is visible.
         */
        set: function (_open) {
            _open = toBoolean(_open) && (['backdrop', 'x', 'escape'].indexOf(_open) === -1);
            _open ? this.create() : this.detach();
            this._open = _open;
        },
        enumerable: true,
        configurable: true
    });
    NglPopoverTrigger.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.nglOpen && !changes.nglOpen.firstChange) {
            var open_1 = changes.nglOpen.currentValue;
            if (!toBoolean(open_1) || open_1 === 'x' || open_1 === 'escape') {
                this.element.nativeElement.focus();
            }
        }
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(function () {
                if (_this.overlayRef) {
                    _this.overlayRef.updatePosition();
                }
            });
            this.popover.markForCheck();
        }
    };
    NglPopoverTrigger.prototype.onclick = function (evt) {
        evt.preventDefault();
        this.toggle();
    };
    NglPopoverTrigger.prototype.ngOnDestroy = function () {
        this.detach();
        this.close();
    };
    NglPopoverTrigger.prototype.open = function () {
        if (!this.nglOpen) {
            this.nglPopoverOpenChange.emit(true);
        }
    };
    NglPopoverTrigger.prototype.close = function (reason) {
        if (reason === void 0) { reason = false; }
        if (this.nglOpen) {
            this.nglPopoverOpenChange.emit(reason);
        }
    };
    NglPopoverTrigger.prototype.toggle = function () {
        this.nglOpen ? this.close() : this.open();
    };
    NglPopoverTrigger.prototype.create = function () {
        var _this = this;
        if (this.nglOpen) {
            return;
        }
        this.detach();
        var overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglPopover, this.viewContainerRef);
        this.popover = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(function (property) { return _this.updatePopover(property, _this[property]); });
        this.popover.markForCheck();
        this.clearGlobalClickTimeout();
        this.globalClickTimeout = setTimeout(function () {
            _this.subscribeToClickEvents();
        });
        this.closeSubscription = this.popoverClosingActions()
            .subscribe(function (reason) { return _this.close(reason); });
    };
    /** Detaches the currently attached popover. */
    NglPopoverTrigger.prototype.detach = function () {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        this.unsubscribeFromClickEvents();
        if (this.closeSubscription) {
            this.closeSubscription.unsubscribe();
            this.closeSubscription = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.popover = null;
    };
    /** Create the overlay config and position strategy */
    NglPopoverTrigger.prototype.createOverlay = function () {
        var _this = this;
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        var strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(function (change) { return getPlacementName(change, _this.placement); }), distinctUntilChanged())
            .subscribe(function (placement) {
            _this.updatePosition();
            _this.updatePopover('placement', placement);
            _this.popover.markForCheck();
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    };
    /** Updates the position of the current popover. */
    NglPopoverTrigger.prototype.updatePosition = function () {
        var position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions(__spread([
            POSITION_MAP[this.placement].position
        ], DEFAULT_POPOVER_POSITIONS));
    };
    NglPopoverTrigger.prototype.updatePopover = function (key, value) {
        this.popover[key] = value;
    };
    /** Set inputs of child components when this component's inputs change. */
    NglPopoverTrigger.prototype.updateProxies = function (changes) {
        var _this = this;
        Object.keys(changes)
            .filter(function (key) { return _this.needProxyProperties.has(key); })
            .forEach(function (key) { return _this.updatePopover(key, _this[key]); });
    };
    /** Returns a stream that emits whenever an action that should close the popover occurs. */
    NglPopoverTrigger.prototype.popoverClosingActions = function () {
        var backdrop = this.backdrop.pipe(mapTo('backdrop'));
        var close = this.popover.close.pipe(mapTo('x'));
        var escape = this.overlayRef.keydownEvents().pipe(filter(function (event) { return event.keyCode === ESCAPE; }), mapTo('escape'));
        return merge(backdrop, close, escape);
    };
    NglPopoverTrigger.prototype.handleGlobalClickEvent = function ($event) {
        if ($event.$nglStop) {
            return;
        }
        this.backdrop.next();
    };
    NglPopoverTrigger.prototype.subscribeToClickEvents = function () {
        this.unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.popover.element.nativeElement, 'click', function ($event) { return $event.$nglStop = true; });
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    };
    NglPopoverTrigger.prototype.unsubscribeFromClickEvents = function () {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    };
    NglPopoverTrigger.prototype.clearGlobalClickTimeout = function () {
        clearTimeout(this.globalClickTimeout);
    };
    NglPopoverTrigger.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: Overlay }
    ]; };
    __decorate([
        Input('nglPopover'),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "template", void 0);
    __decorate([
        Input('nglPopoverHeader'),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "header", void 0);
    __decorate([
        Input('nglPopoverFooter'),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "footer", void 0);
    __decorate([
        Input('nglPopoverVariant'),
        __metadata("design:type", String)
    ], NglPopoverTrigger.prototype, "variant", void 0);
    __decorate([
        Input('nglPopoverSize'),
        __metadata("design:type", String)
    ], NglPopoverTrigger.prototype, "size", void 0);
    __decorate([
        Input('nglPopoverPlacement'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], NglPopoverTrigger.prototype, "placement", null);
    __decorate([
        Input('nglPopoverOpen'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], NglPopoverTrigger.prototype, "nglOpen", null);
    __decorate([
        Input('nglPopoverCloseTitle'),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "closeTitle", void 0);
    __decorate([
        Input('nglPopoverClass'),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "popoverClass", void 0);
    __decorate([
        Input('nglPopoverCloseVisible'), InputBoolean(),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "closeVisible", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglPopoverTrigger.prototype, "nglPopoverOpenChange", void 0);
    __decorate([
        hasObservers('nglPopoverOpenChange'),
        __metadata("design:type", Boolean)
    ], NglPopoverTrigger.prototype, "canClose", void 0);
    __decorate([
        HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Event]),
        __metadata("design:returntype", void 0)
    ], NglPopoverTrigger.prototype, "onclick", null);
    NglPopoverTrigger = __decorate([
        Directive({
            selector: '[nglPopover]',
            exportAs: 'nglPopover',
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            ViewContainerRef,
            Overlay])
    ], NglPopoverTrigger);
    return NglPopoverTrigger;
}());
export { NglPopoverTrigger };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJpZ2dlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi9wb3BvdmVycy90cmlnZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQ3hGLGFBQWEsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5RixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxZQUFZLEVBQUUseUJBQXlCLEVBQUUsZ0JBQWdCLEVBQWEsTUFBTSwwQkFBMEIsQ0FBQztBQUNoSCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVMxRDtJQXNHRSwyQkFDVSxPQUFtQixFQUNuQixRQUFtQixFQUNuQixnQkFBa0MsRUFDbEMsT0FBZ0I7UUFIaEIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLHFCQUFnQixHQUFoQixnQkFB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Q1QsU0FBUztnQkFDRCxnQkFBZ0I7Z0JBQ3pCLE9BQU87O0lBckdMO1FBQXBCLEtBQUssQ0FBQyxZQUFZLENBQUM7O3VEQUFzQztJQUsvQjtRQUExQixLQUFLLENBQUMsa0JBQWtCLENBQUM7O3FEQUFvQztJQUtuQztRQUExQixLQUFLLENBQUMsa0JBQWtCLENBQUM7O3FEQUFvQztJQUtsQztRQUEzQixLQUFLLENBQUMsbUJBQW1CLENBQUM7O3NEQUFrQjtJQUtwQjtRQUF4QixLQUFLLENBQUMsZ0JBQWdCLENBQUM7O21EQUFZO0lBTXBDO1FBREMsS0FBSyxDQUFDLHFCQUFxQixDQUFDOzs7c0RBWTVCO0lBU0Q7UUFEQyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7OztvREFLdkI7SUFROEI7UUFBOUIsS0FBSyxDQUFDLHNCQUFzQixDQUFDOzt5REFBNkI7SUFFakM7UUFBekIsS0FBSyxDQUFDLGlCQUFpQixDQUFDOzsyREFBbUI7SUFLSztRQUFoRCxLQUFLLENBQUMsd0JBQXdCLENBQUMsRUFBRSxZQUFZLEVBQUU7OzJEQUFxQjtJQUczRDtRQUFULE1BQU0sRUFBRTs7bUVBQWdEO0lBRW5CO1FBQXJDLFlBQVksQ0FBQyxzQkFBc0IsQ0FBQzs7dURBQW1CO0lBdUR4RDtRQURDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7eUNBQ3JCLEtBQUs7O29EQUdqQjtJQXJJVSxpQkFBaUI7UUFKN0IsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGNBQWM7WUFDeEIsUUFBUSxFQUFFLFlBQVk7U0FDdkIsQ0FBQzt5Q0F3R21CLFVBQVU7WUFDVCxTQUFTO1lBQ0QsZ0JBQWdCO1lBQ3pCLE9BQU87T0ExR2YsaUJBQWlCLENBc1M3QjtJQUFELHdCQUFDO0NBQUEsQUF0U0QsSUFzU0M7U0F0U1ksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgRWxlbWVudFJlZiwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYsIE9uRGVzdHJveSwgT25DaGFuZ2VzLFxuICBTaW1wbGVDaGFuZ2VzLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgUmVuZGVyZXIyLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJsYXlSZWYsIE92ZXJsYXksIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgZmlsdGVyLCBtYXBUbywgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOZ2xQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyJztcbmltcG9ydCB7IFBPU0lUSU9OX01BUCwgREVGQVVMVF9QT1BPVkVSX1BPU0lUSU9OUywgZ2V0UGxhY2VtZW50TmFtZSwgUGxhY2VtZW50IH0gZnJvbSAnLi4vdXRpbC9vdmVybGF5LXBvc2l0aW9uJztcbmltcG9ydCB7IGhhc09ic2VydmVycyB9IGZyb20gJy4uL3V0aWwvaGFzT2JzZXJ2ZXJzJztcbmltcG9ydCB7IHRvQm9vbGVhbiwgSW5wdXRCb29sZWFuIH0gZnJvbSAnLi4vdXRpbC9jb252ZXJ0JztcblxuZXhwb3J0IHR5cGUgU2l6ZSA9ICdzbWFsbCcgfCAnbWVkaXVtJyB8ICdsYXJnZScgfCAnZnVsbC13aWR0aCc7XG5leHBvcnQgdHlwZSBWYXJpYW50ID0gJ3dhbGt0aHJvdWdoJyB8ICdmZWF0dXJlJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAncGFuZWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmdsUG9wb3Zlcl0nLFxuICBleHBvcnRBczogJ25nbFBvcG92ZXInLFxufSlcbmV4cG9ydCBjbGFzcyBOZ2xQb3BvdmVyVHJpZ2dlciBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAvKipcbiAgICogVGhlIGJvZHkgYXMgc3RyaW5nIG9yIHRoZSBjb25uZWN0ZWQgdGVtcGxhdGUgcmVmZXJlbmNlIHRvIHNob3cuXG4gICAqL1xuICBASW5wdXQoJ25nbFBvcG92ZXInKSB0ZW1wbGF0ZTogc3RyaW5nIHwgVGVtcGxhdGVSZWY8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSBoZWFkZXIgYXMgc3RyaW5nIG9yIHRoZSBjb25uZWN0ZWQgdGVtcGxhdGUgcmVmZXJlbmNlIHRvIHNob3cuXG4gICAqL1xuICBASW5wdXQoJ25nbFBvcG92ZXJIZWFkZXInKSBoZWFkZXI6IHN0cmluZyB8IFRlbXBsYXRlUmVmPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgZm9vdGVyIGFzIHN0cmluZyBvciB0aGUgY29ubmVjdGVkIHRlbXBsYXRlIHJlZmVyZW5jZSB0byBzaG93LlxuICAgKi9cbiAgQElucHV0KCduZ2xQb3BvdmVyRm9vdGVyJykgZm9vdGVyOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjx2b2lkPjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdmFyaWFudCBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIEBJbnB1dCgnbmdsUG9wb3ZlclZhcmlhbnQnKSB2YXJpYW50OiBWYXJpYW50O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaXplIG9mIHRoZSBwb3BvdmVyLlxuICAgKi9cbiAgQElucHV0KCduZ2xQb3BvdmVyU2l6ZScpIHNpemU6IFNpemU7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHJlbGF0aXZlIHRvIGhvc3QgZWxlbWVudC5cbiAgICovXG4gIEBJbnB1dCgnbmdsUG9wb3ZlclBsYWNlbWVudCcpXG4gIHNldCBwbGFjZW1lbnQoX3BsYWNlbWVudDogUGxhY2VtZW50KSB7XG4gICAgX3BsYWNlbWVudCA9IF9wbGFjZW1lbnQgfHwgJ3RvcCc7XG4gICAgaWYgKF9wbGFjZW1lbnQgPT09IHRoaXMuX3BsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BsYWNlbWVudCA9IF9wbGFjZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGdldCBwbGFjZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYWNlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBmbG9hdGluZyBwb3BvdmVyIGlzIHZpc2libGUuXG4gICAqL1xuICBASW5wdXQoJ25nbFBvcG92ZXJPcGVuJylcbiAgc2V0IG5nbE9wZW4oX29wZW46IGFueSkge1xuICAgIF9vcGVuID0gdG9Cb29sZWFuKF9vcGVuKSAmJiAoWydiYWNrZHJvcCcsICd4JywgJ2VzY2FwZSddLmluZGV4T2YoX29wZW4pID09PSAtMSk7XG4gICAgX29wZW4gPyB0aGlzLmNyZWF0ZSgpIDogdGhpcy5kZXRhY2goKTtcbiAgICB0aGlzLl9vcGVuID0gX29wZW47XG4gIH1cbiAgZ2V0IG5nbE9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgYnV0dG9uIHRpdGxlIChhbmQgYXNzaXN0aXZlIHRleHQpLlxuICAgKi9cbiAgQElucHV0KCduZ2xQb3BvdmVyQ2xvc2VUaXRsZScpIGNsb3NlVGl0bGUgPSAnQ2xvc2UgZGlhbG9nJztcblxuICBASW5wdXQoJ25nbFBvcG92ZXJDbGFzcycpIHBvcG92ZXJDbGFzczogYW55O1xuXG4gIC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0byBvdmVycmlkZSB0aGUgY2xvc2UgYnV0dG9uJ3MgdmlzaWJpbGl0eSwgaWYgYG5nbFBvcG92ZXJPcGVuQ2hhbmdlYCBpcyBzZXQuXG5cdCAqL1xuICBASW5wdXQoJ25nbFBvcG92ZXJDbG9zZVZpc2libGUnKSBASW5wdXRCb29sZWFuKCkgY2xvc2VWaXNpYmxlID0gdHJ1ZTtcblxuICAvKiogRW1pdCBhbiBldmVudCB3aGVuIGFjdHVhbCBwb3BvdmVyIGlzIHNob3duIG9yIGhpZGRlbiAqL1xuICBAT3V0cHV0KCkgbmdsUG9wb3Zlck9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBAaGFzT2JzZXJ2ZXJzKCduZ2xQb3BvdmVyT3BlbkNoYW5nZScpIGNhbkNsb3NlOiBib29sZWFuO1xuXG4gIC8qKiBOYW1lcyBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHByb3h5IHRvIGNoaWxkIGNvbXBvbmVudC4gKi9cbiAgcHJpdmF0ZSBuZWVkUHJveHlQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgJ3RlbXBsYXRlJyxcbiAgICAnaGVhZGVyJyxcbiAgICAnZm9vdGVyJyxcbiAgICAncGxhY2VtZW50JyxcbiAgICAndmFyaWFudCcsXG4gICAgJ3NpemUnLFxuICAgICdjbG9zZVRpdGxlJyxcbiAgICAnY2FuQ2xvc2UnLFxuICAgICdwb3BvdmVyQ2xhc3MnLFxuICAgICdjbG9zZVZpc2libGUnLFxuICBdKTtcbiAgcHJpdmF0ZSBfcGxhY2VtZW50OiBQbGFjZW1lbnQgPSAndG9wJztcbiAgcHJpdmF0ZSBfb3BlbjogYm9vbGVhbjtcbiAgcHJpdmF0ZSBwb3J0YWw6IENvbXBvbmVudFBvcnRhbDxOZ2xQb3BvdmVyPjtcbiAgcHJpdmF0ZSBvdmVybGF5UmVmOiBPdmVybGF5UmVmIHwgbnVsbDtcbiAgcHJpdmF0ZSBwb3BvdmVyOiBOZ2xQb3BvdmVyIHwgbnVsbDtcbiAgcHJpdmF0ZSBiYWNrZHJvcCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgY2xvc2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBwb3NpdGlvbkNoYW5nZXNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBnbG9iYWxDbGlja0V2ZW50VW5zdWJzY3JpYmVyOiBGdW5jdGlvbiA9IG51bGw7XG4gIHByaXZhdGUgY2xpY2tFdmVudFVuc3Vic2NyaWJlcjogRnVuY3Rpb24gPSBudWxsO1xuICBwcml2YXRlIGdsb2JhbENsaWNrVGltZW91dDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSkge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubmdsT3BlbiAmJiAhY2hhbmdlcy5uZ2xPcGVuLmZpcnN0Q2hhbmdlKSB7XG4gICAgICBjb25zdCBvcGVuID0gY2hhbmdlcy5uZ2xPcGVuLmN1cnJlbnRWYWx1ZTtcbiAgICAgIGlmICghdG9Cb29sZWFuKG9wZW4pIHx8IG9wZW4gPT09ICd4JyB8fCBvcGVuID09PSAnZXNjYXBlJykge1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm5nbE9wZW4pIHtcbiAgICAgIHRoaXMudXBkYXRlUHJveGllcyhjaGFuZ2VzKTtcblxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucG9wb3Zlci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gIG9uY2xpY2soZXZ0OiBFdmVudCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgb3BlbigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubmdsT3Blbikge1xuICAgICAgdGhpcy5uZ2xQb3BvdmVyT3BlbkNoYW5nZS5lbWl0KHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xvc2UocmVhc29uOiBhbnkgPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5nbE9wZW4pIHtcbiAgICAgIHRoaXMubmdsUG9wb3Zlck9wZW5DaGFuZ2UuZW1pdChyZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMubmdsT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmdsT3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5jcmVhdGVPdmVybGF5KCk7XG5cbiAgICB0aGlzLnBvcnRhbCA9IHRoaXMucG9ydGFsIHx8IG5ldyBDb21wb25lbnRQb3J0YWwoTmdsUG9wb3ZlciwgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICB0aGlzLnBvcG92ZXIgPSBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLnBvcnRhbCkuaW5zdGFuY2U7XG5cbiAgICB0aGlzLm5lZWRQcm94eVByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB0aGlzLnVwZGF0ZVBvcG92ZXIocHJvcGVydHksIHRoaXNbIHByb3BlcnR5IF0pKTtcbiAgICB0aGlzLnBvcG92ZXIubWFya0ZvckNoZWNrKCk7XG5cbiAgICB0aGlzLmNsZWFyR2xvYmFsQ2xpY2tUaW1lb3V0KCk7XG4gICAgdGhpcy5nbG9iYWxDbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlVG9DbGlja0V2ZW50cygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbiA9IHRoaXMucG9wb3ZlckNsb3NpbmdBY3Rpb25zKClcbiAgICAgIC5zdWJzY3JpYmUocmVhc29uID0+IHRoaXMuY2xvc2UocmVhc29uKSk7XG4gIH1cblxuICAvKiogRGV0YWNoZXMgdGhlIGN1cnJlbnRseSBhdHRhY2hlZCBwb3BvdmVyLiAqL1xuICBwcml2YXRlIGRldGFjaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLm92ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICB0aGlzLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdmVybGF5UmVmID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNsaWNrRXZlbnRzKCk7XG5cbiAgICBpZiAodGhpcy5jbG9zZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zaXRpb25DaGFuZ2VzU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMucG9wb3ZlciA9IG51bGw7XG4gIH1cblxuICAvKiogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbmZpZyBhbmQgcG9zaXRpb24gc3RyYXRlZ3kgKi9cbiAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xuICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWY7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNvbm5lY3RlZCBwb3NpdGlvbiBzdHJhdGVneSB0aGF0IGxpc3RlbnMgZm9yIHNjcm9sbCBldmVudHMgdG8gcmVwb3NpdGlvbi5cbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMub3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyh0aGlzLmVsZW1lbnQpXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oOClcbiAgICAgIC53aXRoUHVzaChmYWxzZSk7XG5cbiAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IHN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlc1xuICAgICAgLnBpcGUobWFwKGNoYW5nZSA9PiBnZXRQbGFjZW1lbnROYW1lKGNoYW5nZSwgdGhpcy5wbGFjZW1lbnQpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgIC5zdWJzY3JpYmUoKHBsYWNlbWVudDogUGxhY2VtZW50KSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVQb3BvdmVyKCdwbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLnBvcG92ZXIubWFya0ZvckNoZWNrKCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMub3ZlcmxheVJlZiA9IHRoaXMub3ZlcmxheS5jcmVhdGUoe1xuICAgICAgcG9zaXRpb25TdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpLFxuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZjtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBwb3BvdmVyLiAqL1xuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uKCk6IHZvaWQge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gPEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneT50aGlzLm92ZXJsYXlSZWYuZ2V0Q29uZmlnKCkucG9zaXRpb25TdHJhdGVneTtcblxuICAgIHBvc2l0aW9uLndpdGhQb3NpdGlvbnMoW1xuICAgICAgUE9TSVRJT05fTUFQW3RoaXMucGxhY2VtZW50XS5wb3NpdGlvbixcbiAgICAgIC4uLkRFRkFVTFRfUE9QT1ZFUl9QT1NJVElPTlMsXG4gICAgXSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvcG92ZXIoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnBvcG92ZXJbIGtleSBdID0gdmFsdWU7XG4gIH1cblxuICAvKiogU2V0IGlucHV0cyBvZiBjaGlsZCBjb21wb25lbnRzIHdoZW4gdGhpcyBjb21wb25lbnQncyBpbnB1dHMgY2hhbmdlLiAqL1xuICBwcml2YXRlIHVwZGF0ZVByb3hpZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAuZmlsdGVyKGtleSA9PiB0aGlzLm5lZWRQcm94eVByb3BlcnRpZXMuaGFzKGtleSkpXG4gICAgICAuZm9yRWFjaChrZXkgPT4gdGhpcy51cGRhdGVQb3BvdmVyKGtleSwgdGhpc1trZXldKSk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhIHN0cmVhbSB0aGF0IGVtaXRzIHdoZW5ldmVyIGFuIGFjdGlvbiB0aGF0IHNob3VsZCBjbG9zZSB0aGUgcG9wb3ZlciBvY2N1cnMuICovXG4gIHByaXZhdGUgcG9wb3ZlckNsb3NpbmdBY3Rpb25zKCkge1xuICAgIGNvbnN0IGJhY2tkcm9wID0gdGhpcy5iYWNrZHJvcC5waXBlKG1hcFRvKCdiYWNrZHJvcCcpKTtcbiAgICBjb25zdCBjbG9zZSA9IHRoaXMucG9wb3Zlci5jbG9zZS5waXBlKG1hcFRvKCd4JykpO1xuICAgIGNvbnN0IGVzY2FwZSA9IHRoaXMub3ZlcmxheVJlZi5rZXlkb3duRXZlbnRzKCkucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFKSwgbWFwVG8oJ2VzY2FwZScpKTtcbiAgICByZXR1cm4gbWVyZ2UoYmFja2Ryb3AsIGNsb3NlLCBlc2NhcGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVHbG9iYWxDbGlja0V2ZW50KCRldmVudDogYW55KSB7XG4gICAgaWYgKCRldmVudC4kbmdsU3RvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhY2tkcm9wLm5leHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9DbGlja0V2ZW50cygpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNsaWNrRXZlbnRzKCk7XG5cbiAgICAvLyBQcmV2ZW50IGRvY3VtZW50IGxpc3RlbmVyIHRvIGNsb3NlIGl0LCBzaW5jZSBjbGljayBoYXBwZW5lZCBpbnNpZGVcbiAgICB0aGlzLmNsaWNrRXZlbnRVbnN1YnNjcmliZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLnBvcG92ZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoJGV2ZW50OiBhbnkpID0+ICRldmVudC4kbmdsU3RvcCA9IHRydWUpO1xuXG4gICAgdGhpcy5nbG9iYWxDbGlja0V2ZW50VW5zdWJzY3JpYmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgdGhpcy5oYW5kbGVHbG9iYWxDbGlja0V2ZW50LmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZUZyb21DbGlja0V2ZW50cygpIHtcbiAgICBpZiAodGhpcy5jbGlja0V2ZW50VW5zdWJzY3JpYmVyKSB7XG4gICAgICB0aGlzLmNsaWNrRXZlbnRVbnN1YnNjcmliZXIoKTtcbiAgICAgIHRoaXMuY2xpY2tFdmVudFVuc3Vic2NyaWJlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsQ2xpY2tFdmVudFVuc3Vic2NyaWJlcikge1xuICAgICAgdGhpcy5nbG9iYWxDbGlja0V2ZW50VW5zdWJzY3JpYmVyKCk7XG4gICAgICB0aGlzLmdsb2JhbENsaWNrRXZlbnRVbnN1YnNjcmliZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJHbG9iYWxDbGlja1RpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ2xvYmFsQ2xpY2tUaW1lb3V0KTtcbiAgfVxufVxuIl19