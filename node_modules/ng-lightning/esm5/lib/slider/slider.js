import { __decorate, __metadata } from "tslib";
import { Component, Input, ChangeDetectionStrategy, ElementRef, Renderer2, TemplateRef, forwardRef, ChangeDetectorRef, HostBinding, Output, EventEmitter } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { uniqueId } from '../util/util';
import { InputNumber, InputBoolean } from '../util/convert';
var NGL_SLIDER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return NglSlider; }),
    multi: true
};
var NglSlider = /** @class */ (function () {
    function NglSlider(element, renderer, cd) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * The minimum value that the slider can have.
         */
        this.min = 0;
        /**
         * The maximum value that the slider can have.
         */
        this.max = 100;
        /**
         * The granularity the slider can step through values.
         */
        this.step = 1;
        /**
         * Whether the slider will be displayed vertically.
         */
        this.vertical = false;
        this.valueChange = new EventEmitter();
        this.uid = uniqueId('slider');
        this._value = null;
        this.onChange = null;
        this.onTouched = function () { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    Object.defineProperty(NglSlider.prototype, "hasError", {
        get: function () {
            return !!this.error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglSlider.prototype, "value", {
        get: function () {
            // If the value needs to be read and it is still uninitialized, initialize it to the min.
            if (this._value === null) {
                this._value = this.min;
            }
            return this._value;
        },
        set: function (value) {
            if (value !== this._value) {
                this._value = this.limit(coerceNumberProperty(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    NglSlider.prototype.writeValue = function (value) {
        this.value = value;
        this.cd.markForCheck();
    };
    NglSlider.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    NglSlider.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    NglSlider.prototype.setDisabledState = function (isDisabled) { this.disabled = isDisabled; };
    NglSlider.prototype.onInput = function (value) {
        // Make sure we always emit number
        this.valueChange.emit(coerceNumberProperty(value));
        if (this.onChange) {
            this.value = value;
            this.onChange(this.value);
        }
    };
    NglSlider.prototype.sliderClass = function () {
        var _a;
        return _a = {},
            _a["slds-size_" + this.size] = !!this.size,
            _a["slds-slider_vertical"] = this.vertical,
            _a;
    };
    NglSlider.prototype.limit = function (value) {
        return Math.min(Math.max(value, this.min), this.max);
    };
    NglSlider.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "label", void 0);
    __decorate([
        Input(), InputNumber(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "min", void 0);
    __decorate([
        Input(), InputNumber(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "max", void 0);
    __decorate([
        Input(), InputNumber(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "step", void 0);
    __decorate([
        Input(), InputBoolean(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "vertical", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NglSlider.prototype, "size", void 0);
    __decorate([
        Input(), InputBoolean(),
        __metadata("design:type", Boolean)
    ], NglSlider.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "error", void 0);
    __decorate([
        HostBinding('class.slds-has-error'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [])
    ], NglSlider.prototype, "hasError", null);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], NglSlider.prototype, "value", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglSlider.prototype, "valueChange", void 0);
    NglSlider = __decorate([
        Component({
            selector: 'ngl-slider',
            template: "\n<label class=\"slds-form-element__label\" [attr.for]=\"uid\"><span class=\"slds-slider-label\"><span class=\"slds-slider-label__label\" *ngIf=\"label\" [nglInternalOutlet]=\"label\"></span><span class=\"slds-slider-label__range\">{{min}} - {{max}}</span></span></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-slider\" [ngClass]=\"sliderClass()\">\n    <input class=\"slds-slider__range\" [id]=\"uid\" type=\"range\" [value]=\"value\" [min]=\"min\" [max]=\"max\" [step]=\"step\" [disabled]=\"disabled\" [attr.aria-describedby]=\"hasError ? uid + '-error' : null\" (input)=\"onInput($event.target.value)\"><span class=\"slds-slider__value\" aria-hidden=\"true\">{{value}}</span>\n  </div>\n  <div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>\n</div>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [NGL_SLIDER_VALUE_ACCESSOR]
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
    ], NglSlider);
    return NglSlider;
}());
export { NglSlider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctbGlnaHRuaW5nLyIsInNvdXJjZXMiOlsibGliL3NsaWRlci9zbGlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUM3RSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakcsT0FBTyxFQUFFLGlCQUFpQixFQUF3QixNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzdELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDeEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU1RCxJQUFNLHlCQUF5QixHQUFHO0lBQ2hDLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsU0FBUyxFQUFULENBQVMsQ0FBQztJQUN4QyxLQUFLLEVBQUUsSUFBSTtDQUNaLENBQUM7QUFRRjtJQWtFRSxtQkFBb0IsT0FBbUIsRUFBVSxRQUFtQixFQUFVLEVBQXFCO1FBQS9FLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQVUsT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUEzRG5HOztXQUVHO1FBQ3FCLFFBQUcsR0FBRyxDQUFDLENBQUM7UUFFaEM7O1dBRUc7UUFDcUIsUUFBRyxHQUFHLEdBQUcsQ0FBQztRQUVsQzs7V0FFRztRQUNxQixTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRWpDOztXQUVHO1FBQ3NCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFtQ2hDLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FB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QVksRUFBRTs7K0NBQW1CO0lBS2xDO1FBQVIsS0FBSyxFQUFFOzs0Q0FBa0M7SUFHMUM7UUFEQyxXQUFXLENBQUMsc0JBQXNCLENBQUM7Ozs2Q0FHbkM7SUFFUTtRQUFSLEtBQUssRUFBRTs7OzBDQUlQO0lBU1M7UUFBVCxNQUFNLEVBQUU7O2tEQUEwQztJQTVEeEMsU0FBUztRQU5yQixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsWUFBWTtZQUN0Qix3MUJBQTRCO1lBQzVCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1lBQy9DLFNBQVMsRUFBRSxDQUFDLHlCQUF5QixDQUFDO1NBQ3ZDLENBQUM7eUNBbUU2QixVQUFVLEVBQW9CLFNBQVMsRUFBYyxpQkFBaUI7T0FsRXhGLFNBQVMsQ0F5R3JCO0lBQUQsZ0JBQUM7Q0FBQSxBQXpHRCxJQXlHQztTQXpHWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgVGVtcGxhdGVSZWYsXG4gICAgICAgICBmb3J3YXJkUmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgSG9zdEJpbmRpbmcsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBJbnB1dE51bWJlciwgSW5wdXRCb29sZWFuIH0gZnJvbSAnLi4vdXRpbC9jb252ZXJ0JztcblxuY29uc3QgTkdMX1NMSURFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5nbFNsaWRlciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ2wtc2xpZGVyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3NsaWRlci5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW05HTF9TTElERVJfVkFMVUVfQUNDRVNTT1JdLFxufSlcbmV4cG9ydCBjbGFzcyBOZ2xTbGlkZXIgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgLyoqXG4gICAqIExhYmVsIHRoYXQgYXBwZWFycyBhYm92ZSB0aGUgU2xpZGVyLlxuICAgKi9cbiAgQElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS5cbiAgICovXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIG1pbiA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS5cbiAgICovXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIG1heCA9IDEwMDtcblxuICAvKipcbiAgICogVGhlIGdyYW51bGFyaXR5IHRoZSBzbGlkZXIgY2FuIHN0ZXAgdGhyb3VnaCB2YWx1ZXMuXG4gICAqL1xuICBASW5wdXQoKSBASW5wdXROdW1iZXIoKSBzdGVwID0gMTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIHdpbGwgYmUgZGlzcGxheWVkIHZlcnRpY2FsbHkuXG4gICAqL1xuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgdmVydGljYWwgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIEBJbnB1dCgpIHNpemU6ICd4eC1zbWFsbCcgfCAneC1zbWFsbCcgfCAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnIHwgJ3gtbGFyZ2UnIHwgJ3h4LWxhcmdlJztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIGRpc2FibGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBNZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB0aGVyZSBpcyBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICovXG4gIEBJbnB1dCgpIGVycm9yOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3Muc2xkcy1oYXMtZXJyb3InKVxuICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lcnJvcjtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgbnVsbCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5saW1pdChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAvLyBJZiB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcmVhZCBhbmQgaXQgaXMgc3RpbGwgdW5pbml0aWFsaXplZCwgaW5pdGlhbGl6ZSBpdCB0byB0aGUgbWluLlxuICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgdWlkID0gdW5pcXVlSWQoJ3NsaWRlcicpO1xuXG4gIHByaXZhdGUgX3ZhbHVlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnc2xkcy1mb3JtLWVsZW1lbnQnKTtcbiAgfVxuXG4gIG9uQ2hhbmdlOiBGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIG9uVG91Y2hlZCA9ICgpID0+IHt9O1xuXG4gIHdyaXRlVmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IGFueSk6IHZvaWQgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gYW55KTogdm9pZCB7IHRoaXMub25Ub3VjaGVkID0gZm47IH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHsgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7IH1cblxuICBvbklucHV0KHZhbHVlKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyBlbWl0IG51bWJlclxuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSkpO1xuXG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMub25DaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2xpZGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgc2xkcy1zaXplXyR7dGhpcy5zaXplfWBdOiAhIXRoaXMuc2l6ZSxcbiAgICAgIFtgc2xkcy1zbGlkZXJfdmVydGljYWxgXTogdGhpcy52ZXJ0aWNhbCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBsaW1pdCh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIHRoaXMubWluKSwgdGhpcy5tYXgpO1xuICB9XG59XG4iXX0=