import { __decorate, __metadata } from "tslib";
import { Component, Input, ChangeDetectionStrategy, HostBinding, ContentChildren, QueryList } from '@angular/core';
import { toBoolean, InputBoolean } from '../../util/convert';
import { uniqueId } from '../../util/util';
import { NglCheckboxOption } from './checkbox-option';
var NglCheckboxGroup = /** @class */ (function () {
    function NglCheckboxGroup() {
        this.uid = uniqueId('checkbox-group');
        this._type = 'list';
    }
    Object.defineProperty(NglCheckboxGroup.prototype, "hasError", {
        get: function () {
            return toBoolean(this.error);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglCheckboxGroup.prototype, "errorId", {
        get: function () {
            return "error_" + this.uid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglCheckboxGroup.prototype, "type", {
        get: function () {
            return this._type;
        },
        set: function (type) {
            this._type = type;
            this.updateChildrenType();
        },
        enumerable: true,
        configurable: true
    });
    NglCheckboxGroup.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.error && this.options) {
            this.options.forEach(function (option) {
                option.setError(_this.error ? _this.errorId : null);
            });
        }
    };
    NglCheckboxGroup.prototype.ngAfterContentInit = function () {
        this.updateChildrenType();
    };
    NglCheckboxGroup.prototype.updateChildrenType = function () {
        var _this = this;
        if (!this.options) {
            return;
        }
        this.options.forEach(function (option) {
            option.type = _this.type;
        });
    };
    __decorate([
        ContentChildren(NglCheckboxOption),
        __metadata("design:type", QueryList)
    ], NglCheckboxGroup.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglCheckboxGroup.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NglCheckboxGroup.prototype, "error", void 0);
    __decorate([
        HostBinding('class.slds-has-error'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], NglCheckboxGroup.prototype, "hasError", null);
    __decorate([
        Input(), InputBoolean(),
        __metadata("design:type", Boolean)
    ], NglCheckboxGroup.prototype, "required", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], NglCheckboxGroup.prototype, "type", null);
    NglCheckboxGroup = __decorate([
        Component({
            selector: 'ngl-checkbox-group,[ngl-checkbox-group]',
            template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            host: {
                '[class.slds-form-element]': 'true',
            }
        })
    ], NglCheckboxGroup);
    return NglCheckboxGroup;
}());
export { NglCheckboxGroup };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3gtZ3JvdXAuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1saWdodG5pbmcvIiwic291cmNlcyI6WyJsaWIvY2hlY2tib3hlcy9ncm91cC9jaGVja2JveC1ncm91cC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQWUsV0FBVyxFQUN0QyxlQUFlLEVBQUUsU0FBUyxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUN2RyxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzdELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQVV0RDtJQUFBO1FBMkJVLFFBQUcsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVqQyxVQUFLLEdBQXNCLE1BQU0sQ0FBQztJQXVCNUMsQ0FBQztJQTNDQyxzQkFBSSxzQ0FBUTthQUFaO1lBQ0UsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9CLENBQUM7OztPQUFBO0lBSUQsc0JBQUkscUNBQU87YUFBWDtZQUNFLE9BQU8sV0FBUyxJQUFJLENBQUMsR0FBSyxDQUFDO1FBQzdCLENBQUM7OztPQUFBO0lBRVEsc0JBQUksa0NBQUk7YUFJakI7WUFDRSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQzthQU5RLFVBQVMsSUFBdUI7WUFDdkMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDbEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDNUIsQ0FBQzs7O09BQUE7SUFTRCxzQ0FBVyxHQUFYLFVBQVksT0FBc0I7UUFBbEMsaUJBTUM7UUFMQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNqQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQXlCO2dCQUM3QyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBRUQsNkNBQWtCLEdBQWxCO1FBQ0UsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVPLDZDQUFrQixHQUExQjtRQUFBLGlCQVFDO1FBUEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxNQUF5QjtZQUM3QyxNQUFNLENBQUMsSUFBSSxHQUFHLEtBQUksQ0FBQyxJQUFJLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBakRtQztRQUFuQyxlQUFlLENBQUMsaUJBQWlCLENBQUM7a0NBQVUsU0FBUztxREFBb0I7SUFFakU7UUFBUixLQUFLLEVBQUU7O21EQUFrQztJQUVqQztRQUFSLEtBQUssRUFBRTs7bURBQWtDO0lBRzFDO1FBREMsV0FBVyxDQUFDLHNCQUFzQixDQUFDOzs7b0RBR25DO0lBRXdCO1FBQXhCLEtBQUssRUFBRSxFQUFFLFlBQVksRUFBRTs7c0RBQW1CO0lBTWxDO1FBQVIsS0FBSyxFQUFFOzs7Z0RBR1A7SUF0QlUsZ0JBQWdCO1FBUjVCLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSx5Q0FBeUM7WUFDbkQseW1CQUFvQztZQUNwQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtZQUMvQyxJQUFJLEVBQUU7Z0JBQ0osMkJBQTJCLEVBQUUsTUFBTTthQUNwQztTQUNGLENBQUM7T0FDVyxnQkFBZ0IsQ0FvRDVCO0lBQUQsdUJBQUM7Q0FBQSxBQXBERCxJQW9EQztTQXBEWSxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgVGVtcGxhdGVSZWYsIEhvc3RCaW5kaW5nLFxuICAgICAgICAgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdG9Cb29sZWFuLCBJbnB1dEJvb2xlYW4gfSBmcm9tICcuLi8uLi91dGlsL2NvbnZlcnQnO1xuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgTmdsQ2hlY2tib3hPcHRpb24gfSBmcm9tICcuL2NoZWNrYm94LW9wdGlvbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nbC1jaGVja2JveC1ncm91cCxbbmdsLWNoZWNrYm94LWdyb3VwXScsXG4gIHRlbXBsYXRlVXJsOiAnLi9jaGVja2JveC1ncm91cC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnNsZHMtZm9ybS1lbGVtZW50XSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTmdsQ2hlY2tib3hHcm91cCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2xDaGVja2JveE9wdGlvbikgb3B0aW9uczogUXVlcnlMaXN0PE5nbENoZWNrYm94T3B0aW9uPjtcblxuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICBASW5wdXQoKSBlcnJvcjogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnNsZHMtaGFzLWVycm9yJylcbiAgZ2V0IGhhc0Vycm9yKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0b0Jvb2xlYW4odGhpcy5lcnJvcik7XG4gIH1cblxuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgcmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgZ2V0IGVycm9ySWQoKSB7XG4gICAgcmV0dXJuIGBlcnJvcl8ke3RoaXMudWlkfWA7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgdHlwZSh0eXBlOiAnbGlzdCcgfCAnYnV0dG9uJykge1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMudXBkYXRlQ2hpbGRyZW5UeXBlKCk7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cblxuICBwcml2YXRlIHVpZCA9IHVuaXF1ZUlkKCdjaGVja2JveC1ncm91cCcpO1xuXG4gIHByaXZhdGUgX3R5cGU6ICdsaXN0JyB8ICdidXR0b24nID0gJ2xpc3QnO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5lcnJvciAmJiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKChvcHRpb246IE5nbENoZWNrYm94T3B0aW9uKSA9PiB7XG4gICAgICAgIG9wdGlvbi5zZXRFcnJvcih0aGlzLmVycm9yID8gdGhpcy5lcnJvcklkIDogbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy51cGRhdGVDaGlsZHJlblR5cGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2hpbGRyZW5UeXBlKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2goKG9wdGlvbjogTmdsQ2hlY2tib3hPcHRpb24pID0+IHtcbiAgICAgIG9wdGlvbi50eXBlID0gdGhpcy50eXBlO1xuICAgIH0pO1xuICB9XG59XG4iXX0=