import { ElementRef, TemplateRef, ViewContainerRef, OnDestroy, OnChanges, SimpleChanges, EventEmitter, Renderer2 } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { Placement } from '../util/overlay-position';
import * as ɵngcc0 from '@angular/core';
export declare type Size = 'small' | 'medium' | 'large' | 'full-width';
export declare type Variant = 'walkthrough' | 'feature' | 'warning' | 'error' | 'panel';
export declare class NglPopoverTrigger implements OnChanges, OnDestroy {
    private element;
    private renderer;
    private viewContainerRef;
    private overlay;
    /**
     * The body as string or the connected template reference to show.
     */
    template: string | TemplateRef<void>;
    /**
     * The header as string or the connected template reference to show.
     */
    header: string | TemplateRef<void>;
    /**
     * The footer as string or the connected template reference to show.
     */
    footer: string | TemplateRef<void>;
    /**
     * Determines the variant of the popover.
     */
    variant: Variant;
    /**
     * Determines the size of the popover.
     */
    size: Size;
    /**
     * Position relative to host element.
     */
    set placement(_placement: Placement);
    get placement(): Placement;
    /**
     * Whether the floating popover is visible.
     */
    set nglOpen(_open: any);
    get nglOpen(): any;
    /**
     * Close button title (and assistive text).
     */
    closeTitle: string;
    popoverClass: any;
    /**
       * Whether or not to override the close button's visibility, if `nglPopoverOpenChange` is set.
       */
    closeVisible: boolean;
    /** Emit an event when actual popover is shown or hidden */
    nglPopoverOpenChange: EventEmitter<any>;
    canClose: boolean;
    /** Names of properties that should be proxy to child component. */
    private needProxyProperties;
    private _placement;
    private _open;
    private portal;
    private overlayRef;
    private popover;
    private backdrop;
    private closeSubscription;
    private positionChangesSubscription;
    private globalClickEventUnsubscriber;
    private clickEventUnsubscriber;
    private globalClickTimeout;
    constructor(element: ElementRef, renderer: Renderer2, viewContainerRef: ViewContainerRef, overlay: Overlay);
    ngOnChanges(changes: SimpleChanges): void;
    onclick(evt: Event): void;
    ngOnDestroy(): void;
    private open;
    private close;
    private toggle;
    private create;
    /** Detaches the currently attached popover. */
    private detach;
    /** Create the overlay config and position strategy */
    private createOverlay;
    /** Updates the position of the current popover. */
    private updatePosition;
    private updatePopover;
    /** Set inputs of child components when this component's inputs change. */
    private updateProxies;
    /** Returns a stream that emits whenever an action that should close the popover occurs. */
    private popoverClosingActions;
    private handleGlobalClickEvent;
    private subscribeToClickEvents;
    private unsubscribeFromClickEvents;
    private clearGlobalClickTimeout;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NglPopoverTrigger, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NglPopoverTrigger, "[nglPopover]", ["nglPopover"], { "closeTitle": "nglPopoverCloseTitle"; "closeVisible": "nglPopoverCloseVisible"; "placement": "nglPopoverPlacement"; "nglOpen": "nglPopoverOpen"; "template": "nglPopover"; "header": "nglPopoverHeader"; "footer": "nglPopoverFooter"; "variant": "nglPopoverVariant"; "size": "nglPopoverSize"; "popoverClass": "nglPopoverClass"; }, { "nglPopoverOpenChange": "nglPopoverOpenChange"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJpZ2dlci5kLnRzIiwic291cmNlcyI6WyJ0cmlnZ2VyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmLCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgRXZlbnRFbWl0dGVyLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJsYXkgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi91dGlsL292ZXJsYXktcG9zaXRpb24nO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBTaXplID0gJ3NtYWxsJyB8ICdtZWRpdW0nIHwgJ2xhcmdlJyB8ICdmdWxsLXdpZHRoJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgVmFyaWFudCA9ICd3YWxrdGhyb3VnaCcgfCAnZmVhdHVyZScgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ3BhbmVsJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nbFBvcG92ZXJUcmlnZ2VyIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIG92ZXJsYXk7XG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgYXMgc3RyaW5nIG9yIHRoZSBjb25uZWN0ZWQgdGVtcGxhdGUgcmVmZXJlbmNlIHRvIHNob3cuXG4gICAgICovXG4gICAgdGVtcGxhdGU6IHN0cmluZyB8IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWFkZXIgYXMgc3RyaW5nIG9yIHRoZSBjb25uZWN0ZWQgdGVtcGxhdGUgcmVmZXJlbmNlIHRvIHNob3cuXG4gICAgICovXG4gICAgaGVhZGVyOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9vdGVyIGFzIHN0cmluZyBvciB0aGUgY29ubmVjdGVkIHRlbXBsYXRlIHJlZmVyZW5jZSB0byBzaG93LlxuICAgICAqL1xuICAgIGZvb3Rlcjogc3RyaW5nIHwgVGVtcGxhdGVSZWY8dm9pZD47XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgdmFyaWFudCBvZiB0aGUgcG9wb3Zlci5cbiAgICAgKi9cbiAgICB2YXJpYW50OiBWYXJpYW50O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIHNpemUgb2YgdGhlIHBvcG92ZXIuXG4gICAgICovXG4gICAgc2l6ZTogU2l6ZTtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiByZWxhdGl2ZSB0byBob3N0IGVsZW1lbnQuXG4gICAgICovXG4gICAgc2V0IHBsYWNlbWVudChfcGxhY2VtZW50OiBQbGFjZW1lbnQpO1xuICAgIGdldCBwbGFjZW1lbnQoKTogUGxhY2VtZW50O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGZsb2F0aW5nIHBvcG92ZXIgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBzZXQgbmdsT3Blbihfb3BlbjogYW55KTtcbiAgICBnZXQgbmdsT3BlbigpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYnV0dG9uIHRpdGxlIChhbmQgYXNzaXN0aXZlIHRleHQpLlxuICAgICAqL1xuICAgIGNsb3NlVGl0bGU6IHN0cmluZztcbiAgICBwb3BvdmVyQ2xhc3M6IGFueTtcbiAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIG92ZXJyaWRlIHRoZSBjbG9zZSBidXR0b24ncyB2aXNpYmlsaXR5LCBpZiBgbmdsUG9wb3Zlck9wZW5DaGFuZ2VgIGlzIHNldC5cbiAgICAgICAqL1xuICAgIGNsb3NlVmlzaWJsZTogYm9vbGVhbjtcbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIGFjdHVhbCBwb3BvdmVyIGlzIHNob3duIG9yIGhpZGRlbiAqL1xuICAgIG5nbFBvcG92ZXJPcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBjYW5DbG9zZTogYm9vbGVhbjtcbiAgICAvKiogTmFtZXMgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBwcm94eSB0byBjaGlsZCBjb21wb25lbnQuICovXG4gICAgcHJpdmF0ZSBuZWVkUHJveHlQcm9wZXJ0aWVzO1xuICAgIHByaXZhdGUgX3BsYWNlbWVudDtcbiAgICBwcml2YXRlIF9vcGVuO1xuICAgIHByaXZhdGUgcG9ydGFsO1xuICAgIHByaXZhdGUgb3ZlcmxheVJlZjtcbiAgICBwcml2YXRlIHBvcG92ZXI7XG4gICAgcHJpdmF0ZSBiYWNrZHJvcDtcbiAgICBwcml2YXRlIGNsb3NlU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgcG9zaXRpb25DaGFuZ2VzU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgZ2xvYmFsQ2xpY2tFdmVudFVuc3Vic2NyaWJlcjtcbiAgICBwcml2YXRlIGNsaWNrRXZlbnRVbnN1YnNjcmliZXI7XG4gICAgcHJpdmF0ZSBnbG9iYWxDbGlja1RpbWVvdXQ7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgb3ZlcmxheTogT3ZlcmxheSk7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgb25jbGljayhldnQ6IEV2ZW50KTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHByaXZhdGUgb3BlbjtcbiAgICBwcml2YXRlIGNsb3NlO1xuICAgIHByaXZhdGUgdG9nZ2xlO1xuICAgIHByaXZhdGUgY3JlYXRlO1xuICAgIC8qKiBEZXRhY2hlcyB0aGUgY3VycmVudGx5IGF0dGFjaGVkIHBvcG92ZXIuICovXG4gICAgcHJpdmF0ZSBkZXRhY2g7XG4gICAgLyoqIENyZWF0ZSB0aGUgb3ZlcmxheSBjb25maWcgYW5kIHBvc2l0aW9uIHN0cmF0ZWd5ICovXG4gICAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5O1xuICAgIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBwb3BvdmVyLiAqL1xuICAgIHByaXZhdGUgdXBkYXRlUG9zaXRpb247XG4gICAgcHJpdmF0ZSB1cGRhdGVQb3BvdmVyO1xuICAgIC8qKiBTZXQgaW5wdXRzIG9mIGNoaWxkIGNvbXBvbmVudHMgd2hlbiB0aGlzIGNvbXBvbmVudCdzIGlucHV0cyBjaGFuZ2UuICovXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm94aWVzO1xuICAgIC8qKiBSZXR1cm5zIGEgc3RyZWFtIHRoYXQgZW1pdHMgd2hlbmV2ZXIgYW4gYWN0aW9uIHRoYXQgc2hvdWxkIGNsb3NlIHRoZSBwb3BvdmVyIG9jY3Vycy4gKi9cbiAgICBwcml2YXRlIHBvcG92ZXJDbG9zaW5nQWN0aW9ucztcbiAgICBwcml2YXRlIGhhbmRsZUdsb2JhbENsaWNrRXZlbnQ7XG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb0NsaWNrRXZlbnRzO1xuICAgIHByaXZhdGUgdW5zdWJzY3JpYmVGcm9tQ2xpY2tFdmVudHM7XG4gICAgcHJpdmF0ZSBjbGVhckdsb2JhbENsaWNrVGltZW91dDtcbn1cbiJdfQ==