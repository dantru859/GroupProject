import { ElementRef, Renderer2, TemplateRef, ChangeDetectorRef, EventEmitter, OnInit, OnChanges, SimpleChanges, OnDestroy, NgZone } from '@angular/core';
import { ControlValueAccessor, Validator, AbstractControl, ValidationErrors } from '@angular/forms';
import { CdkConnectedOverlay, ConnectionPositionPair } from '@angular/cdk/overlay';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { HostService } from '../../common/host/host.service';
import { NglDateAdapter } from '../adapters/date-fns-adapter';
import { NglDatepickerConfig } from '../config';
import * as ɵngcc0 from '@angular/core';
export declare class NglDatepickerInput implements ControlValueAccessor, Validator, OnInit, OnChanges, OnDestroy {
    private element;
    private renderer;
    private cd;
    private hostService;
    private ngZone;
    private focusTrapFactory;
    private adapter;
    /**
     * Label that appears above the input.
     */
    label: string | TemplateRef<any>;
    /**
     * Placeholder of input.
     */
    placeholder: string;
    /**
     * Pre-defined format to use.
     */
    format: 'big-endian' | 'little-endian' | 'middle-endian';
    /**
     * Delimiter to use on pre-defined formats.
     */
    delimiter: any;
    /**
     * Disable input and calendar.
     */
    disabled: boolean;
    /**
     * Whether input is readonly and calendar is available for date selection.
     */
    readonlyInput: boolean;
    /**
     * Aligns the right or left side of the dropdown menu with the respective side of the input.
     */
    dropdownAlign: 'left' | 'right';
    /**
     * The date value.
     */
    set value(value: Date | string | null);
    get value(): Date | string | null;
    /**
     * Whether to open the datepicker when a mouse user clicks on the input.
     */
    openOnInputClick: boolean;
    /**
     * Emits when selected date changes.
     */
    valueChange: EventEmitter<string | Date>;
    inputEl: ElementRef;
    cdkOverlay: CdkConnectedOverlay;
    /**
     * The minimum valid date.
     */
    readonly min: Date;
    /**
     * The maximum valid date.
     */
    readonly max: Date;
    /**
     * Text for button to open calendar.
     */
    readonly selectDateLabel = "Select a date";
    /**
     * Datepicker inputs
     */
    monthNames: string[];
    dayNamesShort: string[];
    dayNamesLong: string[];
    firstDayOfWeek: number;
    showToday: boolean;
    dateDisabled: (date: Date) => boolean | null;
    relativeYearFrom: number;
    relativeYearTo: number;
    todayLabel: string;
    previousMonthLabel: string;
    nextMonthLabel: string;
    date: Date;
    uid: string;
    overlayPositions: ConnectionPositionPair[];
    set open(open: boolean);
    get open(): boolean;
    private _open;
    private _value;
    private pattern;
    private config;
    private focusTrap;
    constructor(defaultConfig: NglDatepickerConfig, locale: string, element: ElementRef, renderer: Renderer2, cd: ChangeDetectorRef, hostService: HostService, ngZone: NgZone, focusTrapFactory: FocusTrapFactory, adapter: NglDateAdapter);
    onChange: Function | null;
    onTouched: () => void;
    validatorChange: () => void;
    validate(c: AbstractControl): ValidationErrors | null;
    writeValue(value: Date): void;
    registerOnChange(fn: (value: any) => any): void;
    registerOnTouched(fn: () => any): void;
    registerOnValidatorChange(fn: () => void): void;
    setDisabledState(disabled: boolean): void;
    onBlur(): void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    onKeyboardInput(evt: KeyboardEvent): void;
    onInputChange(value: string): void;
    openCalendar(): void;
    onAttach(): void;
    onDetach(): void;
    closeCalendar(focusInput?: boolean): void;
    onTriggerClick(origin: 'input' | 'button'): void;
    pickerSelection(date: Date): void;
    updateDatepickerSize(width: number, height: number): void;
    private setPositions;
    private formatInputValue;
    private updateInputValue;
    private dateParse;
    private dateFormat;
    private getPattern;
    private setPattern;
    private emitSelection;
    private setHostClass;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NglDatepickerInput, [{ optional: true; }, null, null, null, null, null, null, null, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NglDatepickerInput, "ngl-datepicker-input", never, { "placeholder": "placeholder"; "readonlyInput": "readonlyInput"; "selectDateLabel": "selectDateLabel"; "dateDisabled": "dateDisabled"; "format": "format"; "delimiter": "delimiter"; "monthNames": "monthNames"; "dayNamesShort": "dayNamesShort"; "dayNamesLong": "dayNamesLong"; "firstDayOfWeek": "firstDayOfWeek"; "showToday": "showToday"; "relativeYearFrom": "relativeYearFrom"; "relativeYearTo": "relativeYearTo"; "openOnInputClick": "openOnInputClick"; "todayLabel": "todayLabel"; "previousMonthLabel": "previousMonthLabel"; "nextMonthLabel": "nextMonthLabel"; "value": "value"; "disabled": "disabled"; "label": "label"; "dropdownAlign": "dropdownAlign"; "min": "min"; "max": "max"; }, { "valueChange": "valueChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci1pbnB1dC5kLnRzIiwic291cmNlcyI6WyJkYXRlcGlja2VyLWlucHV0LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBSZW5kZXJlcjIsIFRlbXBsYXRlUmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgT25EZXN0cm95LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENka0Nvbm5lY3RlZE92ZXJsYXksIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBGb2N1c1RyYXBGYWN0b3J5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgSG9zdFNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb21tb24vaG9zdC9ob3N0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdsRGF0ZUFkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVycy9kYXRlLWZucy1hZGFwdGVyJztcbmltcG9ydCB7IE5nbERhdGVwaWNrZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdsRGF0ZXBpY2tlcklucHV0IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50O1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBjZDtcbiAgICBwcml2YXRlIGhvc3RTZXJ2aWNlO1xuICAgIHByaXZhdGUgbmdab25lO1xuICAgIHByaXZhdGUgZm9jdXNUcmFwRmFjdG9yeTtcbiAgICBwcml2YXRlIGFkYXB0ZXI7XG4gICAgLyoqXG4gICAgICogTGFiZWwgdGhhdCBhcHBlYXJzIGFib3ZlIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBvZiBpbnB1dC5cbiAgICAgKi9cbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFByZS1kZWZpbmVkIGZvcm1hdCB0byB1c2UuXG4gICAgICovXG4gICAgZm9ybWF0OiAnYmlnLWVuZGlhbicgfCAnbGl0dGxlLWVuZGlhbicgfCAnbWlkZGxlLWVuZGlhbic7XG4gICAgLyoqXG4gICAgICogRGVsaW1pdGVyIHRvIHVzZSBvbiBwcmUtZGVmaW5lZCBmb3JtYXRzLlxuICAgICAqL1xuICAgIGRlbGltaXRlcjogYW55O1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgaW5wdXQgYW5kIGNhbGVuZGFyLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaW5wdXQgaXMgcmVhZG9ubHkgYW5kIGNhbGVuZGFyIGlzIGF2YWlsYWJsZSBmb3IgZGF0ZSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcmVhZG9ubHlJbnB1dDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbGlnbnMgdGhlIHJpZ2h0IG9yIGxlZnQgc2lkZSBvZiB0aGUgZHJvcGRvd24gbWVudSB3aXRoIHRoZSByZXNwZWN0aXZlIHNpZGUgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGRyb3Bkb3duQWxpZ246ICdsZWZ0JyB8ICdyaWdodCc7XG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgdmFsdWUuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBEYXRlIHwgc3RyaW5nIHwgbnVsbCk7XG4gICAgZ2V0IHZhbHVlKCk6IERhdGUgfCBzdHJpbmcgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3BlbiB0aGUgZGF0ZXBpY2tlciB3aGVuIGEgbW91c2UgdXNlciBjbGlja3Mgb24gdGhlIGlucHV0LlxuICAgICAqL1xuICAgIG9wZW5PbklucHV0Q2xpY2s6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmcgfCBEYXRlPjtcbiAgICBpbnB1dEVsOiBFbGVtZW50UmVmO1xuICAgIGNka092ZXJsYXk6IENka0Nvbm5lY3RlZE92ZXJsYXk7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdmFsaWQgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkb25seSBtaW46IERhdGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsaWQgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkb25seSBtYXg6IERhdGU7XG4gICAgLyoqXG4gICAgICogVGV4dCBmb3IgYnV0dG9uIHRvIG9wZW4gY2FsZW5kYXIuXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2VsZWN0RGF0ZUxhYmVsID0gXCJTZWxlY3QgYSBkYXRlXCI7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBpbnB1dHNcbiAgICAgKi9cbiAgICBtb250aE5hbWVzOiBzdHJpbmdbXTtcbiAgICBkYXlOYW1lc1Nob3J0OiBzdHJpbmdbXTtcbiAgICBkYXlOYW1lc0xvbmc6IHN0cmluZ1tdO1xuICAgIGZpcnN0RGF5T2ZXZWVrOiBudW1iZXI7XG4gICAgc2hvd1RvZGF5OiBib29sZWFuO1xuICAgIGRhdGVEaXNhYmxlZDogKGRhdGU6IERhdGUpID0+IGJvb2xlYW4gfCBudWxsO1xuICAgIHJlbGF0aXZlWWVhckZyb206IG51bWJlcjtcbiAgICByZWxhdGl2ZVllYXJUbzogbnVtYmVyO1xuICAgIHRvZGF5TGFiZWw6IHN0cmluZztcbiAgICBwcmV2aW91c01vbnRoTGFiZWw6IHN0cmluZztcbiAgICBuZXh0TW9udGhMYWJlbDogc3RyaW5nO1xuICAgIGRhdGU6IERhdGU7XG4gICAgdWlkOiBzdHJpbmc7XG4gICAgb3ZlcmxheVBvc2l0aW9uczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdO1xuICAgIHNldCBvcGVuKG9wZW46IGJvb2xlYW4pO1xuICAgIGdldCBvcGVuKCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfb3BlbjtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIHBhdHRlcm47XG4gICAgcHJpdmF0ZSBjb25maWc7XG4gICAgcHJpdmF0ZSBmb2N1c1RyYXA7XG4gICAgY29uc3RydWN0b3IoZGVmYXVsdENvbmZpZzogTmdsRGF0ZXBpY2tlckNvbmZpZywgbG9jYWxlOiBzdHJpbmcsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgaG9zdFNlcnZpY2U6IEhvc3RTZXJ2aWNlLCBuZ1pvbmU6IE5nWm9uZSwgZm9jdXNUcmFwRmFjdG9yeTogRm9jdXNUcmFwRmFjdG9yeSwgYWRhcHRlcjogTmdsRGF0ZUFkYXB0ZXIpO1xuICAgIG9uQ2hhbmdlOiBGdW5jdGlvbiB8IG51bGw7XG4gICAgb25Ub3VjaGVkOiAoKSA9PiB2b2lkO1xuICAgIHZhbGlkYXRvckNoYW5nZTogKCkgPT4gdm9pZDtcbiAgICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBEYXRlKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IGFueSkgPT4gYW55KTogdm9pZDtcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gYW55KTogdm9pZDtcbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICBzZXREaXNhYmxlZFN0YXRlKGRpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICBvbkJsdXIoKTogdm9pZDtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgb25LZXlib2FyZElucHV0KGV2dDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgb25JbnB1dENoYW5nZSh2YWx1ZTogc3RyaW5nKTogdm9pZDtcbiAgICBvcGVuQ2FsZW5kYXIoKTogdm9pZDtcbiAgICBvbkF0dGFjaCgpOiB2b2lkO1xuICAgIG9uRGV0YWNoKCk6IHZvaWQ7XG4gICAgY2xvc2VDYWxlbmRhcihmb2N1c0lucHV0PzogYm9vbGVhbik6IHZvaWQ7XG4gICAgb25UcmlnZ2VyQ2xpY2sob3JpZ2luOiAnaW5wdXQnIHwgJ2J1dHRvbicpOiB2b2lkO1xuICAgIHBpY2tlclNlbGVjdGlvbihkYXRlOiBEYXRlKTogdm9pZDtcbiAgICB1cGRhdGVEYXRlcGlja2VyU2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQ7XG4gICAgcHJpdmF0ZSBzZXRQb3NpdGlvbnM7XG4gICAgcHJpdmF0ZSBmb3JtYXRJbnB1dFZhbHVlO1xuICAgIHByaXZhdGUgdXBkYXRlSW5wdXRWYWx1ZTtcbiAgICBwcml2YXRlIGRhdGVQYXJzZTtcbiAgICBwcml2YXRlIGRhdGVGb3JtYXQ7XG4gICAgcHJpdmF0ZSBnZXRQYXR0ZXJuO1xuICAgIHByaXZhdGUgc2V0UGF0dGVybjtcbiAgICBwcml2YXRlIGVtaXRTZWxlY3Rpb247XG4gICAgcHJpdmF0ZSBzZXRIb3N0Q2xhc3M7XG59XG4iXX0=