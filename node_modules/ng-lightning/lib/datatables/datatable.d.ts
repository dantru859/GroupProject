import { ChangeDetectorRef, QueryList, EventEmitter, AfterContentInit, OnDestroy } from '@angular/core';
import { NglDatatableColumn } from './column';
import { NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay } from './overlays';
import * as ɵngcc0 from '@angular/core';
export interface INglDatatableSort {
    key: string;
    order: 'asc' | 'desc';
}
export interface INglDatatableRowClick {
    event: Event;
    data: any;
}
export declare class NglDatatable implements AfterContentInit, OnDestroy {
    private detector;
    data: any[];
    trackByKey: string;
    sort: INglDatatableSort;
    sortChange: EventEmitter<INglDatatableSort>;
    loading: boolean;
    loadingOverlay: NglDatatableLoadingOverlay;
    get showLoading(): NglDatatableLoadingOverlay;
    noRowsOverlay: NglDatatableNoRowsOverlay;
    columns: QueryList<NglDatatableColumn>;
    rowClick: EventEmitter<INglDatatableRowClick>;
    private _columnsSubscription;
    constructor(detector: ChangeDetectorRef);
    columnTrackBy(index: number, column: NglDatatableColumn): string | number;
    dataTrackBy: (index: number, data: any) => any;
    onColumnSort(column: NglDatatableColumn, order: 'asc' | 'desc'): void;
    getColumnSortOrder(column: NglDatatableColumn): "desc" | "asc";
    onRowClick(event: Event, data: any): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NglDatatable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NglDatatable, "table[ngl-datatable]", never, { "data": "data"; "loading": "loading"; "trackByKey": "trackByKey"; "sort": "sort"; }, { "sortChange": "sortChange"; "rowClick": "rowClick"; }, ["loadingOverlay", "noRowsOverlay", "columns"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRhYmxlLmQudHMiLCJzb3VyY2VzIjpbImRhdGF0YWJsZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBRdWVyeUxpc3QsIEV2ZW50RW1pdHRlciwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ2xEYXRhdGFibGVDb2x1bW4gfSBmcm9tICcuL2NvbHVtbic7XG5pbXBvcnQgeyBOZ2xEYXRhdGFibGVMb2FkaW5nT3ZlcmxheSwgTmdsRGF0YXRhYmxlTm9Sb3dzT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMnO1xuZXhwb3J0IGludGVyZmFjZSBJTmdsRGF0YXRhYmxlU29ydCB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgb3JkZXI6ICdhc2MnIHwgJ2Rlc2MnO1xufVxuZXhwb3J0IGludGVyZmFjZSBJTmdsRGF0YXRhYmxlUm93Q2xpY2sge1xuICAgIGV2ZW50OiBFdmVudDtcbiAgICBkYXRhOiBhbnk7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2xEYXRhdGFibGUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZGV0ZWN0b3I7XG4gICAgZGF0YTogYW55W107XG4gICAgdHJhY2tCeUtleTogc3RyaW5nO1xuICAgIHNvcnQ6IElOZ2xEYXRhdGFibGVTb3J0O1xuICAgIHNvcnRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxJTmdsRGF0YXRhYmxlU29ydD47XG4gICAgbG9hZGluZzogYm9vbGVhbjtcbiAgICBsb2FkaW5nT3ZlcmxheTogTmdsRGF0YXRhYmxlTG9hZGluZ092ZXJsYXk7XG4gICAgZ2V0IHNob3dMb2FkaW5nKCk6IE5nbERhdGF0YWJsZUxvYWRpbmdPdmVybGF5O1xuICAgIG5vUm93c092ZXJsYXk6IE5nbERhdGF0YWJsZU5vUm93c092ZXJsYXk7XG4gICAgY29sdW1uczogUXVlcnlMaXN0PE5nbERhdGF0YWJsZUNvbHVtbj47XG4gICAgcm93Q2xpY2s6IEV2ZW50RW1pdHRlcjxJTmdsRGF0YXRhYmxlUm93Q2xpY2s+O1xuICAgIHByaXZhdGUgX2NvbHVtbnNTdWJzY3JpcHRpb247XG4gICAgY29uc3RydWN0b3IoZGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgICBjb2x1bW5UcmFja0J5KGluZGV4OiBudW1iZXIsIGNvbHVtbjogTmdsRGF0YXRhYmxlQ29sdW1uKTogc3RyaW5nIHwgbnVtYmVyO1xuICAgIGRhdGFUcmFja0J5OiAoaW5kZXg6IG51bWJlciwgZGF0YTogYW55KSA9PiBhbnk7XG4gICAgb25Db2x1bW5Tb3J0KGNvbHVtbjogTmdsRGF0YXRhYmxlQ29sdW1uLCBvcmRlcjogJ2FzYycgfCAnZGVzYycpOiB2b2lkO1xuICAgIGdldENvbHVtblNvcnRPcmRlcihjb2x1bW46IE5nbERhdGF0YWJsZUNvbHVtbik6IFwiZGVzY1wiIHwgXCJhc2NcIjtcbiAgICBvblJvd0NsaWNrKGV2ZW50OiBFdmVudCwgZGF0YTogYW55KTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xufVxuIl19