import { __decorate, __metadata, __param } from 'tslib';
import { RendererFactory2, Injectable, ElementRef, Input, Component, ChangeDetectionStrategy, InjectionToken, Optional, Inject, Renderer2, NgModule, TemplateRef, Directive, EventEmitter, Output, ContentChildren, QueryList, ChangeDetectorRef, HostBinding, HostListener, ViewChildren, ViewChild, ContentChild, ViewContainerRef, forwardRef, Self, NgZone, LOCALE_ID } from '@angular/core';
import { CommonModule, DOCUMENT, getLocaleMonthNames, FormStyle, TranslationWidth, getLocaleDayNames, getLocaleFirstDayOfWeek } from '@angular/common';
import { coerceBooleanProperty, _isNumberValue, coerceNumberProperty } from '@angular/cdk/coercion';
import { LEFT_ARROW, RIGHT_ARROW, ESCAPE, DOWN_ARROW, UP_ARROW, ENTER, PAGE_UP, PAGE_DOWN, HOME, END } from '@angular/cdk/keycodes';
import { BehaviorSubject, Subject, merge, fromEvent } from 'rxjs';
import { ConnectionPositionPair, Overlay, OverlayModule, CdkConnectedOverlay, ScrollDispatcher, CdkOverlayOrigin } from '@angular/cdk/overlay';
import { FocusTrapFactory, A11yModule, ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { ComponentPortal } from '@angular/cdk/portal';
import { map, distinctUntilChanged, mapTo, filter, flatMap, startWith, takeUntil, buffer, debounceTime, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { parse, format } from 'date-fns';

let HostService = class HostService {
    constructor(rendererFactory2) {
        this.classMap = {};
        this.styleMap = {};
        this.renderer = rendererFactory2.createRenderer(null, null);
    }
    updateClass({ nativeElement }, classMap) {
        const newClassMap = {};
        const remove = Object.assign({}, this.classMap);
        Object.keys(classMap).filter(i => classMap[i]).forEach(i => {
            newClassMap[i] = true;
            if (!this.classMap[i]) {
                this.renderer.addClass(nativeElement, i);
            }
            if (remove[i]) {
                remove[i] = false;
            }
        });
        Object.keys(remove).filter(i => remove[i]).forEach(i => this.renderer.removeClass(nativeElement, i));
        this.classMap = newClassMap;
    }
    updateStyle({ nativeElement }, styleMap) {
        const remove = Object.assign({}, this.styleMap);
        Object.keys(styleMap).filter(i => styleMap[i]).forEach(i => {
            if (styleMap[i] !== false) {
                this.renderer.setStyle(nativeElement, i, styleMap[i]);
            }
            if (remove[i]) {
                delete remove[i];
            }
        });
        Object.keys(remove).forEach(i => this.renderer.removeStyle(nativeElement, i));
        this.styleMap = styleMap;
    }
};
HostService.ctorParameters = () => [
    { type: RendererFactory2 }
];
HostService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [RendererFactory2])
], HostService);

// Check if given value is integer. Cast strings as potential integers as well.
// See: http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript
function isInt(value) {
    if (isNaN(value)) {
        return false;
    }
    const x = parseFloat(value);
    // tslint:disable-next-line:no-bitwise
    return (x | 0) === x;
}
// Similar to `lodash.isobject`
function isObject(value) {
    const type = typeof value;
    return !!value && (type === 'object' || type === 'function');
}
// Generate a unique id (unique within the entire client session).
// Useful for temporary DOM ids.
let idCounter = 0;
function uniqueId(prefix = 'uid') {
    return `ngl_${prefix}_${++idCounter}`;
}
function replaceClass(instance, oldClass, newClass) {
    if (oldClass && oldClass !== newClass) {
        setClass(instance, oldClass, false);
    }
    if (newClass) {
        setClass(instance, newClass, true);
    }
}
function setClass(instance, klasses, isAdd) {
    if (klasses) {
        (Array.isArray(klasses) ? klasses : [klasses]).forEach(k => {
            instance.renderer[isAdd ? 'addClass' : 'removeClass'](instance.element.nativeElement, k);
        });
    }
}
function ngClassCombine(ngClasses, customClasses) {
    if (!ngClasses) {
        return customClasses;
    }
    // Convert string and Set to array
    if (typeof ngClasses === 'string') {
        ngClasses = ngClasses.split(/\s+/);
    }
    else if (ngClasses instanceof Set) {
        const a = [];
        ngClasses.forEach(v => a.push(v));
        ngClasses = a;
    }
    // Convert array to object
    if (Array.isArray(ngClasses)) {
        ngClasses = ngClasses.reduce((o, klass) => {
            o[klass] = true;
            return o;
        }, {});
    }
    return Object.assign(Object.assign({}, ngClasses), customClasses);
}
/**
   * Check whether value is currently selected.
   *
   * @param selection The value(s) currently selected
   * @param value The value in test, whether is (part of) selection or not
   * @param multiple Whether selections can be have multiple values
   */
function isOptionSelected(value, selection, multiple) {
    // Multiple
    if (multiple) {
        if (!selection) {
            return false;
        }
        return Array.isArray(selection) ? selection.indexOf(value) > -1 : !!selection[value];
    }
    // Single
    return value === selection;
}
function addOptionToSelection(value, selection, multiple) {
    let next;
    if (multiple) {
        if (!selection) {
            selection = [];
        }
        if (Array.isArray(selection)) {
            // Remove if already there or add to selection
            const index = selection.indexOf(value);
            next = index > -1
                ? [...selection.slice(0, index), ...selection.slice(index + 1)]
                : [...selection, value];
        }
        else {
            next = Object.assign({}, selection, { [value]: !selection[value] });
        }
    }
    else {
        next = selection === value ? null : value;
    }
    return next;
}
function menuItemScroll(container, domItem, scrollPadding = 4) {
    if (domItem.offsetHeight - container.scrollTop + domItem.offsetTop >=
        container.offsetHeight) {
        container.scrollTop =
            domItem.offsetHeight +
                domItem.offsetTop -
                container.offsetHeight +
                scrollPadding;
    }
    else if (domItem.offsetTop <= container.scrollTop) {
        container.scrollTop = domItem.offsetTop - scrollPadding;
    }
}
function trapEvent(event) {
    if (!event) {
        return;
    }
    event.preventDefault();
    event.stopPropagation();
}

function normalizeIconName(iconName) {
    return iconName.indexOf(':') > -1 ? iconName : `utility:${iconName}`;
}

let NglIcon = class NglIcon {
    constructor(el, hostService) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The appearance of a `utility` icon.
         */
        this.variant = 'default';
    }
    set iconName(iconName) {
        this._iconName = normalizeIconName(iconName);
    }
    get iconName() {
        return this._iconName;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    svgClasses() {
        const [category] = this.iconName.split(':');
        const isUtility = category === 'utility';
        const isDefaultOrInverse = this.variant === 'default' || this.variant === 'inverse';
        const classes = {
            [`slds-icon_${this.size}`]: !!this.size && this.size !== 'medium',
            [`slds-icon-text-${isDefaultOrInverse ? 'default' : this.variant}`]: isDefaultOrInverse ?
                (this.variant === 'default' ? isUtility : !isUtility)
                : !!this.variant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const [category, icon] = this.iconName.split(':');
        const kebabCaseName = icon.replace(/_/g, '-');
        this.hostService.updateClass(this.el, {
            [`slds-icon_container`]: category !== 'utility',
            [`slds-icon_container_circle`]: category === 'action',
            [`slds-icon-${category}-${kebabCaseName}`]: category !== 'utility' && category !== 'doctype',
        });
    }
};
NglIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglIcon.prototype, "iconName", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglIcon.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglIcon.prototype, "svgClass", void 0);
NglIcon = __decorate([
    Component({
        selector: 'ngl-icon, [ngl-icon]',
        template: "\n<svg class=\"slds-icon\" [nglIconName]=\"iconName\" [ngClass]=\"svgClasses()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, HostService])
], NglIcon);

/** Injection token that can be used to specify default options. */
const NGL_ICON_CONFIG = new InjectionToken('ngl-icon-config');
/**
 * Configuration service for the icons components.
 */
class NglIconConfig {
    constructor() {
        /**
         * The path to LDS assets
         */
        this.svgPath = 'assets/icons';
    }
}

let NglIconSvg = class NglIconSvg {
    constructor(defaultConfig, el, renderer) {
        this.xPos = '0';
        renderer.setAttribute(el.nativeElement, 'aria-hidden', 'true');
        const config = Object.assign(Object.assign({}, new NglIconConfig()), defaultConfig);
        this.path = config.svgPath;
    }
    set iconName(iconName) {
        const [category, icon] = normalizeIconName(iconName).split(':');
        this.iconPath = `${this.path}/${category}-sprite/svg/symbols.svg#${icon}`;
    }
};
NglIconSvg.ctorParameters = () => [
    { type: NglIconConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_ICON_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('nglIconName'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglIconSvg.prototype, "iconName", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglIconSvg.prototype, "xPos", void 0);
NglIconSvg = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'svg[nglIconName]',
        template: "\n<svg:use [attr.xlink:href]=\"iconPath\" [attr.x]=\"xPos\"></svg:use>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Optional()), __param(0, Inject(NGL_ICON_CONFIG)),
    __metadata("design:paramtypes", [NglIconConfig,
        ElementRef,
        Renderer2])
], NglIconSvg);

const NGL_ICON_DIRECTIVES = [
    NglIcon,
    NglIconSvg,
];
let NglIconsModule = class NglIconsModule {
};
NglIconsModule = __decorate([
    NgModule({
        declarations: NGL_ICON_DIRECTIVES,
        exports: NGL_ICON_DIRECTIVES,
        imports: [CommonModule],
    })
], NglIconsModule);

let NglInternalOutlet = class NglInternalOutlet {
    isTemplate() {
        return this.nglInternalOutlet instanceof TemplateRef;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalOutlet.prototype, "nglInternalOutlet", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalOutlet.prototype, "nglInternalOutletContext", void 0);
NglInternalOutlet = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglInternalOutlet]',
        template: `
    <ng-template [ngIf]="isTemplate()" [ngIfElse]="str">
      <ng-template [ngTemplateOutlet]="nglInternalOutlet" [ngTemplateOutletContext]="nglInternalOutletContext"></ng-template>
    </ng-template>
    <ng-template #str>{{nglInternalOutlet}}</ng-template>`,
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglInternalOutlet);

let NglInternalOutletModule = class NglInternalOutletModule {
};
NglInternalOutletModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [NglInternalOutlet],
        exports: [NglInternalOutlet],
    })
], NglInternalOutletModule);

let NglAccordionSection = class NglAccordionSection {
    constructor(templateRef) {
        this.templateRef = templateRef;
        /**
         * The unique name to use with the `activeName` of the accordion component.
         */
        this.name = uniqueId('accordion-section');
    }
};
NglAccordionSection.ctorParameters = () => [
    { type: TemplateRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "labelContext", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordionSection.prototype, "name", void 0);
NglAccordionSection = __decorate([
    Directive({
        selector: '[nglAccordionSection]',
    }),
    __metadata("design:paramtypes", [TemplateRef])
], NglAccordionSection);

function propDecoratorFactory(name, fallback) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${name} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                return this[privatePropName];
            },
            set(value) {
                this[privatePropName] = fallback(value);
            }
        });
    }
    return propDecorator;
}
function toBoolean(value) {
    return coerceBooleanProperty(value);
}
function InputBoolean() {
    return propDecoratorFactory('InputBoolean', toBoolean);
}
function toNumber(value, fallbackValue = 0) {
    return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function InputNumber() {
    return propDecoratorFactory('InputNumber', toNumber);
}

let NglAccordion = class NglAccordion {
    constructor(element, renderer) {
        this.activeNameChange = new EventEmitter();
        /**
         * Whether we allow multiple sections open at a time.
         */
        this.multiple = false;
        renderer.addClass(element.nativeElement, 'slds-accordion');
    }
    toggle(section) {
        const active = addOptionToSelection(section.name, this.activeName, this.multiple);
        this.activeNameChange.emit(active);
    }
    isActive(section) {
        return isOptionSelected(section.name, this.activeName, this.multiple);
    }
};
NglAccordion.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "activeName", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "activeNameChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglAccordion.prototype, "multiple", void 0);
__decorate([
    ContentChildren(NglAccordionSection),
    __metadata("design:type", QueryList)
], NglAccordion.prototype, "sections", void 0);
NglAccordion = __decorate([
    Component({
        selector: 'ngl-accordion,[ngl-accordion]',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<li *ngFor=\"let section of sections\" nglAccordionItem [isActive]=\"isActive(section)\" [section]=\"section\" (toggle)=\"toggle(section)\"></li>"
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglAccordion);

let NglAccordionItem = class NglAccordionItem {
    constructor(element, renderer) {
        this.toggle = new EventEmitter();
        this.uid = uniqueId('accordion-item');
        renderer.addClass(element.nativeElement, 'slds-accordion__list-item');
    }
    onToggle() {
        this.toggle.emit();
    }
};
NglAccordionItem.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NglAccordionItem.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", NglAccordionSection)
], NglAccordionItem.prototype, "section", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAccordionItem.prototype, "toggle", void 0);
NglAccordionItem = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'li[nglAccordionItem]',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<section class=\"slds-accordion__section\" [class.slds-is-open]=\"isActive\">\n  <div class=\"slds-accordion__summary\">\n    <h3 class=\"slds-accordion__summary-heading\" (click)=\"onToggle()\">\n      <button class=\"slds-button slds-button_reset slds-accordion__summary-action\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"isActive\">\n        <svg class=\"slds-accordion__summary-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"utility:switch\"></svg><span class=\"slds-truncate\" [nglInternalOutlet]=\"section.label\" [nglInternalOutletContext]=\"{$implicit: section.labelContext}\"></span>\n      </button>\n    </h3>\n  </div>\n  <div class=\"slds-accordion__content\" [attr.hidden]=\"isActive ? null : ''\" [id]=\"uid\">\n    <ng-container *ngIf=\"isActive\">\n      <ng-template [ngTemplateOutlet]=\"section.templateRef\"></ng-template>\n    </ng-container>\n  </div>\n</section>"
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglAccordionItem);

const DIRECTIVES = [
    NglAccordion,
    NglAccordionSection,
];
let NglAccordionModule = class NglAccordionModule {
};
NglAccordionModule = __decorate([
    NgModule({
        declarations: [...DIRECTIVES, NglAccordionItem],
        exports: DIRECTIVES,
        imports: [CommonModule, NglIconsModule, NglInternalOutletModule],
    })
], NglAccordionModule);

class NglCommonNotify {
    constructor(element, renderer, cd, type) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.closeButtonAssistiveText = 'Close';
        /**
         * Triggered by close button or duration timeout.
         */
        // tslint:disable-next-line:no-output-rename
        this.closeEventEmitter = new EventEmitter();
        this.currentTimeout = null;
        this.renderer.addClass(this.element.nativeElement, 'slds-notify');
        this.renderer.addClass(this.element.nativeElement, `slds-notify_${type}`);
        this.toggleThemeClass(true, this.variant);
        this.renderer.setAttribute(this.element.nativeElement, 'role', type === 'toast' ? 'status' : 'alert');
    }
    /**
     * The type of alert.
     */
    set variant(variant) {
        this.toggleThemeClass(false, this.variant);
        this._variant = variant;
        this.toggleThemeClass(true, this.variant);
    }
    get variant() {
        return this._variant || 'info';
    }
    /**
     * The number of milliseconds after which, the close event will be triggered with an emitted reason of `'timeout'`.
     */
    set duration(duration) {
        this.clearTimeout();
        if (isInt(duration) && duration >= 0) {
            this.currentTimeout = setTimeout(() => this.close('timeout'), +duration);
        }
    }
    set dismissible(dismissible) {
        this._dismissible = dismissible;
        this.cd.markForCheck();
    }
    get dismissible() {
        return this._dismissible;
    }
    close(reason, $event) {
        this.clearTimeout();
        if ($event) {
            $event.preventDefault();
            $event.stopPropagation();
        }
        this.closeEventEmitter.emit(reason);
    }
    ngOnDestroy() {
        this.clearTimeout();
    }
    clearTimeout() {
        if (this.currentTimeout !== null) {
            clearTimeout(this.currentTimeout);
            this.currentTimeout = null;
        }
    }
    toggleThemeClass(isAdd, klass) {
        if (!klass) {
            return;
        }
        const el = this.element.nativeElement;
        this.renderer[isAdd ? 'addClass' : 'removeClass'](el, `slds-theme_${klass}`);
    }
}
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglCommonNotify.prototype, "variant", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCommonNotify.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "assistiveText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "closeButtonAssistiveText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglCommonNotify.prototype, "duration", null);
__decorate([
    Output('close'),
    __metadata("design:type", Object)
], NglCommonNotify.prototype, "closeEventEmitter", void 0);

let NglAlert = class NglAlert extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'alert');
    }
};
NglAlert.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglAlert = __decorate([
    Component({
        selector: 'ngl-alert',
        template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_x-small\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"x-small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        exportAs: 'nglAlert'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglAlert);

class NglCommonNotifyClose {
    constructor(host) {
        this.host = host;
        this.host.dismissible = true;
    }
    set dismissible(dismissible) {
        this.host.dismissible = dismissible;
    }
}
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglCommonNotifyClose.prototype, "dismissible", null);

let NglAlertClose = class NglAlertClose extends NglCommonNotifyClose {
    constructor(alert) {
        super(alert);
    }
};
NglAlertClose.ctorParameters = () => [
    { type: NglAlert }
];
NglAlertClose = __decorate([
    Directive({
        // tslint:disable-next-line:directive-selector
        selector: 'ngl-alert[close]',
    }),
    __metadata("design:paramtypes", [NglAlert])
], NglAlertClose);

const NGL_ALERT_DIRECTIVES = [
    NglAlert,
    NglAlertClose,
];
let NglAlertModule = class NglAlertModule {
};
NglAlertModule = __decorate([
    NgModule({
        declarations: [NGL_ALERT_DIRECTIVES],
        exports: [NGL_ALERT_DIRECTIVES],
        imports: [CommonModule, NglIconsModule],
    })
], NglAlertModule);

let NglAvatar = class NglAvatar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.hostService = hostService;
        this.src = '';
        this.alternativeText = '';
        this.fallbackIconName = 'standard:user';
        this.error = new EventEmitter();
        this._imgError = false;
        renderer.addClass(element.nativeElement, 'slds-avatar');
    }
    fallbackIconClass() {
        const [category, icon] = this.fallbackIconName.split(':');
        return `slds-icon-${category}-${icon}`;
    }
    get shouldShowImage() {
        return this.src && !this._imgError;
    }
    onImgError() {
        this._imgError = true;
        this.error.emit();
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-avatar_${this.size || 'medium'}`]: true,
            [`slds-avatar_${this.variant || 'rectangle'}`]: true,
        });
    }
};
NglAvatar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "src", void 0);
__decorate([
    HostBinding('attr.title'),
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglAvatar.prototype, "initials", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "fallbackIconName", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglAvatar.prototype, "error", void 0);
NglAvatar = __decorate([
    Component({
        selector: 'ngl-avatar',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "<img *ngIf=\"shouldShowImage; else template_initials\" [src]=\"src\" [alt]=\"alternativeText\" (error)=\"onImgError()\">\n<ng-template #template_initials><abbr class=\"slds-avatar__initials\" [ngClass]=\"fallbackIconClass()\">{{ initials }}</abbr></ng-template>",
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglAvatar);

let NglAvatarModule = class NglAvatarModule {
};
NglAvatarModule = __decorate([
    NgModule({
        declarations: [NglAvatar],
        exports: [NglAvatar],
        imports: [CommonModule],
    })
], NglAvatarModule);

let NglBadge = class NglBadge {
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglBadge.prototype, "theme", void 0);
NglBadge = __decorate([
    Component({
        selector: 'ngl-badge',
        template: "<span class=\"slds-badge\" [ngClass]=\"theme ? 'slds-theme_' + theme : ''\">\n  <ng-content></ng-content></span>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglBadge);

let NglBadgesModule = class NglBadgesModule {
};
NglBadgesModule = __decorate([
    NgModule({
        declarations: [NglBadge],
        exports: [NglBadge],
        imports: [CommonModule],
    })
], NglBadgesModule);

let NglBreadcrumb = class NglBreadcrumb {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglBreadcrumb.ctorParameters = () => [
    { type: TemplateRef }
];
NglBreadcrumb = __decorate([
    Directive({
        selector: '[nglBreadcrumb]',
    }),
    __metadata("design:paramtypes", [TemplateRef])
], NglBreadcrumb);

let NglBreadcrumbs = class NglBreadcrumbs {
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglBreadcrumbs.prototype, "assistiveText", void 0);
__decorate([
    ContentChildren(NglBreadcrumb),
    __metadata("design:type", QueryList)
], NglBreadcrumbs.prototype, "breadcrumbs", void 0);
NglBreadcrumbs = __decorate([
    Component({
        selector: 'ngl-breadcrumbs',
        template: "\n<nav role=\"navigation\" [attr.aria-label]=\"assistiveText\">\n  <ol class=\"slds-breadcrumb slds-list_horizontal slds-wrap\">\n    <li class=\"slds-breadcrumb__item\" *ngFor=\"let b of breadcrumbs\">\n      <ng-template [ngTemplateOutlet]=\"b.templateRef\"></ng-template>\n    </li>\n  </ol>\n</nav>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglBreadcrumbs);

const NGL_BREADCRUMB_DIRECTIVES = [
    NglBreadcrumbs,
    NglBreadcrumb,
];
let NglBreadcrumbsModule = class NglBreadcrumbsModule {
};
NglBreadcrumbsModule = __decorate([
    NgModule({
        declarations: [NGL_BREADCRUMB_DIRECTIVES],
        exports: [NGL_BREADCRUMB_DIRECTIVES],
        imports: [CommonModule],
    })
], NglBreadcrumbsModule);

let NglButtonIcon = class NglButtonIcon {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * The variant changes the appearance of the button
         */
        this.variant = 'border';
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    iconClass() {
        const hasVariant = this.hasVariant();
        const classes = {
            [`slds-button__icon_${this.size}`]: !hasVariant,
        };
        return ngClassCombine(this.svgClass, classes);
    }
    setHostClass() {
        const hasVariant = this.hasVariant();
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant}`]: hasVariant,
            [`slds-button_icon-${this.size}`]: this.size && hasVariant,
        });
    }
    hasVariant() {
        return this.variant && this.variant !== 'bare';
    }
};
NglButtonIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIcon.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIcon.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIcon.prototype, "svgClass", void 0);
NglButtonIcon = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglButtonIcon]',
        template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\" [ngClass]=\"iconClass()\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, HostService, Renderer2])
], NglButtonIcon);

const DEFAULT_VARIANT = 'border';
let NglButtonIconStateful = class NglButtonIconStateful {
    constructor(el, hostService, renderer) {
        this.el = el;
        this.hostService = hostService;
        /**
         * Specifies whether button is in selected state or not.
         */
        this.selected = false;
        this.selectedChange = new EventEmitter();
        /**
         * The variant changes the appearance of the button.
         */
        this.variant = DEFAULT_VARIANT;
        /**
         *  The size of the button.
         */
        this.size = null;
        renderer.addClass(this.el.nativeElement, 'slds-button');
        renderer.addClass(this.el.nativeElement, 'slds-button_icon');
    }
    get altText() {
        return this.alternativeText || this.title;
    }
    onclick() {
        this.selectedChange.emit(!this.selected);
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_icon-${this.variant || DEFAULT_VARIANT}`]: true,
            [`slds-button_icon-${this.size}`]: !!this.size,
        });
    }
};
NglButtonIconStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: HostService },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.slds-is-selected'),
    HostBinding('attr.aria-pressed'),
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "selected", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "selectedChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglButtonIconStateful.prototype, "alternativeText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonIconStateful.prototype, "size", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglButtonIconStateful.prototype, "onclick", null);
NglButtonIconStateful = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglButtonIconStateful]',
        template: "\n<svg class=\"slds-button__icon\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content><span class=\"slds-assistive-text\" *ngIf=\"altText as text\">{{ text }}</span>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, HostService, Renderer2])
], NglButtonIconStateful);

const NGL_BUTTON_ICON_DIRECTIVES = [
    NglButtonIcon,
    NglButtonIconStateful,
];
let NglButtonIconsModule = class NglButtonIconsModule {
};
NglButtonIconsModule = __decorate([
    NgModule({
        declarations: NGL_BUTTON_ICON_DIRECTIVES,
        exports: NGL_BUTTON_ICON_DIRECTIVES,
        imports: [CommonModule, NglIconsModule],
    })
], NglButtonIconsModule);

let NglButton = class NglButton {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Changes the appearance of the button.
         */
        this.variant = 'neutral';
        /**
         * Describes the position of the icon with respect to ng-content.
         */
        this.iconPosition = 'left';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges(changes) {
        if (changes.variant) {
            this.setHostClass();
        }
    }
    hasLeftIcon() {
        return this.iconName && (!this.iconPosition || this.iconPosition === 'left');
    }
    hasRightIcon() {
        return this.iconName && this.iconPosition === 'right';
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant}`]: this.variant && this.variant !== 'base',
        });
    }
};
NglButton.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "iconName", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButton.prototype, "iconPosition", void 0);
NglButton = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglButton]',
        template: "\n<svg class=\"slds-button__icon slds-button__icon_left\" *ngIf=\"hasLeftIcon()\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>\n<svg class=\"slds-button__icon slds-button__icon_right\" *ngIf=\"hasRightIcon()\" [nglIconName]=\"iconName\"></svg>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglButton);

let NglButtonStateful = class NglButtonStateful {
    constructor(el, renderer, hostService) {
        this.el = el;
        this.renderer = renderer;
        this.hostService = hostService;
        /**
         * Triggered when the button is clicked.
         */
        this.stateChange = new EventEmitter();
        /**
         * Appearance.
         */
        this.variant = 'neutral';
        this.renderer.addClass(this.el.nativeElement, 'slds-button');
        this.renderer.addClass(this.el.nativeElement, 'slds-button_stateful');
        this.renderer.setAttribute(this.el.nativeElement, 'aria-live', 'assertive');
    }
    onSelectChange() {
        this.stateChange.emit(!this.state);
    }
    onFocusToggle(focused) {
        this.focused = !!+focused;
        if (!this.focused) {
            this.setHostClass();
        }
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.el, {
            [`slds-button_${this.variant === 'text' ? 'reset' : this.variant}`]: !!this.variant,
            [`slds-is-selected-clicked`]: this.state && this.focused,
            [`slds-is-selected`]: this.state && !this.focused,
            [`slds-not-selected`]: !this.state,
        });
    }
};
NglButtonStateful.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglButtonStateful.prototype, "state", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglButtonStateful.prototype, "stateChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonStateful.prototype, "variant", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglButtonStateful.prototype, "onSelectChange", null);
__decorate([
    HostListener('focus', ['1']),
    HostListener('blur', ['0']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NglButtonStateful.prototype, "onFocusToggle", null);
NglButtonStateful = __decorate([
    Directive({
        selector: '[nglButtonStateful]',
        providers: [HostService],
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglButtonStateful);

let NglButtonStateOn = class NglButtonStateOn {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, this.getHostClass());
    }
    getHostClass() {
        return 'slds-text-selected';
    }
};
NglButtonStateOn.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglButtonStateOn.prototype, "iconName", void 0);
NglButtonStateOn = __decorate([
    Component({
        selector: 'ngl-state-on',
        template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglButtonStateOn);
let NglButtonStateOff = class NglButtonStateOff extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-not-selected';
    }
};
NglButtonStateOff = __decorate([
    Component({
        selector: 'ngl-state-off',
        template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglButtonStateOff);
let NglButtonStateHover = class NglButtonStateHover extends NglButtonStateOn {
    getHostClass() {
        return 'slds-text-selected-focus';
    }
};
NglButtonStateHover = __decorate([
    Component({
        selector: 'ngl-state-hover',
        template: "\n<svg class=\"slds-button__icon slds-button__icon_small slds-button__icon_left\" *ngIf=\"iconName\" [nglIconName]=\"iconName\"></svg>\n<ng-content></ng-content>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglButtonStateHover);

const NGL_BUTTON_DIRECTIVES = [
    NglButton,
    NglButtonStateful,
    NglButtonStateOn,
    NglButtonStateOff,
    NglButtonStateHover
];
let NglButtonsModule = class NglButtonsModule {
};
NglButtonsModule = __decorate([
    NgModule({
        declarations: NGL_BUTTON_DIRECTIVES,
        exports: NGL_BUTTON_DIRECTIVES,
        imports: [CommonModule, NglIconsModule],
    })
], NglButtonsModule);

let NglCarouselImage = class NglCarouselImage {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.uid = uniqueId('carousel-image');
        this.renderer.setAttribute(this.el.nativeElement, 'id', this.uid);
        this.renderer.addClass(this.el.nativeElement, 'slds-carousel__panel');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'tabpanel');
    }
    set labelledby(labelledby) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-labelledby', labelledby);
    }
    set active(active) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-hidden', `${!active}`);
    }
};
NglCarouselImage.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "src", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCarouselImage.prototype, "description", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCarouselImage.prototype, "alternativeText", void 0);
NglCarouselImage = __decorate([
    Component({
        selector: 'ngl-carousel-image',
        template: "<a class=\"slds-carousel__panel-action slds-text-link_reset\" href=\"javascript:void(0);\" [attr.tabindex]=\"active ? 0 : -1\">\n  <div class=\"slds-carousel__image\"><img [src]=\"src\" [attr.alt]=\"alternativeText || null\"></div>\n  <div class=\"slds-carousel__content\">\n    <h2 class=\"slds-carousel__content-title\" [nglInternalOutlet]=\"header\"></h2>\n    <p [nglInternalOutlet]=\"description\"></p>\n  </div></a>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglCarouselImage);

let NglCarouselIndicator = class NglCarouselIndicator {
    constructor(el) {
        this.el = el;
        this.uid = uniqueId('carousel-indicator');
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    ngOnChanges(changes) {
        this.image.active = this.isActive;
        if (changes.image) {
            this.image.labelledby = this.uid;
        }
    }
    focus() {
        this.el.nativeElement.focus();
    }
};
NglCarouselIndicator.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('class.slds-is-active'),
    HostBinding('attr.aria-selected'),
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarouselIndicator.prototype, "isActive", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglCarouselIndicator.prototype, "tabindex", null);
__decorate([
    Input(),
    __metadata("design:type", NglCarouselImage)
], NglCarouselIndicator.prototype, "image", void 0);
__decorate([
    HostBinding('attr.id'),
    __metadata("design:type", Object)
], NglCarouselIndicator.prototype, "uid", void 0);
NglCarouselIndicator = __decorate([
    Directive({
        selector: '[nglCarouselIndicator]',
    }),
    __metadata("design:paramtypes", [ElementRef])
], NglCarouselIndicator);

let NglCarousel = class NglCarousel {
    constructor(document) {
        this.document = document;
        this.activeChange = new EventEmitter();
        /**
         * The auto scroll duration in seconds. After that the next image is displayed.
         */
        this.scrollDuration = 5;
        /**
         * Whether auto scroll is enabled.
         */
        this.autoScroll = true;
        /**
         * Whether the carousel should continue looping from the beginning after the last item is displayed.
         */
        this.autoRefresh = true;
        this.labels = {
            startAutoPlay: 'Start auto-play',
            stopAutoPlay: 'Stop auto-play',
        };
        this.playing = true;
        this.nextTimer = null;
    }
    isActive(index) {
        return index === this.active;
    }
    getImage(index) {
        return this.images.toArray()[index];
    }
    ngOnChanges(changes) {
        if (changes.active) {
            // Focus correct indicator if one is already focused
            if (this.document && this.indicatorsEl.nativeElement.contains(document.activeElement)) {
                this.indicators.toArray()[this.active].focus();
            }
        }
        if (changes.active || changes.autoScroll || changes.scrollDuration) {
            // Reset timer when active changes
            this.setTimer();
        }
    }
    onIndicatorClick(index) {
        this.setActive(index, true);
    }
    onKeyboard(evt) {
        if (evt.keyCode === LEFT_ARROW || evt.keyCode === RIGHT_ARROW) {
            this.activateNext(evt.keyCode === LEFT_ARROW);
        }
    }
    setActive(index, stopPlaying = false) {
        if (stopPlaying) {
            this.playing = false;
        }
        if (this.active !== index) {
            this.activeChange.emit(index);
        }
    }
    togglePlay() {
        this.playing = !this.playing;
        this.setTimer();
    }
    playLabel() {
        return this.labels[this.playing ? 'stopAutoPlay' : 'startAutoPlay'];
    }
    activateNext(reverse = false) {
        const active = this.active + (reverse ? -1 : 1);
        if ((active < 0 || active > this.images.length - 1) && !this.autoRefresh) {
            return;
        }
        this.setActive((this.images.length + active) % this.images.length);
    }
    setTimer() {
        clearTimeout(this.nextTimer);
        if (this.autoScroll && this.playing) {
            this.nextTimer = setTimeout(() => {
                this.activateNext();
            }, this.scrollDuration * 1000);
        }
    }
};
NglCarousel.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "active", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "activeChange", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "scrollDuration", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoScroll", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "autoRefresh", void 0);
__decorate([
    ContentChildren(NglCarouselImage),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "images", void 0);
__decorate([
    ViewChildren(NglCarouselIndicator),
    __metadata("design:type", QueryList)
], NglCarousel.prototype, "indicators", void 0);
__decorate([
    ViewChild('indicatorsEl', { static: true }),
    __metadata("design:type", ElementRef)
], NglCarousel.prototype, "indicatorsEl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCarousel.prototype, "labels", void 0);
NglCarousel = __decorate([
    Component({
        selector: 'ngl-carousel',
        template: "\n<div class=\"slds-carousel__stage\"><span class=\"slds-carousel__autoplay\" *ngIf=\"autoScroll\">\n    <button class=\"slds-button slds-button_icon slds-button_icon-border-filled slds-button_icon-x-small\" [attr.aria-pressed]=\"!playing\" [title]=\"playLabel()\" (click)=\"togglePlay()\">\n      <svg class=\"slds-button__icon\" [nglIconName]=\"playing ? 'utility:pause' : 'utility:right'\"></svg><span class=\"slds-assistive-text\">{{ playLabel() }}</span>\n    </button></span>\n  <div class=\"slds-carousel__panels\" [style.transform]=\"'translateX(' + (-active * 100) + '%)'\">\n    <ng-content></ng-content>\n  </div>\n  <ul class=\"slds-carousel__indicators\" #indicatorsEl role=\"tablist\" (keydown)=\"onKeyboard($event)\">\n    <li class=\"slds-carousel__indicator\" *ngFor=\"let image of images; let i = index\" role=\"presentation\"><a class=\"slds-carousel__indicator-action\" nglCarouselIndicator href=\"javascript:void(0);\" role=\"tab\" [isActive]=\"isActive(i)\" [image]=\"getImage(i)\" [attr.aria-controls]=\"image.uid\" [title]=\"image.header\" (click)=\"onIndicatorClick(i)\"><span class=\"slds-assistive-text\">{{ image.header }}</span></a></li>\n  </ul>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-carousel]': 'true',
        }
    }),
    __param(0, Optional()), __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglCarousel);

const DIRECTIVES$1 = [
    NglCarousel,
    NglCarouselImage,
];
let NglCarouselModule = class NglCarouselModule {
};
NglCarouselModule = __decorate([
    NgModule({
        declarations: [...DIRECTIVES$1, NglCarouselIndicator],
        exports: DIRECTIVES$1,
        imports: [CommonModule, NglIconsModule, NglInternalOutletModule],
    })
], NglCarouselModule);

let NglCheckboxInput = class NglCheckboxInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.RequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('checkbox'));
        }
    }
    set describedBy(value) {
        this.renderer.setAttribute(this.el.nativeElement, 'aria-describedby', value);
    }
    set required(required) {
        this.RequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
    addClass(klass) {
        this.renderer.addClass(this.el.nativeElement, klass);
    }
};
NglCheckboxInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglCheckboxInput.prototype, "required", null);
NglCheckboxInput = __decorate([
    Directive({
        selector: 'input[ngl][type=checkbox]',
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglCheckboxInput);

let NglCheckboxButton = class NglCheckboxButton {
    constructor(cd) {
        this.cd = cd;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside ${this}`);
        }
        this._uid = this.input.id;
        this.cd.detectChanges();
        this.input.addClass('slds-assistive-text');
    }
};
NglCheckboxButton.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxButton.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxButton.prototype, "label", void 0);
NglCheckboxButton = __decorate([
    Component({
        selector: 'ngl-checkbox-button',
        template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox_faux\" [attr.for]=\"_uid\"><span class=\"slds-assistive-text\" [nglInternalOutlet]=\"label\"></span></label>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-checkbox_add-button]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckboxButton);

let NglCheckbox = class NglCheckbox {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckbox`);
        }
        this.RequiredSubscription = this.input.RequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.RequiredSubscription) {
            this.RequiredSubscription.unsubscribe();
            this.RequiredSubscription = null;
        }
    }
};
NglCheckbox.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckbox.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckbox.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckbox.prototype, "error", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCheckbox.prototype, "stacked", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckbox.prototype, "hasError", null);
NglCheckbox = __decorate([
    Component({
        selector: 'ngl-checkbox,[ngl-checkbox]',
        template: "\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox\" [class.slds-checkbox_stacked]=\"stacked\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr>\n    <ng-content></ng-content>\n    <label class=\"slds-checkbox__label\" [attr.for]=\"_uid\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckbox);

let NglCheckboxToggle = class NglCheckboxToggle {
    constructor(cd) {
        this.cd = cd;
        this.enabledText = 'Enabled';
        this.disabledText = 'Disabled';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input type="checkbox"> with [ngl] attribute inside NglCheckboxToggle`);
        }
        this.RequiredSubscription = this.input.RequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this.uid = `${this.input.id}_toggle`;
        this.input.describedBy = this.uid;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.RequiredSubscription) {
            this.RequiredSubscription.unsubscribe();
            this.RequiredSubscription = null;
        }
    }
};
NglCheckboxToggle.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxToggle.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCheckboxToggle.prototype, "error", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "enabledText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxToggle.prototype, "disabledText", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckboxToggle.prototype, "hasError", null);
NglCheckboxToggle = __decorate([
    Component({
        selector: 'ngl-checkbox-toggle',
        template: "\n<label class=\"slds-checkbox_toggle slds-grid\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span class=\"slds-form-element__label slds-m-bottom_none\" [nglInternalOutlet]=\"label\"></span>\n  <ng-content></ng-content><span class=\"slds-checkbox_faux_container\" [id]=\"uid\" aria-live=\"assertive\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-checkbox_on\">{{enabledText}}</span><span class=\"slds-checkbox_off\">{{disabledText}}</span></span>\n</label>\n<div class=\"slds-form-element__help\" *ngIf=\"error\">{{error}}</div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglCheckboxToggle);

let NglCheckboxOption = class NglCheckboxOption {
    constructor(cd, element, hostService) {
        this.cd = cd;
        this.element = element;
        this.hostService = hostService;
    }
    set type(type) {
        this._type = type;
        this.setHostClass();
        this.cd.detectChanges();
    }
    get type() {
        return this._type;
    }
    setError(id) {
        this.input.describedBy = id;
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-checkbox`]: this.type === 'list',
            [`slds-button`]: this.type === 'button',
            [`slds-checkbox_button`]: this.type === 'button',
        });
    }
};
NglCheckboxOption.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxOption.prototype, "label", void 0);
__decorate([
    ContentChild(NglCheckboxInput, { static: true }),
    __metadata("design:type", NglCheckboxInput)
], NglCheckboxOption.prototype, "input", void 0);
NglCheckboxOption = __decorate([
    Component({
        selector: 'ngl-checkbox-option',
        template: "\n<ng-content></ng-content>\n<label class=\"slds-checkbox__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-checkbox_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-checkbox_faux\" [nglInternalOutlet]=\"label\"></span></label>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef, ElementRef, HostService])
], NglCheckboxOption);

let NglCheckboxGroup = class NglCheckboxGroup {
    constructor() {
        this.uid = uniqueId('checkbox-group');
        this._type = 'list';
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    set type(type) {
        this._type = type;
        this.updateChildrenType();
    }
    get type() {
        return this._type;
    }
    ngOnChanges(changes) {
        if (changes.error && this.options) {
            this.options.forEach((option) => {
                option.setError(this.error ? this.errorId : null);
            });
        }
    }
    ngAfterContentInit() {
        this.updateChildrenType();
    }
    updateChildrenType() {
        if (!this.options) {
            return;
        }
        this.options.forEach((option) => {
            option.type = this.type;
        });
    }
};
__decorate([
    ContentChildren(NglCheckboxOption),
    __metadata("design:type", QueryList)
], NglCheckboxGroup.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxGroup.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCheckboxGroup.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglCheckboxGroup.prototype, "hasError", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCheckboxGroup.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglCheckboxGroup.prototype, "type", null);
NglCheckboxGroup = __decorate([
    Component({
        selector: 'ngl-checkbox-group,[ngl-checkbox-group]',
        template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-checkbox_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    })
], NglCheckboxGroup);

const DIRECTIVES$2 = [
    NglCheckboxButton,
    NglCheckbox,
    NglCheckboxToggle,
    NglCheckboxInput,
    NglCheckboxGroup,
    NglCheckboxOption,
];
let NglCheckboxesModule = class NglCheckboxesModule {
};
NglCheckboxesModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$2,
        exports: DIRECTIVES$2,
        imports: [CommonModule, NglInternalOutletModule],
    })
], NglCheckboxesModule);

/*
 * <ng-template ngl-tab label="...">
 *    Content goes here...
 * </ng-template>
 */
let NglTab = class NglTab {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.uid = uniqueId('tab');
        this._active = false;
    }
    set active(active) {
        if (active === this._active) {
            return;
        }
        this._active = active;
        if (active) {
            this.activate.emit(this);
        }
        else {
            this.deactivate.emit(this);
        }
    }
    get active() {
        return this._active;
    }
};
NglTab.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglTab.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTab.prototype, "label", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTab.prototype, "activate", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTab.prototype, "deactivate", void 0);
NglTab = __decorate([
    Directive({
        // tslint:disable-next-line:directive-selector
        selector: '[ngl-tab]',
        exportAs: 'nglTab',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], NglTab);

let NglTabs = class NglTabs {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        /**
         * Whether every tab's content is instantiated when visible, and destroyed when hidden.
         */
        this.lazy = true;
        this.renderer.addClass(this.element.nativeElement, `slds-tabs_${this.variant}`);
    }
    set variant(variant) {
        const el = this.element.nativeElement;
        this.renderer.removeClass(el, `slds-tabs_${this.variant}`);
        this._variant = variant;
        this.renderer.addClass(el, `slds-tabs_${this.variant}`);
    }
    get variant() {
        return this._variant || 'default';
    }
    set setSelected(selected) {
        if (selected === this.selected) {
            return;
        }
        this.selected = selected;
        if (!this.tabs) {
            return;
        } // Wait for content to initialize
        this.activate();
    }
    ngAfterContentInit() {
        // Initial selection after all tabs are created
        this.activate();
        if (!this.activeTab) {
            setTimeout(() => this.select(this.tabs.first));
        }
    }
    select(tab) {
        this.selectedChange.emit(tab);
    }
    move(evt, moves) {
        evt.preventDefault();
        const tabs = this.tabs.toArray();
        const selectedIndex = tabs.indexOf(this.activeTab);
        this.select(tabs[(tabs.length + selectedIndex + moves) % tabs.length]);
    }
    tabClass(tab) {
        return {
            [`slds-tabs_${this.variant}__content`]: true,
            [`slds-${tab.active ? 'show' : 'hide'}`]: true,
        };
    }
    trackByTab(index, tab) {
        return tab.uid;
    }
    activate() {
        if (this.activeTab) {
            this.activeTab.active = false;
        }
        this.activeTab = this.findTab();
        if (this.activeTab) {
            this.activeTab.active = true;
        }
    }
    findTab(value = this.selected) {
        if (value instanceof NglTab) {
            return value;
        }
        if (isInt(value)) {
            return this.tabs.toArray()[+value];
        }
        return this.tabs.toArray().find((t) => {
            return t.id && t.id === value;
        });
    }
};
NglTabs.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglTabs.prototype, "variant", null);
__decorate([
    ContentChildren(NglTab),
    __metadata("design:type", QueryList)
], NglTabs.prototype, "tabs", void 0);
__decorate([
    Input('selected'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTabs.prototype, "setSelected", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTabs.prototype, "selectedChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglTabs.prototype, "lazy", void 0);
NglTabs = __decorate([
    Component({
        selector: 'ngl-tabset',
        template: "\n<ul [ngClass]=\"'slds-tabs_' + variant + '__nav'\" role=\"tablist\" (keydown.ArrowLeft)=\"move($event, -1)\" (keydown.ArrowRight)=\"move($event, 1)\">\n  <li *ngFor=\"let tab of tabs; trackBy: trackByTab\" [ngClass]=\"'slds-tabs_' + variant + '__item'\" [class.slds-is-active]=\"tab.active\" [id]=\"tab.uid + '__item'\" [attr.aria-controls]=\"tab.uid\" (click)=\"select(tab)\" role=\"presentation\"><a [nglInternalOutlet]=\"tab.label\" [ngClass]=\"'slds-tabs_' + variant + '__link'\" role=\"tab\" [attr.aria-selected]=\"tab.active\" [attr.tabindex]=\"tab.active ? 0 : -1\"></a></li>\n</ul>\n<div *ngFor=\"let tab of tabs; trackBy: trackByTab\" [id]=\"tab.uid\" [attr.aria-labelledby]=\"tab.uid + '__item'\" [ngClass]=\"tabClass(tab)\" role=\"tabpanel\">\n  <ng-container *ngIf=\"!lazy || tab.active\">\n    <ng-template [ngTemplateOutlet]=\"tab?.templateRef\"></ng-template>\n  </ng-container>\n</div>"
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglTabs);

var NglTabVerbose_1;
/*
 * <ngl-tab [label="..."]>
 *    <ng-template ngl-tab-label>...</ng-template>
 *    <ng-template ngl-tab-content>
 *       Content goes here...
 *    </ng-template>
 * </ngl-tab>
 */
// tslint:disable-next-line:directive-selector
let NglTabLabel = class NglTabLabel {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglTabLabel.ctorParameters = () => [
    { type: TemplateRef }
];
NglTabLabel = __decorate([
    Directive({ selector: '[ngl-tab-label]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglTabLabel);
// tslint:disable-next-line:directive-selector
let NglTabContent = class NglTabContent {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglTabContent.ctorParameters = () => [
    { type: TemplateRef }
];
NglTabContent = __decorate([
    Directive({ selector: '[ngl-tab-content]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglTabContent);
let NglTabVerbose = NglTabVerbose_1 = class NglTabVerbose extends NglTab {
    ngAfterContentInit() {
        if (this.labelTemplate) {
            this.label = this.labelTemplate.templateRef;
        }
        this.templateRef = this.contentTemplate.templateRef;
    }
};
__decorate([
    ContentChild(NglTabContent),
    __metadata("design:type", NglTabContent)
], NglTabVerbose.prototype, "contentTemplate", void 0);
__decorate([
    ContentChild(NglTabLabel),
    __metadata("design:type", NglTabLabel)
], NglTabVerbose.prototype, "labelTemplate", void 0);
NglTabVerbose = NglTabVerbose_1 = __decorate([
    Directive({
        // tslint:disable-next-line:directive-selector
        selector: 'ngl-tab',
        providers: [{ provide: NglTab, useExisting: NglTabVerbose_1 }],
    })
], NglTabVerbose);

const NGL_TAB_DIRECTIVES = [
    NglTabs,
    NglTab,
    NglTabVerbose, NglTabContent, NglTabLabel,
];
let NglTabsModule = class NglTabsModule {
};
NglTabsModule = __decorate([
    NgModule({
        declarations: [NGL_TAB_DIRECTIVES],
        exports: [NGL_TAB_DIRECTIVES],
        imports: [CommonModule, NglInternalOutletModule],
    })
], NglTabsModule);

const POSITION_MAP = {
    'top': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'center', overlayY: 'bottom' }),
        nubbin: 'bottom'
    },
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left'
    },
    'top-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'bottom-left-corner'
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right'
    },
    'top-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'bottom-right-corner'
    },
    'right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' }),
        nubbin: 'left'
    },
    'right-top': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top'
    },
    'right-top-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'left-top-corner'
    },
    'right-bottom': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom'
    },
    'right-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'bottom' }),
        nubbin: 'left-bottom-corner'
    },
    'bottom': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'center', overlayY: 'top' }),
        nubbin: 'top'
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left'
    },
    'bottom-left-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
        nubbin: 'top-left-corner'
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right'
    },
    'bottom-right-corner': {
        position: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'top-right-corner'
    },
    'left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' }),
        nubbin: 'right'
    },
    'left-top': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top'
    },
    'left-top-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'top' }),
        nubbin: 'right-top-corner'
    },
    'left-bottom': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom'
    },
    'left-bottom-corner': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'bottom' }),
        nubbin: 'right-bottom-corner'
    }
};
const DROPDOWN_POSITION_MAP = {
    'top-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    },
    'bottom-left': {
        position: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    },
    'bottom-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
    },
    'top-right': {
        position: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    },
};
const 0 = (p) => DROPDOWN_POSITION_MAP[p].position, 1 = (p) => DROPDOWN_POSITION_MAP[p].position;
const DEFAULT_DROPDOWN_POSITIONS = {
    left: [`bottom-left`, `top-left`].map(0),
    right: [`bottom-right`, `top-right`].map(1),
};
const 2 = (placement) => POSITION_MAP[placement].position;
const DEFAULT_TOOLTIP_POSITIONS = ['top', 'right', 'bottom', 'left'].map(2);
const DEFAULT_POPOVER_POSITIONS = DEFAULT_TOOLTIP_POSITIONS;
function getPlacementName(position, initialPlacement) {
    const keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
    for (const placement in POSITION_MAP) {
        if (keyList.every(key => position.connectionPair[key] === POSITION_MAP[placement]['position'][key])) {
            if (initialPlacement && initialPlacement === `${placement}-corner`) {
                return initialPlacement;
            }
            return placement;
        }
    }
}
function getPlacementStyles(nubbin) {
    const [direction, align, corner] = nubbin.split('-');
    return {
        [direction]: '1rem',
        [align]: corner ? '-0.75rem' : (align ? '-1.5rem' : false),
    };
}

function isTemplateRef(value) {
    return value instanceof TemplateRef;
}

function OnChange(callback = 'nglOnPropertyChange') {
    const cachedValueKey = Symbol();
    const isFirstChangeKey = Symbol();
    return (target, key) => {
        Object.defineProperty(target, key, {
            set: function (value) {
                // change status of "isFirstChange"
                if (this[isFirstChangeKey] === undefined) {
                    this[isFirstChangeKey] = true;
                }
                else {
                    this[isFirstChangeKey] = false;
                }
                // No operation if new value is same as old value
                if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                    return;
                }
                const oldValue = this[cachedValueKey];
                this[cachedValueKey] = value;
                const simpleChange = {
                    firstChange: this[isFirstChangeKey],
                    previousValue: oldValue,
                    currentValue: this[cachedValueKey],
                    isFirstChange: () => this[isFirstChangeKey],
                };
                this[callback](key, this[cachedValueKey], simpleChange);
            },
            get: function () {
                return this[cachedValueKey];
            },
        });
    };
}

let NglPopover = class NglPopover {
    constructor(hostService, element, renderer, focusTrapFactory, cd) {
        this.hostService = hostService;
        this.element = element;
        this.renderer = renderer;
        this.focusTrapFactory = focusTrapFactory;
        this.cd = cd;
        this.close = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.uid = uniqueId('popover');
    }
    get labelledby() {
        return this.header ? `${this.uid}-heading` : null;
    }
    get describedby() {
        return this.template ? this.uid : null;
    }
    ngOnInit() {
        this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
        this.focusTrap.focusInitialElementWhenReady();
    }
    ngOnDestroy() {
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
    }
    nglOnPropertyChange(prop) {
        if (prop === 'size' || prop === 'popoverClass') {
            this.setHostClass();
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'variant') {
            this.inverseCloseButton = ['walkthrough', 'feature', 'error'].indexOf(this.variant) > -1;
            this.setHostClass();
        }
    }
    markForCheck() {
        this.cd.markForCheck();
    }
    onClose() {
        this.close.emit();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.popoverClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
            [`slds-popover_${this.size}`]: !!this.size,
            [`slds-popover_walkthrough`]: this.variant === 'feature',
            [`slds-popover_${this.variant}`]: !!this.variant,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
};
NglPopover.ctorParameters = () => [
    { type: HostService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: FocusTrapFactory },
    { type: ChangeDetectorRef }
];
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglPopover.prototype, "popoverClass", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "size", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "variant", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglPopover.prototype, "placement", void 0);
__decorate([
    HostBinding('attr.aria-labelledby'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglPopover.prototype, "labelledby", null);
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglPopover.prototype, "describedby", null);
NglPopover = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'section[ngl-popover]',
        template: "\n<button class=\"slds-button slds-button_icon slds-button_icon-small slds-float_right slds-popover__close\" *ngIf=\"canClose &amp;&amp; closeVisible\" [title]=\"closeTitle\" [class.slds-button_icon-inverse]=\"inverseCloseButton\" (click)=\"onClose()\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeTitle\">{{closeTitle}}</span>\n</button>\n<header class=\"slds-popover__header\" *ngIf=\"header\">\n  <div *ngIf=\"isTemplateRef(header); else defaultTpl\" [id]=\"labelledby\">\n    <ng-container [ngTemplateOutlet]=\"header\"></ng-container>\n  </div>\n  <ng-template #defaultTpl>\n    <h2 class=\"slds-text-heading_small\" [id]=\"labelledby\">{{header}}</h2>\n  </ng-template>\n</header>\n<div class=\"slds-popover__body\" [id]=\"uid\" [nglInternalOutlet]=\"template\"></div>\n<footer class=\"slds-popover__footer\" *ngIf=\"footer\" [nglInternalOutlet]=\"footer\"></footer>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService],
        host: {
            'role': 'dialog',
            '[class.slds-popover]': 'true',
        }
    }),
    __metadata("design:paramtypes", [HostService,
        ElementRef,
        Renderer2,
        FocusTrapFactory,
        ChangeDetectorRef])
], NglPopover);

function hasObservers(output) {
    function propDecorator(target, propName) {
        const privatePropName = `$$__${propName}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`[ng-lightning]: The prop "${privatePropName}" already exists, it will be overridden by ${propName} decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, propName, {
            get() {
                if (!(this[output] instanceof EventEmitter)) {
                    throw Error(`[ng-lightning] ${target.constructor.name}: "${output}" is not an EventEmitter`);
                }
                return this[output].observers.length > 0;
            },
            set() {
                console.warn(`[ng-lightning] ${target.constructor.name}: "${propName}" is readonly and cannot be assigned a value`);
            }
        });
    }
    return propDecorator;
}

let NglPopoverTrigger = class NglPopoverTrigger {
    constructor(element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Close button title (and assistive text).
         */
        this.closeTitle = 'Close dialog';
        /**
           * Whether or not to override the close button's visibility, if `nglPopoverOpenChange` is set.
           */
        this.closeVisible = true;
        /** Emit an event when actual popover is shown or hidden */
        this.nglPopoverOpenChange = new EventEmitter();
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'header',
            'footer',
            'placement',
            'variant',
            'size',
            'closeTitle',
            'canClose',
            'popoverClass',
            'closeVisible',
        ]);
        this._placement = 'top';
        this.backdrop = new Subject();
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    /**
     * Position relative to host element.
     */
    set placement(_placement) {
        _placement = _placement || 'top';
        if (_placement === this._placement) {
            return;
        }
        this._placement = _placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement;
    }
    /**
     * Whether the floating popover is visible.
     */
    set nglOpen(_open) {
        _open = toBoolean(_open) && (['backdrop', 'x', 'escape'].indexOf(_open) === -1);
        _open ? this.create() : this.detach();
        this._open = _open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (changes.nglOpen && !changes.nglOpen.firstChange) {
            const open = changes.nglOpen.currentValue;
            if (!toBoolean(open) || open === 'x' || open === 'escape') {
                this.element.nativeElement.focus();
            }
        }
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
            this.popover.markForCheck();
        }
    }
    onclick(evt) {
        evt.preventDefault();
        this.toggle();
    }
    ngOnDestroy() {
        this.detach();
        this.close();
    }
    open() {
        if (!this.nglOpen) {
            this.nglPopoverOpenChange.emit(true);
        }
    }
    close(reason = false) {
        if (this.nglOpen) {
            this.nglPopoverOpenChange.emit(reason);
        }
    }
    toggle() {
        this.nglOpen ? this.close() : this.open();
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglPopover, this.viewContainerRef);
        this.popover = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updatePopover(property, this[property]));
        this.popover.markForCheck();
        this.clearGlobalClickTimeout();
        this.globalClickTimeout = setTimeout(() => {
            this.subscribeToClickEvents();
        });
        this.closeSubscription = this.popoverClosingActions()
            .subscribe(reason => this.close(reason));
    }
    /** Detaches the currently attached popover. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        this.unsubscribeFromClickEvents();
        if (this.closeSubscription) {
            this.closeSubscription.unsubscribe();
            this.closeSubscription = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.popover = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updatePopover('placement', placement);
            this.popover.markForCheck();
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current popover. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_POPOVER_POSITIONS,
        ]);
    }
    updatePopover(key, value) {
        this.popover[key] = value;
    }
    /** Set inputs of child components when this component's inputs change. */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updatePopover(key, this[key]));
    }
    /** Returns a stream that emits whenever an action that should close the popover occurs. */
    popoverClosingActions() {
        const backdrop = this.backdrop.pipe(mapTo('backdrop'));
        const close = this.popover.close.pipe(mapTo('x'));
        const escape = this.overlayRef.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE), mapTo('escape'));
        return merge(backdrop, close, escape);
    }
    handleGlobalClickEvent($event) {
        if ($event.$nglStop) {
            return;
        }
        this.backdrop.next();
    }
    subscribeToClickEvents() {
        this.unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.popover.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
};
NglPopoverTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
__decorate([
    Input('nglPopover'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "template", void 0);
__decorate([
    Input('nglPopoverHeader'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "header", void 0);
__decorate([
    Input('nglPopoverFooter'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "footer", void 0);
__decorate([
    Input('nglPopoverVariant'),
    __metadata("design:type", String)
], NglPopoverTrigger.prototype, "variant", void 0);
__decorate([
    Input('nglPopoverSize'),
    __metadata("design:type", String)
], NglPopoverTrigger.prototype, "size", void 0);
__decorate([
    Input('nglPopoverPlacement'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglPopoverTrigger.prototype, "placement", null);
__decorate([
    Input('nglPopoverOpen'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPopoverTrigger.prototype, "nglOpen", null);
__decorate([
    Input('nglPopoverCloseTitle'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "closeTitle", void 0);
__decorate([
    Input('nglPopoverClass'),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "popoverClass", void 0);
__decorate([
    Input('nglPopoverCloseVisible'), InputBoolean(),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "closeVisible", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPopoverTrigger.prototype, "nglPopoverOpenChange", void 0);
__decorate([
    hasObservers('nglPopoverOpenChange'),
    __metadata("design:type", Boolean)
], NglPopoverTrigger.prototype, "canClose", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglPopoverTrigger.prototype, "onclick", null);
NglPopoverTrigger = __decorate([
    Directive({
        selector: '[nglPopover]',
        exportAs: 'nglPopover',
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ViewContainerRef,
        Overlay])
], NglPopoverTrigger);

const NGL_POPOVER_DIRECTIVES = [
    NglPopover,
    NglPopoverTrigger,
];
let NglPopoversModule = class NglPopoversModule {
};
NglPopoversModule = __decorate([
    NgModule({
        declarations: [NGL_POPOVER_DIRECTIVES],
        exports: [NGL_POPOVER_DIRECTIVES],
        imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule, NglIconsModule],
        entryComponents: [NglPopover],
    })
], NglPopoversModule);

let NglTooltip = class NglTooltip {
    constructor(element, renderer, hostService, cd) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.cd = cd;
        this.renderer.addClass(this.element.nativeElement, 'slds-popover');
        this.renderer.addClass(this.element.nativeElement, 'slds-popover_tooltip');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'tooltip');
    }
    nglOnPropertyChange(prop) {
        if (prop === 'uid') {
            this.renderer.setAttribute(this.element.nativeElement, 'id', this.uid);
        }
        else if (prop === 'placement') {
            this.nubbin = POSITION_MAP[this.placement].nubbin;
            this.setHostClass();
        }
        else if (prop === 'template') {
            this.cd.markForCheck();
        }
        else if (prop === 'tooltipClass') {
            this.setHostClass();
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, ngClassCombine(this.tooltipClass, {
            [`slds-nubbin_${this.nubbin}`]: true,
        }));
        this.hostService.updateStyle(this.element, getPlacementStyles(this.nubbin));
    }
};
NglTooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService },
    { type: ChangeDetectorRef }
];
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglTooltip.prototype, "template", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglTooltip.prototype, "placement", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", String)
], NglTooltip.prototype, "uid", void 0);
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], NglTooltip.prototype, "tooltipClass", void 0);
NglTooltip = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'div[ngl-tooltip]',
        template: "\n<div class=\"slds-popover__body\" [nglInternalOutlet]=\"template\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        HostService,
        ChangeDetectorRef])
], NglTooltip);

/** Injection token that can be used to specify default options. */
const NGL_TOOLTIP_CONFIG = new InjectionToken('ngl-tooltip-config');
class NglTooltipConfig {
    constructor() {
        /**
         * Default position relative to host element.
         */
        this.placement = 'top';
        /**
         * Whether you can interact with the content of the tooltip.
         */
        this.interactive = false;
        /**
         * Whether tooltip will open/close without two-way binding input.
         */
        this.openAuto = false;
        /**
         * Delay in milliseconds until it opens/closes.
         */
        this.delay = 0;
    }
}

let NglTooltipTrigger = class NglTooltipTrigger {
    constructor(defaultConfig, element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Emit an event when actual tooltip is shown or hidden.
         */
        this.nglTooltipOpenChange = new EventEmitter();
        this.uid = uniqueId('tooltip');
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'placement',
            'uid',
            'tooltipClass',
        ]);
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.overlayListeners = new Set();
        this.config = Object.assign(Object.assign({}, new NglTooltipConfig()), defaultConfig);
        this.openAuto = this.config.openAuto;
        this.interactive = this.config.interactive;
        this.delay = this.config.delay;
        this.renderer.setAttribute(this.element.nativeElement, 'aria-describedby', this.uid);
    }
    /**
     * Position relative to host element.
     */
    set placement(placement) {
        if (placement === this.placement) {
            return;
        }
        this._placement = placement;
        if (this.overlayRef) {
            this.updatePosition();
        }
    }
    get placement() {
        return this._placement || this.config.placement;
    }
    /**
     * Delay in milliseconds until it opens/closes.
     */
    set delay(_delay) {
        const delay = Array.isArray(_delay) ? _delay : [_delay, _delay];
        [this.openDelay, this.closeDelay] = delay.map(Number);
    }
    /**
     * Whether the floating tooltip is visible.
     */
    set nglOpen(open) {
        if (open === this.nglOpen) {
            return;
        }
        open ? this.create() : this.detach();
        this._open = open;
    }
    get nglOpen() {
        return this._open;
    }
    ngOnChanges(changes) {
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(() => {
                if (this.overlayRef) {
                    this.overlayRef.updatePosition();
                }
            });
        }
    }
    onMouseOver() {
        this.open();
    }
    onMouseOut() {
        this.close();
        if (this.overlayRef && !this.overlayElement && this.interactive) {
            this.overlayElement = this.overlayRef.overlayElement;
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseenter', () => this.open()));
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseleave', () => this.close()));
        }
    }
    ngOnDestroy() {
        this.detach();
        this.close(0);
    }
    // Expose open method
    open(delay = this.openDelay) {
        this.handle(true, delay);
    }
    // Expose close method
    close(delay = this.closeDelay) {
        this.handle(false, delay);
    }
    // Expose toggle method
    toggle() {
        this.nglOpen ? this.close(0) : this.open(0);
    }
    handle(open, delay) {
        if (this.toggleTimeout !== null) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        if (open !== this.nglOpen) {
            if (delay > 0) {
                this.toggleTimeout = setTimeout(() => {
                    this.toggleTimeout = null;
                    this.emitOpen(open);
                }, delay);
            }
            else {
                this.emitOpen(open);
            }
        }
    }
    emitOpen(open) {
        if (this.openAuto) {
            this.nglOpen = open;
        }
        this.nglTooltipOpenChange.emit(open);
    }
    create() {
        if (this.nglOpen) {
            return;
        }
        this.detach();
        const overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglTooltip, this.viewContainerRef);
        this.tooltip = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(property => this.updateTooltip(property, this[property]));
    }
    /** Detaches the currently-attached tooltip. */
    detach() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        // Clean up the event listeners
        this.overlayListeners.forEach((unlisten) => unlisten());
        this.overlayListeners.clear();
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.tooltip = null;
    }
    /** Create the overlay config and position strategy */
    createOverlay() {
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(change => getPlacementName(change, this.placement)), distinctUntilChanged())
            .subscribe((placement) => {
            this.updatePosition();
            this.updateTooltip('placement', placement);
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    }
    /** Updates the position of the current tooltip. */
    updatePosition() {
        const position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions([
            POSITION_MAP[this.placement].position,
            ...DEFAULT_TOOLTIP_POSITIONS,
        ]);
    }
    updateTooltip(key, value) {
        this.tooltip[key] = value;
    }
    /**
     * Set inputs of child components when this component's inputs change.
     */
    updateProxies(changes) {
        Object.keys(changes)
            .filter(key => this.needProxyProperties.has(key))
            .forEach(key => this.updateTooltip(key, this[key]));
    }
};
NglTooltipTrigger.ctorParameters = () => [
    { type: NglTooltipConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_TOOLTIP_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: Overlay }
];
__decorate([
    Input('nglTooltip'),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "template", void 0);
__decorate([
    Input('nglTooltipPlacement'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglTooltipTrigger.prototype, "placement", null);
__decorate([
    Input('nglTooltipDelay'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTooltipTrigger.prototype, "delay", null);
__decorate([
    Input('nglTooltipOpen'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglTooltipTrigger.prototype, "nglOpen", null);
__decorate([
    Input('nglTooltipOpenAuto'), InputBoolean(),
    __metadata("design:type", Boolean)
], NglTooltipTrigger.prototype, "openAuto", void 0);
__decorate([
    Input('nglTooltipInteractive'), InputBoolean(),
    __metadata("design:type", Boolean)
], NglTooltipTrigger.prototype, "interactive", void 0);
__decorate([
    Input('nglTooltipClass'),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "tooltipClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglTooltipTrigger.prototype, "nglTooltipOpenChange", void 0);
__decorate([
    HostListener('mouseenter'),
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglTooltipTrigger.prototype, "onMouseOver", null);
__decorate([
    HostListener('mouseleave'),
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglTooltipTrigger.prototype, "onMouseOut", null);
NglTooltipTrigger = __decorate([
    Directive({
        selector: '[nglTooltip]',
        exportAs: 'nglTooltip',
    }),
    __param(0, Optional()), __param(0, Inject(NGL_TOOLTIP_CONFIG)),
    __metadata("design:paramtypes", [NglTooltipConfig,
        ElementRef,
        Renderer2,
        ViewContainerRef,
        Overlay])
], NglTooltipTrigger);

let NglTooltipsModule = class NglTooltipsModule {
};
NglTooltipsModule = __decorate([
    NgModule({
        declarations: [NglTooltip, NglTooltipTrigger],
        exports: [NglTooltipTrigger],
        imports: [CommonModule, OverlayModule, A11yModule, NglInternalOutletModule],
        entryComponents: [NglTooltip],
    })
], NglTooltipsModule);

let NglFormLabel = class NglFormLabel {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.klass = 'slds-form-element__label';
    }
    ngOnInit() {
        this.renderer.addClass(this.element.nativeElement, this.klass);
    }
};
NglFormLabel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('nglFormLabel'),
    __metadata("design:type", Object)
], NglFormLabel.prototype, "label", void 0);
__decorate([
    Input('nglFormLabelClass'),
    __metadata("design:type", Object)
], NglFormLabel.prototype, "klass", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglFormLabel.prototype, "required", void 0);
NglFormLabel = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'label[nglFormLabel]',
        template: "<abbr class=\"slds-required\" *ngIf=\"required\" title=\"Required\">*</abbr><span [nglInternalOutlet]=\"label\"></span>\n<ng-content></ng-content>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFormLabel);

let NglFormHelp = class NglFormHelp {
    constructor() {
        this.isOpen = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFormHelp.prototype, "content", void 0);
NglFormHelp = __decorate([
    Component({
        selector: 'ngl-form-help',
        template: "\n<button class=\"slds-button slds-button_icon\" [nglTooltip]=\"content\" [(nglTooltipOpen)]=\"isOpen\">\n  <svg class=\"slds-button__icon\" nglIconName=\"utility:info\"></svg><span class=\"slds-assistive-text\">Help</span>\n</button>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element__icon]': 'true',
        }
    })
], NglFormHelp);

const DIRECTIVES$3 = [
    NglFormLabel,
    NglFormHelp,
];
let NglFormsModule = class NglFormsModule {
};
NglFormsModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$3,
        exports: DIRECTIVES$3,
        imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglTooltipsModule],
    })
], NglFormsModule);

function getHexFromHsv(hsv) {
    return hsv ? getHexFromRgb(getRgbFromHsv(hsv)) : null;
}
function getRgbFromHsv({ hue, saturation, value }) {
    const hueRatio = hue / 360;
    const satRatio = saturation / 100;
    const valRatio = value / 100;
    let red;
    let green;
    let blue;
    const i = Math.floor(hueRatio * 6);
    const f = hueRatio * 6 - i;
    const p = valRatio * (1 - satRatio);
    const q = valRatio * (1 - f * satRatio);
    const t = valRatio * (1 - (1 - f) * satRatio);
    switch (i % 6) {
        case 0:
            red = valRatio;
            green = t;
            blue = p;
            break;
        case 1:
            red = q;
            green = valRatio;
            blue = p;
            break;
        case 2:
            red = p;
            green = valRatio;
            blue = t;
            break;
        case 3:
            red = p;
            green = q;
            blue = valRatio;
            break;
        case 4:
            red = t;
            green = p;
            blue = valRatio;
            break;
        default:
            red = valRatio;
            green = p;
            blue = q;
    }
    return {
        red: Math.round(red * 255),
        blue: Math.round(blue * 255),
        green: Math.round(green * 255),
    };
}
function getHex(color) {
    return `0${Math.round(color).toString(16)}`.substr(-2);
}
function getHexFromRgb({ red, green, blue }) {
    return `#${getHex(red)}${getHex(green)}${getHex(blue)}`;
}
function getHsvFromHex(hex) {
    return hex ? getHsvFromRgb(getRgbFromHex(hex)) : null;
}
function getHsvFromRgb({ red, green, blue }) {
    const redRatio = red / 255;
    const greenRatio = green / 255;
    const blueRatio = blue / 255;
    const max = Math.max(redRatio, greenRatio, blueRatio);
    const min = Math.min(redRatio, greenRatio, blueRatio);
    const delta = max - min;
    const saturation = max === 0 ? 0 : delta / max * 100;
    const value = max * 100;
    let hue;
    if (max === min) {
        hue = 0;
    }
    else {
        if (redRatio === max) {
            hue =
                (greenRatio - blueRatio) / delta + (greenRatio < blueRatio ? 6 : 0);
        }
        else if (greenRatio === max) {
            hue = (blueRatio - redRatio) / delta + 2;
        }
        else {
            hue = (redRatio - greenRatio) / delta + 4;
        }
        hue *= 60;
    }
    return { hue, saturation, value };
}
const HEX_REGEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
function getRgbFromHex(hex) {
    const result = HEX_REGEX.exec(toSixDigitHex(hex));
    return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16),
    };
}
function toSixDigitHex(value) {
    const shortHandHex = /^#([a-f\d])([a-f\d])([a-f\d])$/i;
    const match = shortHandHex.exec(value);
    if (match) {
        return `#${match[1]}${match[1]}${match[2]}${match[2]}${match[3]}${match[3]}`;
    }
    return value;
}
function isValidHex(value) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(value);
}

/** Injection token that can be used to specify default options. */
const NGL_COLORPICKER_CONFIG = new InjectionToken('ngl-colorpicker-config');
class NglColorpickerConfig {
    constructor() {
        this.swatchColors = [
            '#e3abec', '#c2dbf7', '#9fd6ff', '#9de7da', '#9df0c0', '#fff099', '#fed49a',
            '#d073e0', '#86baf3', '#5ebbff', '#44d8be', '#3be282', '#ffe654', '#ffb758',
            '#bd35bd', '#5779c1', '#5679c0', '#00aea9', '#3cba4c', '#f5bc25', '#f99221',
            '#580d8c', '#001970', '#0a2399', '#0b7477', '#0b6b50', '#b67e11', '#b85d0d',
        ];
        this.variant = 'base';
    }
}

const NGL_COLORPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglColorpicker),
    multi: true
};
let NglColorpicker = class NglColorpicker {
    constructor(defaultConfig, el, renderer, cd) {
        this.el = el;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * An input label as for a form.
         */
        this.label = 'Choose Color';
        /**
         * Placeholder of input box.
         */
        this.placeholder = '';
        /**
         * Text for cancel button on popover.
         */
        this.cancelButtonLabel = 'Cancel';
        /**
         * Text for submit button of popover.
         */
        this.submitButtonLabel = 'Done';
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        this.required = false;
        /**
         * Error message when hex color input is invalid.
         */
        this.invalidColorLabel = 'Please ensure value is correct';
        /**
         * Text for swatch tab of popover.
         */
        this.swatchTabLabel = 'Default';
        /**
         * Text for custom tab of popover.
         */
        this.customTabLabel = 'Custom';
        /**
         * Whether to make the hex color input readonly.
         */
        this.readonlyInput = false;
        /**
         * Determines which tab is visible when popover opens.
         */
        this.defaultSelectedTab = 'swatches';
        this.uid = uniqueId('colorpicker');
        this.hexCurrent = '#FFF';
        this.hsvCurrent = getHsvFromHex(this.hexCurrent);
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker');
        const config = Object.assign(Object.assign({}, new NglColorpickerConfig()), defaultConfig);
        this.swatchColors = config.swatchColors;
        this.variant = config.variant;
    }
    writeValue(value) {
        this.color = value || '';
        if (isValidHex(value)) {
            this.hexCurrent = value;
            this.hsvCurrent = getHsvFromHex(value);
        }
        this.cd.detectChanges();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onSwatchSelection(hex) {
        this.hsvCurrent = getHsvFromHex(hex);
        this.hexCurrent = hex;
    }
    onCustomSelection(hsv) {
        this.hsvCurrent = hsv;
        this.hexCurrent = getHexFromHsv(hsv);
    }
    openChange(open) {
        this.open = open;
    }
    cancel() {
        this.open = false;
    }
    done() {
        this.open = false;
        if (this.hexCurrent !== this.color) {
            this.color = this.hexCurrent;
            this.onChange(this.color);
        }
    }
    canApply() {
        return isValidHex(this.hexCurrent);
    }
    onInput(hex) {
        this.color = hex;
        if (isValidHex(hex)) {
            this.onSwatchSelection(hex);
            this.onChange(hex);
        }
        else {
            this.onChange(null);
        }
    }
    get isValidInput() {
        return !this.color || isValidHex(this.color);
    }
};
NglColorpicker.ctorParameters = () => [
    { type: NglColorpickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_COLORPICKER_CONFIG,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "cancelButtonLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "submitButtonLabel", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "invalidColorLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "swatchTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "customTabLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglColorpicker.prototype, "swatchColors", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglColorpicker.prototype, "readonlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpicker.prototype, "defaultSelectedTab", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpicker.prototype, "variant", void 0);
NglColorpicker = __decorate([
    Component({
        selector: 'ngl-colorpicker',
        template: "\n<div class=\"slds-color-picker__summary slds-form-element\" [class.slds-has-error]=\"!isValidInput\">\n  <label class=\"slds-form-element__label slds-color-picker__summary-label\" [nglFormLabel]=\"label\" [attr.for]=\"uid + '-summary-input'\" [required]=\"required\">\n    <ngl-form-help class=\"slds-m-horizontal_xx-small\" *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n  </label>\n  <div class=\"slds-form-element__control\">\n    <button class=\"slds-button slds-color-picker__summary-button slds-button_icon slds-button_icon-more\" [title]=\"label\" [nglPopover]=\"tip\" nglPopoverPlacement=\"bottom-left\" [nglPopoverOpen]=\"open\" (nglPopoverOpenChange)=\"openChange($event)\" nglPopoverClass=\"slds-color-picker__selector\" [nglPopoverFooter]=\"footer\" nglPopoverCloseVisible=\"false\" [disabled]=\"disabled\"><span class=\"slds-swatch\" nglColorpickerSwatch [color]=\"isValidInput ? color : hexCurrent\"></span>\n      <svg class=\"slds-button__icon slds-button__icon_small slds-m-left_xx-small\" *ngIf=\"!disabled\" nglIconName=\"utility:down\"></svg><span class=\"slds-assistive-text\">{{ label }}: {{ color }}</span>\n    </button>\n    <div class=\"slds-color-picker__summary-input\">\n      <input class=\"slds-input\" [id]=\"uid + '-summary-input'\" type=\"text\" [value]=\"color\" (input)=\"onInput($event.target.value)\" [disabled]=\"disabled\" [readOnly]=\"readonlyInput\" maxlength=\"7\" [placeholder]=\"placeholder || ''\">\n    </div>\n    <p class=\"slds-form-error\" *ngIf=\"!isValidInput\" [nglInternalOutlet]=\"invalidColorLabel\"></p>\n  </div>\n</div>\n<ng-template #tip>\n  <ng-container [ngSwitch]=\"variant\">\n    <ng-container *ngSwitchCase=\"'swatches'\">\n      <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"'custom'\">\n      <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n    </ng-container>\n    <ngl-tabset *ngSwitchDefault [selected]=\"defaultSelectedTab\" (selectedChange)=\"defaultSelectedTab = $event.id\">\n      <ng-template ngl-tab id=\"swatches\" [label]=\"swatchTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"swatches\"></ng-template>\n      </ng-template>\n      <ng-template ngl-tab id=\"custom\" [label]=\"customTabLabel\">\n        <ng-template [ngTemplateOutlet]=\"custom\"></ng-template>\n      </ng-template>\n    </ngl-tabset>\n  </ng-container>\n</ng-template>\n<ng-template #swatches>\n  <ngl-colorpicker-swatches [hex]=\"hexCurrent\" (hexChange)=\"onSwatchSelection($event)\" [swatchColors]=\"swatchColors\"></ngl-colorpicker-swatches>\n</ng-template>\n<ng-template #custom>\n  <ngl-colorpicker-custom [hsv]=\"hsvCurrent\" (hsvChange)=\"onCustomSelection($event)\"></ngl-colorpicker-custom>\n</ng-template>\n<ng-template #footer>\n  <div class=\"slds-color-picker__selector-footer\">\n    <button class=\"slds-button slds-button_neutral\" type=\"button\" (click)=\"cancel()\">{{ cancelButtonLabel }}</button>\n    <button class=\"slds-button slds-button_brand\" type=\"button\" (click)=\"done()\" [disabled]=\"!canApply()\">{{ submitButtonLabel }}</button>\n  </div>\n</ng-template>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [NGL_COLORPICKER_VALUE_ACCESSOR]
    }),
    __param(0, Optional()), __param(0, Inject(NGL_COLORPICKER_CONFIG)),
    __metadata("design:paramtypes", [NglColorpickerConfig,
        ElementRef,
        Renderer2,
        ChangeDetectorRef])
], NglColorpicker);

let NglColorpickerSwatch = class NglColorpickerSwatch {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, 'slds-swatch');
    }
};
NglColorpickerSwatch.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('style.background'),
    Input(),
    __metadata("design:type", String)
], NglColorpickerSwatch.prototype, "color", void 0);
NglColorpickerSwatch = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglColorpickerSwatch]',
        template: "<span class=\"slds-assistive-text\" aria-hidden=\"true\">{{ color }}</span>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatch);

let NglColorpickerCustom = class NglColorpickerCustom {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hsvChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__custom');
    }
    ngOnChanges(changes) {
        if (changes.hsv) {
            this.hex = getHexFromHsv(this.hsv);
        }
    }
    onHsvChange($event) {
        this.hsvChange.emit($event);
    }
    onHexChange(hex) {
        const hsv = getHsvFromHex(hex);
        this.hsvChange.emit(hsv);
    }
};
NglColorpickerCustom.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglColorpickerCustom.prototype, "hsv", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerCustom.prototype, "hsvChange", void 0);
NglColorpickerCustom = __decorate([
    Component({
        selector: 'ngl-colorpicker-custom',
        template: "\n<ngl-colorpicker-range [hsv]=\"hsv\" (hsvChange)=\"onHsvChange($event)\"></ngl-colorpicker-range>\n<ngl-colorpicker-inputs [hex]=\"hex\" (hexChange)=\"onHexChange($event)\"></ngl-colorpicker-inputs>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerCustom);

let NglColorpickerRange = class NglColorpickerRange {
    constructor(document) {
        this.document = document;
        this.hsvChange = new EventEmitter();
        this.uid = uniqueId('colorpicker-range');
        this._hsv = { hue: 0, saturation: 0, value: 0 };
    }
    set hsv(hsv) {
        if (hsv) {
            this._hsv = hsv;
        }
    }
    get hsv() {
        return this._hsv;
    }
    get hex() {
        return getHexFromHsv(this.hsv);
    }
    ngAfterViewInit() {
        this.dragSubscription = this.setupDrag().subscribe((mm) => this.emitChange(mm));
    }
    hueSliderChange(value) {
        this.emitChange({ hue: value });
    }
    rangeIndicatorKeyboard(evt) {
        let saturation = this.hsv.saturation;
        let value = this.hsv.value;
        switch (evt.keyCode) {
            case LEFT_ARROW:
                saturation = this.limit(saturation - 1);
                break;
            case RIGHT_ARROW:
                saturation = this.limit(saturation + 1);
                break;
            case UP_ARROW:
                value = this.limit(value + 1);
                break;
            case DOWN_ARROW:
                value = this.limit(value - 1);
                break;
            default:
                return;
        }
        trapEvent(evt);
        this.emitChange({ saturation, value });
    }
    indicatorStyle() {
        return {
            'bottom.%': this.hsv.value,
            'left.%': this.hsv.saturation,
            'background': this.hex,
        };
    }
    ngOnDestroy() {
        if (this.dragSubscription) {
            this.dragSubscription.unsubscribe();
            this.dragSubscription = null;
        }
    }
    emitChange(hsv) {
        this.hsvChange.emit(Object.assign(Object.assign({}, this.hsv), hsv));
    }
    limit(value) {
        return Math.min(Math.max(value, 0), 100);
    }
    setupDrag() {
        const dragTarget = this.rangeIndicatorContainer.nativeElement;
        const pressEnd = merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend'));
        const pressMove = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));
        const pressStart = merge(fromEvent(dragTarget, 'mousedown'), fromEvent(dragTarget, 'touchstart'));
        return pressStart.pipe(flatMap((md) => {
            this.rangeIndicator.nativeElement.focus();
            const rect = dragTarget.getBoundingClientRect();
            return pressMove.pipe(startWith(md), map((mm) => {
                mm.preventDefault();
                const saturation = Math.round((mm.clientX - rect.left) / rect.width * 100);
                const value = Math.round((rect.bottom - mm.clientY) / rect.height * 100);
                return { saturation: this.limit(saturation), value: this.limit(value) };
            }), takeUntil(pressEnd));
        }));
    }
};
NglColorpickerRange.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange.prototype, "hsv", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerRange.prototype, "hsvChange", void 0);
__decorate([
    ViewChild('rangeIndicator'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicator", void 0);
__decorate([
    ViewChild('rangeIndicatorContainer'),
    __metadata("design:type", ElementRef)
], NglColorpickerRange.prototype, "rangeIndicatorContainer", void 0);
NglColorpickerRange = __decorate([
    Component({
        selector: 'ngl-colorpicker-range',
        template: "\n<p class=\"slds-assistive-text\" [attr.id]=\"uid + '-instructions'\">Use arrow keys to select a saturation and brightness, on an x and y axis.</p>\n<div class=\"slds-color-picker__custom-range\" #rangeIndicatorContainer [style.background]=\"'hsl(' + hsv.hue + ', 100%, 50%)'\"><a class=\"slds-color-picker__range-indicator\" #rangeIndicator href=\"javascript:void(0);\" aria-live=\"assertive\" aria-atomic=\"true\" [attr.aria-describedby]=\"uid + '-instructions'\" [ngStyle]=\"indicatorStyle()\" (keydown)=\"rangeIndicatorKeyboard($event)\"><span class=\"slds-assistive-text\">Saturation: {{hsv.saturation}}%. Brightness: {{hsv.value}}%.</span></a></div>\n<div class=\"slds-color-picker__hue-and-preview\">\n  <label class=\"slds-assistive-text\" [attr.for]=\"uid + '-hue'\">Select Hue</label>\n  <input class=\"slds-color-picker__hue-slider\" #hueSlider type=\"range\" min=\"0\" max=\"360\" [id]=\"uid + '-hue'\" [value]=\"hsv.hue\" (input)=\"hueSliderChange($event.target.value)\"><span nglColorpickerSwatch [color]=\"hex\"></span>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object])
], NglColorpickerRange);

let NglColorpickerInputs = class NglColorpickerInputs {
    constructor() {
        this.hexChange = new EventEmitter();
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.uid = uniqueId('colorpicker-inputs');
    }
    set hex(hex) {
        if (hex) {
            this._hex = hex;
            const { red, green, blue } = getRgbFromHex(this.hex);
            this.red = red;
            this.green = green;
            this.blue = blue;
        }
    }
    get hex() {
        return this._hex;
    }
    updateHex(value) {
        const isValid = isValidHex(value);
        if (!isValid) {
            this.red = this.green = this.blue = null;
        }
        this.hexChange.emit(isValid ? value : null);
    }
    onRGB(key, value) {
        this[key] = value;
        const hex = this.isRGBValid() ? getHexFromRgb({ red: this.red, green: this.green, blue: this.blue }) : null;
        this.hexChange.emit(hex);
    }
    get isHexInvalid() {
        return this.red === null && this.green === null && this.blue === null;
    }
    isColorNumberValid(key) {
        const value = this[key];
        return _isNumberValue(value) && value >= 0 && value <= 255;
    }
    isRGBValid() {
        return ['red', 'green', 'blue'].every((prop) => this.isColorNumberValid(prop));
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglColorpickerInputs.prototype, "hex", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerInputs.prototype, "hexChange", void 0);
NglColorpickerInputs = __decorate([
    Component({
        selector: 'ngl-colorpicker-inputs',
        template: "\n<div class=\"slds-color-picker__custom-inputs\">\n  <div class=\"slds-form-element slds-color-picker__input-custom-hex\" [class.slds-has-error]=\"isHexInvalid\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'hex'\">Hex</label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'hex'\" type=\"text\" maxlength=\"7\" [value]=\"hex\" (input)=\"updateHex($event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('red')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'red'\"><abbr title=\"red\">R</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'red'\" type=\"text\" maxlength=\"3\" [value]=\"red\" (input)=\"onRGB('red', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('green')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'green'\"><abbr title=\"green\">G</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'green'\" type=\"text\" maxlength=\"3\" [value]=\"green\" (input)=\"onRGB('green', $event.target.value)\">\n    </div>\n  </div>\n  <div class=\"slds-form-element\" [class.slds-has-error]=\"!isColorNumberValid('blue')\">\n    <label class=\"slds-form-element__label\" [attr.for]=\"uid + 'blue'\"><abbr title=\"blue\">B</abbr></label>\n    <div class=\"slds-form-element__control\">\n      <input class=\"slds-input\" [id]=\"uid + 'blue'\" type=\"text\" maxlength=\"3\" [value]=\"blue\" (input)=\"onRGB('blue', $event.target.value)\">\n    </div>\n  </div>\n</div>\n<div class=\"slds-color-picker\">\n  <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"isHexInvalid; else rgbError\">The color entered is invalid</p>\n  <ng-template #rgbError>\n    <p class=\"slds-form-error slds-color-picker__input-custom-error\" *ngIf=\"!isRGBValid()\">The value needs to be an integer from 0-255</p>\n  </ng-template>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglColorpickerInputs);

let NglColorpickerSwatchTrigger = class NglColorpickerSwatchTrigger {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatch-trigger');
        this.renderer.setAttribute(this.el.nativeElement, 'role', 'option');
    }
    onSelect() {
        return this.selectedChange.emit();
    }
    focus() {
        this.el.nativeElement.focus();
        this.onSelect();
    }
};
NglColorpickerSwatchTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.ngl-color-picker__swatch-selected'),
    Input(),
    __metadata("design:type", Boolean)
], NglColorpickerSwatchTrigger.prototype, "selected", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerSwatchTrigger.prototype, "selectedChange", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglColorpickerSwatchTrigger.prototype, "onSelect", null);
NglColorpickerSwatchTrigger = __decorate([
    Directive({
        selector: '[nglColorpickerSwatchTrigger]',
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatchTrigger);

let NglColorpickerSwatches = class NglColorpickerSwatches {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hexChange = new EventEmitter();
        this.swatchColors = [];
        this.renderer.addClass(this.el.nativeElement, 'slds-color-picker__swatches');
    }
    ngOnChanges() {
        this.activeIndex = Math.max(this.swatchColors.indexOf(this.hex), 0);
    }
    onSelectViaInteraction(evt) {
        let direction = 0;
        switch (evt.keyCode) {
            case LEFT_ARROW:
            case UP_ARROW:
                direction = -1;
                break;
            case RIGHT_ARROW:
            case DOWN_ARROW:
                direction = 1;
                break;
            default:
                return;
        }
        trapEvent(evt);
        const activeIndex = this.swatchColors.indexOf(this.hex);
        const index = (this.triggers.length + activeIndex + direction) % this.triggers.length;
        const trigger = this.triggers.toArray()[index];
        trigger.focus();
    }
    isSelected(hex) {
        return hex === this.hex;
    }
    onSelect(hex) {
        this.hexChange.emit(hex);
    }
};
NglColorpickerSwatches.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglColorpickerSwatches.prototype, "hex", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglColorpickerSwatches.prototype, "hexChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglColorpickerSwatches.prototype, "swatchColors", void 0);
__decorate([
    ViewChildren(NglColorpickerSwatchTrigger),
    __metadata("design:type", QueryList)
], NglColorpickerSwatches.prototype, "triggers", void 0);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglColorpickerSwatches.prototype, "onSelectViaInteraction", null);
NglColorpickerSwatches = __decorate([
    Component({
        selector: 'ngl-colorpicker-swatches',
        template: "\n<li class=\"slds-color-picker__swatch\" *ngFor=\"let color of swatchColors; let i = index\" role=\"presentation\"><a nglColorpickerSwatchTrigger href=\"javascript:void(0);\" [selected]=\"isSelected(color)\" [attr.tabindex]=\"activeIndex === i ? 0 : -1\" (selectedChange)=\"onSelect(color)\"><span nglColorpickerSwatch [color]=\"color\"></span></a></li>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [`
    .ngl-color-picker__swatch-selected {
      box-shadow: rgb(117, 112, 112) 1px 1px 1px;
  `]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglColorpickerSwatches);

const DIRECTIVES$4 = [
    NglColorpicker,
];
let NglColorpickerModule = class NglColorpickerModule {
};
NglColorpickerModule = __decorate([
    NgModule({
        declarations: [
            ...DIRECTIVES$4,
            NglColorpickerSwatch,
            NglColorpickerCustom,
            NglColorpickerRange,
            NglColorpickerInputs,
            NglColorpickerSwatches,
            NglColorpickerSwatchTrigger,
        ],
        exports: DIRECTIVES$4,
        imports: [
            CommonModule,
            NglIconsModule,
            NglTabsModule,
            NglPopoversModule,
            NglFormsModule,
            NglInternalOutletModule,
        ],
    })
], NglColorpickerModule);

let NglOverlaynglOverlayScrolledOutsideViewDirective = class NglOverlaynglOverlayScrolledOutsideViewDirective {
    constructor(cdkOverlay, ngZone, scrollDispatcher) {
        this.cdkOverlay = cdkOverlay;
        this.ngZone = ngZone;
        this.scrollDispatcher = scrollDispatcher;
        this.overlayOutside = new EventEmitter();
    }
    ngOnInit() {
        const elementRef = this.cdkOverlay.origin.elementRef;
        const scrollableAncestors = this.scrollDispatcher.getAncestorScrollContainers(elementRef).map(container => container.getElementRef());
        if (!scrollableAncestors || !scrollableAncestors.length)
            return;
        this.subscription = this.cdkOverlay.positionChange.subscribe(() => {
            const bounds = elementRef.nativeElement.getBoundingClientRect();
            for (let i = 0, n = scrollableAncestors.length; i < n; i++) {
                const ancestorsBounds = scrollableAncestors[i].nativeElement.getBoundingClientRect();
                if (isElementOutside(bounds, ancestorsBounds)) {
                    this.ngZone.run(() => this.overlayOutside.emit());
                    return;
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
};
NglOverlaynglOverlayScrolledOutsideViewDirective.ctorParameters = () => [
    { type: CdkConnectedOverlay, decorators: [{ type: Self }] },
    { type: NgZone },
    { type: ScrollDispatcher }
];
__decorate([
    Output('nglOverlayScrolledOutsideView'),
    __metadata("design:type", EventEmitter)
], NglOverlaynglOverlayScrolledOutsideViewDirective.prototype, "overlayOutside", void 0);
NglOverlaynglOverlayScrolledOutsideViewDirective = __decorate([
    Directive({
        selector: '[nglOverlayScrolledOutsideView]'
    }),
    __param(0, Self()),
    __metadata("design:paramtypes", [CdkConnectedOverlay,
        NgZone,
        ScrollDispatcher])
], NglOverlaynglOverlayScrolledOutsideViewDirective);
/**
 * Gets whether an element is scrolled outside of view by its parent scrolling container.
 * @param element Dimensions of the element (from getBoundingClientRect)
 * @param container Dimensions of element's scrolling container (from getBoundingClientRect)
 * @returns Whether the element is scrolled out of view
 */
function isElementOutside(element, container) {
    return (element.bottom < container.top || element.top > container.bottom ||
        element.right < container.left || element.left > container.right);
}

const DIRECTIVES$5 = [
    NglOverlaynglOverlayScrolledOutsideViewDirective,
];
let NglOverlayModule = class NglOverlayModule {
};
NglOverlayModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: DIRECTIVES$5,
        exports: DIRECTIVES$5,
    })
], NglOverlayModule);

let NglComboboxService = class NglComboboxService {
};
NglComboboxService = __decorate([
    Injectable()
], NglComboboxService);

let NglComboboxOption = class NglComboboxOption {
    constructor(element, service, cd, ngZone, renderer) {
        this.element = element;
        this.service = service;
        this.cd = cd;
        this.ngZone = ngZone;
        this.disabled = false;
        this.uid = uniqueId('combo-option');
        this._active = false;
        // Flag to disable scrolling into view when option is activated using mouse
        this.disableNextScrollIntoView = false;
        this.destroyed = false;
        renderer.addClass(element.nativeElement, 'slds-listbox__item');
        renderer.setAttribute(element.nativeElement, 'role', 'presentation');
    }
    // Whether or not the option is currently active and ready to be selected
    set active(active) {
        if (this.active === active || this.destroyed) {
            return;
        }
        this._active = active;
        this.cd.detectChanges();
        if (active) {
            this.service.combobox.inputEl.setAriaActiveDescendant(this.uid);
            this.scrollIntoView();
        }
        else {
            clearTimeout(this.scrollTimer);
        }
    }
    get active() {
        return this._active;
    }
    onSelectViaInteraction(evt) {
        trapEvent(evt);
        if (!this.disabled) {
            this.service.combobox.onOptionSelection(this);
        }
    }
    hover() {
        if (!this.disabled) {
            this.disableNextScrollIntoView = true;
            this.service.combobox.keyManager.setActiveItem(this);
        }
    }
    setActiveStyles() {
        this.active = true;
    }
    setInactiveStyles() {
        this.active = false;
    }
    scrollIntoView() {
        if (this.disableNextScrollIntoView) {
            this.disableNextScrollIntoView = false;
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.scrollTimer = setTimeout(() => {
                const li = this.element.nativeElement;
                menuItemScroll(li.parentElement.parentElement, li);
            }, 0);
        });
    }
    ngOnDestroy() {
        this.destroyed = true;
        clearTimeout(this.scrollTimer);
    }
};
NglComboboxOption.ctorParameters = () => [
    { type: ElementRef },
    { type: NglComboboxService },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglComboboxOption.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglComboboxOption.prototype, "label", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglComboboxOption.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglComboboxOption.prototype, "disabled", void 0);
__decorate([
    HostListener('mousedown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], NglComboboxOption.prototype, "onSelectViaInteraction", null);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxOption.prototype, "hover", null);
NglComboboxOption = __decorate([
    Component({
        selector: 'ngl-combobox-option, [nglComboboxOption]',
        template: "\n<div class=\"slds-media slds-listbox__option slds-listbox__option_plain slds-media_small slds-media_center\" role=\"option\" [attr.id]=\"uid\" [class.slds-has-focus]=\"active\" [class.slds-is-selected]=\"selected\" [attr.aria-selected]=\"selected || null\" [attr.aria-disabled]=\"disabled || null\"><span class=\"slds-media__figure slds-listbox__option-icon\"><span class=\"slds-icon_container slds-icon-utility-check slds-current-color\" *ngIf=\"selected\">\n      <svg class=\"slds-icon slds-icon_x-small\" nglIconName=\"utility:check\"></svg></span></span><span class=\"slds-media__body\"><span class=\"slds-truncate\"><span class=\"slds-assistive-text\" *ngIf=\"selected\">Current Selection:</span>{{ label }}</span></span></div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef,
        NglComboboxService,
        ChangeDetectorRef,
        NgZone,
        Renderer2])
], NglComboboxOption);

const MAX_INTERVAL_BETWEEN_KEYSTROKES = 300; // ms
let NglComboboxInput = class NglComboboxInput {
    constructor(service, el, renderer) {
        this.service = service;
        this.el = el;
        this.renderer = renderer;
        const { nativeElement } = this.el;
        this.renderer.addClass(nativeElement, 'slds-input');
        this.renderer.addClass(nativeElement, 'slds-combobox__input');
        this.renderer.setAttribute(nativeElement, 'autoComplete', 'off');
        this.renderer.setAttribute(nativeElement, 'role', 'textbox');
        this.renderer.setAttribute(nativeElement, 'aria-controls', this.service.combobox.uid);
        if (!nativeElement.id) {
            this.renderer.setAttribute(nativeElement, 'id', uniqueId('combobox-input'));
        }
        const keyboardEvent$ = fromEvent(nativeElement, 'keypress').pipe(map((e) => e.keyCode));
        this.keyboardBuffer$ = keyboardEvent$.pipe(buffer(keyboardEvent$.pipe(debounceTime(MAX_INTERVAL_BETWEEN_KEYSTROKES))), map((keyCodes) => keyCodes.map((c) => String.fromCharCode(c)).join('')));
    }
    get isReadonly() {
        return this.service.combobox.variant === 'base' || this.service.combobox.hasLookupSingleSelection;
    }
    get ariaAutocomplete() {
        return this.service.combobox.isLookup ? 'list' : null;
    }
    get hasReadonlyValue() {
        return this.service.combobox.hasLookupSingleSelection;
    }
    get id() {
        return this.el.nativeElement.id;
    }
    setAriaActiveDescendant(uid) {
        if (uid) {
            this.renderer.setAttribute(this.el.nativeElement, 'aria-activedescendant', uid);
        }
        else {
            this.renderer.removeAttribute(this.el.nativeElement, 'aria-activedescendant');
        }
    }
    setValue(value) {
        this.renderer.setProperty(this.el.nativeElement, 'value', value !== null ? value : '');
    }
    focus() {
        this.el.nativeElement.focus();
    }
    onMouseInteraction() {
        if (this.service.combobox.hasLookupSingleSelection || (this.service.combobox.open && this.service.combobox.isLookup)) {
            return;
        }
        this.service.combobox.openChange.emit(!this.service.combobox.open);
    }
    onBlur() {
        this.service.combobox.openChange.emit(false);
    }
    onKeyboard(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ESCAPE) {
            // This is handled by CDK, and detaches overlay
            return;
        }
        if (this.service.combobox.open) {
            switch (keyCode) {
                // User selects currently active option by pressing the `Enter` key
                case ENTER:
                    trapEvent(evt);
                    this.service.combobox.onOptionSelection();
                    return;
                // Propagate to keymanager
                default:
                    this.service.combobox.keyManager.onKeydown(evt);
                    return;
            }
        }
        else {
            // Do nothing if readonly Lookup
            if (this.service.combobox.hasLookupSingleSelection) {
                return;
            }
            // Pressing the `Down` or `Enter` key will expand the collapsed menu
            if (keyCode === DOWN_ARROW || keyCode === ENTER) {
                trapEvent(evt);
                this.service.combobox.openChange.emit(true);
                return;
            }
            // Any key on Lookup should expand the collapsed menu
            if (this.service.combobox.isLookup) {
                // Delay emission so actual value of the input has been updated
                setTimeout(() => this.service.combobox.openChange.emit(true), 0);
            }
        }
    }
};
NglComboboxInput.ctorParameters = () => [
    { type: NglComboboxService },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('readOnly'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "isReadonly", null);
__decorate([
    HostBinding('attr.aria-autocomplete'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "ariaAutocomplete", null);
__decorate([
    HostBinding('class.slds-combobox__input-value'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglComboboxInput.prototype, "hasReadonlyValue", null);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onMouseInteraction", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onBlur", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglComboboxInput.prototype, "onKeyboard", null);
NglComboboxInput = __decorate([
    Directive({
        selector: 'input[nglCombobox]',
    }),
    __metadata("design:paramtypes", [NglComboboxService,
        ElementRef,
        Renderer2])
], NglComboboxInput);

let NglCombobox = class NglCombobox {
    constructor(ngZone, cd, service) {
        this.ngZone = ngZone;
        this.cd = cd;
        this.service = service;
        this.variant = 'base';
        this.uid = uniqueId('combobox');
        this.open = false;
        this.openChange = new EventEmitter();
        this.selectionChange = new EventEmitter();
        this.multiple = false;
        this.visibleLength = 5;
        this.closeOnSelection = true;
        this.overlayWidth = 0;
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS['left']];
        this.selectionValueFn = (selection) => {
            if (selection.length > 0) {
                if (this.multiple && this.isLookup) {
                    return '';
                }
                return selection.length === 1 ? selection[0] : `${selection.length} options selected`;
            }
            return '';
        };
        this.service.combobox = this;
        // this.service.openChange = this.openChange;
    }
    set data(data) {
        this._data = (data || []).map((d) => {
            if (typeof d === 'string') {
                // Support array of strings as options, by mapping to NglComboboxOptionItem
                return { value: d, label: d };
            }
            else if (!d.label) {
                // Use `value` if missing `label`
                return Object.assign(Object.assign({}, d), { label: d.value });
            }
            return d;
        });
    }
    get data() {
        return this._data;
    }
    get activeOption() {
        return this.keyManager ? this.keyManager.activeItem : null;
    }
    get selectedOptions() {
        return this.data ? this.data.filter(d => this.isSelected(d.value)) : [];
    }
    get isLookup() {
        return this.variant === 'lookup';
    }
    get hasLookupSingleSelection() {
        return this.isLookup && !this.multiple && this.selectedOptions.length > 0;
    }
    ngOnChanges(changes) {
        if (changes.selection) {
            this.calculateDisplayValue();
        }
    }
    onAttach() {
        // Same width as the trigger element
        this.overlayWidth = this.overlayOrigin.elementRef.nativeElement.offsetWidth;
        this.cd.detectChanges();
        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        // Activate selected item or first option
        const selectedOption = this.options.find(o => o.selected);
        if (selectedOption) {
            this.keyManager.setActiveItem(selectedOption);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
        // Listen to button presses if picklist to activate matching option
        this.keyboardSubscribe(this.variant === 'base');
        // When it is open we listen for option changes in order to fix active option and handle scroll
        this.optionChangesSubscription = this.options.changes.subscribe(() => {
            if (!this.activeOption || this.options.toArray().indexOf(this.activeOption) === -1) {
                // Activate first option if active one is destroyed
                this.keyManager.setFirstItemActive();
            }
            else {
                this.activeOption.scrollIntoView();
            }
            this.updateMenuHeight();
        });
        this.updateMenuHeight();
    }
    onDetach() {
        if (this.open) {
            this.close();
            return;
        }
        // Clear aria-activedescendant when menu is closed
        this.inputEl.setAriaActiveDescendant(null);
        this.detach();
    }
    trackByOption(index, option) {
        return option.value;
    }
    dropdownClass() {
        return {
            [`slds-dropdown_length-${this.visibleLength}`]: this.visibleLength > 0,
        };
    }
    inputIconRight() {
        return this.isLookup ? 'utility:search' : 'utility:down';
    }
    hasNoMatches() {
        return this.isLookup && this.data.length === 0 && !this.loadingMore;
    }
    onOptionSelection(option = this.activeOption) {
        const selection = addOptionToSelection(option.value, this.selection, this.multiple);
        this.selectionChange.emit(selection);
        if (this.closeOnSelection) {
            this.close();
        }
    }
    // Trigger by clear button on Lookup
    onClearSelection() {
        this.selectionChange.emit(null);
        setTimeout(() => this.inputEl.focus(), 0);
    }
    /**
     * Check whether value is currently selected.
     *
     * @param value The value in test, whether is (part of) selection or not
     */
    isSelected(value) {
        return isOptionSelected(value, this.selection, this.multiple);
    }
    ngOnDestroy() {
        this.detach();
    }
    close() {
        this.openChange.emit(false);
    }
    detach() {
        this.keyboardSubscribe(false);
        this.keyManager = null;
        if (this.optionChangesSubscription) {
            this.optionChangesSubscription.unsubscribe();
            this.optionChangesSubscription = null;
        }
    }
    calculateDisplayValue() {
        const value = this.selectionValueFn(this.selectedOptions.map(option => option.label));
        this.inputEl.setValue(value);
    }
    keyboardSubscribe(listen) {
        if (this.keyboardSubscription) {
            this.keyboardSubscription.unsubscribe();
            this.keyboardSubscription = null;
        }
        if (listen) {
            this.keyboardSubscription = this.inputEl.keyboardBuffer$.subscribe((pattern) => {
                pattern = pattern.toLocaleLowerCase();
                const options = this.options.toArray();
                const activeIndex = this.activeOption ? this.keyManager.activeItemIndex + 1 : 0;
                for (let i = 0, n = options.length; i < n; i++) {
                    const index = (activeIndex + i) % n;
                    const option = options[index];
                    if (!option.disabled && option.label.toLocaleLowerCase().substr(0, pattern.length) === pattern) {
                        this.keyManager.setActiveItem(option);
                        break;
                    }
                }
            });
        }
    }
    updateMenuHeight() {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            const height = this.dropdownElementRef.nativeElement.offsetHeight;
            overlayRef.updateSize({
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
};
NglCombobox.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NglComboboxService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "label", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "openChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selection", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "multiple", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglCombobox.prototype, "visibleLength", void 0);
__decorate([
    ContentChild(NglComboboxInput, { static: true }),
    __metadata("design:type", NglComboboxInput)
], NglCombobox.prototype, "inputEl", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loading", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loadingMore", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "closeOnSelection", void 0);
__decorate([
    ViewChildren(NglComboboxOption),
    __metadata("design:type", QueryList)
], NglCombobox.prototype, "options", void 0);
__decorate([
    Input('options'),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], NglCombobox.prototype, "data", null);
__decorate([
    ViewChild('overlayOrigin', { static: true }),
    __metadata("design:type", CdkOverlayOrigin)
], NglCombobox.prototype, "overlayOrigin", void 0);
__decorate([
    ViewChild('cdkOverlay'),
    __metadata("design:type", CdkConnectedOverlay)
], NglCombobox.prototype, "cdkOverlay", void 0);
__decorate([
    ViewChild('dropdown'),
    __metadata("design:type", ElementRef)
], NglCombobox.prototype, "dropdownElementRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionValueFn", void 0);
NglCombobox = __decorate([
    Component({
        selector: 'ngl-combobox',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"inputEl.id\"></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-combobox_container\" [class.slds-has-selection]=\"hasLookupSingleSelection\">\n    <div class=\"slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click\" [attr.aria-expanded]=\"open\" aria-haspopup=\"listbox\" role=\"combobox\" [class.slds-is-open]=\"open\" [attr.aria-owns]=\"uid\">\n      <div class=\"slds-combobox__form-element slds-input-has-icon\" role=\"none\" cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [class.slds-input-has-icon_group-right]=\"loading\" [class.slds-input-has-icon_right]=\"!loading\">\n        <ng-content select=\"input\"></ng-content>\n        <div class=\"slds-input__icon-group slds-input__icon-group_right\" *ngIf=\"loading; else iconRight\">\n          <div class=\"slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner\" role=\"status\"><span class=\"slds-assistive-text\">Loading</span>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n          <ng-template [ngTemplateOutlet]=\"iconRight\"></ng-template>\n        </div>\n        <ng-template #iconRight>\n          <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" *ngIf=\"hasLookupSingleSelection; else iconTpl\" type=\"button\" (click)=\"onClearSelection()\" title=\"Remove selected option\">\n            <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\">Remove selected option</span>\n          </button>\n        </ng-template>\n        <ng-template #iconTpl><span class=\"slds-icon_container slds-input__icon slds-input__icon_right\">\n            <svg class=\"slds-icon slds-icon_x-small slds-icon-text-default\" [nglIconName]=\"inputIconRight()\"></svg></span></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayMinWidth]=\"overlayWidth\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"close()\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <div class=\"slds-dropdown slds-dropdown_fluid\" #dropdown [attr.id]=\"uid\" role=\"listbox\" [ngClass]=\"dropdownClass()\" (mousedown)=\"$event.preventDefault()\">\n    <ul class=\"slds-listbox slds-listbox_vertical\" role=\"presentation\">\n      <li *ngFor=\"let d of data; trackBy: trackByOption\" nglComboboxOption [value]=\"d.value\" [label]=\"d.label\" [disabled]=\"d.disabled\" [selected]=\"isSelected(d.value)\"></li>\n      <li class=\"slds-listbox__item\" *ngIf=\"loadingMore\" role=\"presentation\">\n        <div class=\"slds-align_absolute-center slds-p-top_medium\">\n          <div class=\"slds-spinner slds-spinner_x-small slds-spinner_inline\" role=\"status\">\n            <div class=\"slds-assistive-text\">Loading</div>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n        </div>\n      </li>\n      <li class=\"slds-listbox__item\" *ngIf=\"hasNoMatches()\" role=\"presentation\" aria-live=\"polite\">\n        <div class=\"slds-align_absolute-center\"><span role=\"status\">No matches found.</span></div>\n      </li>\n    </ul>\n  </div>\n</ng-template>",
        host: {
            'class.slds-form-element': 'true',
        },
        providers: [NglComboboxService]
    }),
    __metadata("design:paramtypes", [NgZone, ChangeDetectorRef, NglComboboxService])
], NglCombobox);

const DIRECTIVES$6 = [
    NglCombobox,
    NglComboboxOption,
    NglComboboxInput,
];
let NglComboboxesModule = class NglComboboxesModule {
};
NglComboboxesModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$6,
        exports: DIRECTIVES$6,
        imports: [CommonModule, NglInternalOutletModule, NglIconsModule, NglFormsModule, OverlayModule, NglOverlayModule],
    })
], NglComboboxesModule);

let NglDatatableCell = class NglDatatableCell {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableCell.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableCell = __decorate([
    Directive({ selector: '[nglDatatableCell]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglDatatableCell);

let NglDatatableHeadingTemplate = class NglDatatableHeadingTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableHeadingTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableHeadingTemplate = __decorate([
    Directive({ selector: '[nglDatatableHeading]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglDatatableHeadingTemplate);

let NglDatatableColumn = class NglDatatableColumn {
    constructor() {
        this.sortable = false;
        this.truncate = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatableColumn.prototype, "heading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatableColumn.prototype, "key", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "headClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "cellClass", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "sortable", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatatableColumn.prototype, "truncate", void 0);
__decorate([
    ContentChild(NglDatatableCell),
    __metadata("design:type", NglDatatableCell)
], NglDatatableColumn.prototype, "cellTpl", void 0);
__decorate([
    ContentChild(NglDatatableHeadingTemplate),
    __metadata("design:type", NglDatatableHeadingTemplate)
], NglDatatableColumn.prototype, "headingTpl", void 0);
NglDatatableColumn = __decorate([
    Directive({
        // tslint:disable-next-line:directive-selector
        selector: 'ngl-datatable-column',
    })
], NglDatatableColumn);

let NglDatatableLoadingOverlay = class NglDatatableLoadingOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableLoadingOverlay.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableLoadingOverlay = __decorate([
    Directive({ selector: '[nglLoadingOverlay]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglDatatableLoadingOverlay);
let NglDatatableNoRowsOverlay = class NglDatatableNoRowsOverlay {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglDatatableNoRowsOverlay.ctorParameters = () => [
    { type: TemplateRef }
];
NglDatatableNoRowsOverlay = __decorate([
    Directive({ selector: '[nglNoRowsOverlay]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglDatatableNoRowsOverlay);

let NglDatatable = class NglDatatable {
    constructor(detector) {
        this.detector = detector;
        this.data = [];
        this.sortChange = new EventEmitter();
        this.loading = false;
        this.rowClick = new EventEmitter();
        this.dataTrackBy = (index, data) => {
            return this.trackByKey ? data[this.trackByKey] : index;
        };
    }
    get showLoading() {
        return this.loading && this.loadingOverlay;
    }
    columnTrackBy(index, column) {
        return column.key || index;
    }
    onColumnSort(column, order) {
        const key = column.key;
        if (!key) {
            throw new Error(`ng-lightning: No "key" property is set for sortable column "${column.heading}"`);
        }
        this.sortChange.emit({ key, order });
    }
    getColumnSortOrder(column) {
        return this.sort && column.key === this.sort.key ? this.sort.order : null;
    }
    onRowClick(event, data) {
        this.rowClick.emit({ event, data });
    }
    ngAfterContentInit() {
        this._columnsSubscription = this.columns.changes.subscribe(() => this.detector.markForCheck());
    }
    ngOnDestroy() {
        if (this._columnsSubscription) {
            this._columnsSubscription.unsubscribe();
            this._columnsSubscription = null;
        }
    }
};
NglDatatable.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatatable.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatatable.prototype, "trackByKey", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sort", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "sortChange", void 0);
__decorate([
    HostBinding('class.slds-is-relative'),
    Input(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "loading", void 0);
__decorate([
    ContentChild(NglDatatableLoadingOverlay),
    __metadata("design:type", NglDatatableLoadingOverlay)
], NglDatatable.prototype, "loadingOverlay", void 0);
__decorate([
    ContentChild(NglDatatableNoRowsOverlay),
    __metadata("design:type", NglDatatableNoRowsOverlay)
], NglDatatable.prototype, "noRowsOverlay", void 0);
__decorate([
    ContentChildren(NglDatatableColumn),
    __metadata("design:type", QueryList)
], NglDatatable.prototype, "columns", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatatable.prototype, "rowClick", void 0);
NglDatatable = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'table[ngl-datatable]',
        template: "\n<thead>\n  <tr class=\"slds-line-height_reset\">\n    <th *ngFor=\"let col of columns; trackBy:columnTrackBy\" nglDatatableHead scope=\"col\" [heading]=\"col.heading\" [headingTpl]=\"col.headingTpl?.templateRef\" [sortable]=\"col.sortable\" [sortOrder]=\"getColumnSortOrder(col)\" (sort)=\"onColumnSort(col, $event)\" [ngClass]=\"col.headClass\"></th>\n  </tr>\n</thead>\n<tbody>\n  <ng-template #noData>\n    <tr>\n      <td [attr.colspan]=\"columns.length\">\n        <ng-template [ngTemplateOutlet]=\"noRowsOverlay?.templateRef\"></ng-template>\n      </td>\n    </tr>\n  </ng-template>\n  <ng-container *ngIf=\"data &amp;&amp; data.length &gt; 0; else noData\">\n    <tr *ngFor=\"let d of data; let i = index; trackBy:dataTrackBy\" (click)=\"onRowClick($event, d)\">\n      <td *ngFor=\"let col of columns; trackBy:columnTrackBy\" [ngClass]=\"col.cellClass\" nglDatatatableCell_ [row]=\"d\" [column]=\"col\" [index]=\"i\"></td>\n    </tr>\n  </ng-container>\n</tbody>\n<div class=\"ngl-datatable-loading slds-align_absolute-center\" *ngIf=\"showLoading\">\n  <ng-template [ngTemplateOutlet]=\"loadingOverlay.templateRef\"></ng-template>\n</div>",
        host: {
            '[class.slds-table]': 'true',
        },
        styles: [`
    .ngl-datatable-loading {
      position: absolute;
      z-index: 1;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.5)
    }
  `]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglDatatable);

let NglInternalDatatableHeadCell = class NglInternalDatatableHeadCell {
    constructor() {
        this.sort = new EventEmitter();
    }
    get header() {
        return this.headingTpl || this.heading;
    }
    get attrTitle() {
        return this.heading || null;
    }
    get ariaSort() {
        return this.sortOrder ? `${this.sortOrder}ending` : 'none';
    }
    sortChange() {
        this.sort.emit(this.sortOrder === 'desc' ? 'asc' : 'desc');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglInternalDatatableHeadCell.prototype, "heading", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], NglInternalDatatableHeadCell.prototype, "headingTpl", void 0);
__decorate([
    HostBinding('class.slds-is-sortable'),
    Input(),
    __metadata("design:type", Boolean)
], NglInternalDatatableHeadCell.prototype, "sortable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglInternalDatatableHeadCell.prototype, "sortOrder", void 0);
__decorate([
    HostBinding('attr.aria-sort'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglInternalDatatableHeadCell.prototype, "ariaSort", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglInternalDatatableHeadCell.prototype, "sort", void 0);
NglInternalDatatableHeadCell = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'th[nglDatatableHead]',
        template: "<a class=\"slds-th__action slds-text-link_reset\" *ngIf=\"sortable; else baseTpl\" (click)=\"sortChange()\" role=\"button\" tabindex=\"0\"><span class=\"slds-assistive-text\">Sort by:</span>\n  <div class=\"slds-grid slds-grid_vertical-align-center slds-has-flexi-truncate\"><span class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></span><span class=\"slds-icon_container slds-icon-utility-arrowdown\">\n      <svg class=\"slds-icon slds-icon-text-default slds-is-sortable__icon\" nglIconName=\"arrowdown\"></svg></span></div></a>\n<ng-template #baseTpl>\n  <div class=\"slds-truncate\" [attr.title]=\"attrTitle\" [nglInternalOutlet]=\"header\"></div>\n</ng-template>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-is-sorted_asc]': `sortOrder === 'asc'`,
            '[class.slds-is-sorted_desc]': `sortOrder === 'desc'`,
            '[class.slds-is-sorted]': `!!sortOrder`,
        }
    })
], NglInternalDatatableHeadCell);

let NglInternalDatatableCell = class NglInternalDatatableCell {
    get dataLabel() {
        return this.column.heading;
    }
    ngOnChanges() {
        this.context = {
            $implicit: this.value,
            row: this.row,
            index: this.index,
        };
    }
    get value() {
        const { key } = this.column;
        return key ? this.row[key] : null;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInternalDatatableCell.prototype, "row", void 0);
__decorate([
    Input(),
    __metadata("design:type", NglDatatableColumn)
], NglInternalDatatableCell.prototype, "column", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglInternalDatatableCell.prototype, "index", void 0);
__decorate([
    HostBinding('attr.data-label'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglInternalDatatableCell.prototype, "dataLabel", null);
NglInternalDatatableCell = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'td[nglDatatatableCell_]',
        template: "\n<div [class.slds-truncate]=\"column.truncate\" [attr.title]=\"column.truncate ? value : null\">\n  <ng-container *ngIf=\"column.cellTpl; else stringTpl\" [ngTemplateOutlet]=\"column.cellTpl.templateRef\" [ngTemplateOutletContext]=\"context\"></ng-container>\n  <ng-template #stringTpl>{{ value }}</ng-template>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglInternalDatatableCell);

const NGL_DATATABLE_DIRECTIVES = [
    NglDatatable,
    NglDatatableColumn,
    NglDatatableCell,
    NglDatatableHeadingTemplate,
    NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay,
];
let NglDatatablesModule = class NglDatatablesModule {
};
NglDatatablesModule = __decorate([
    NgModule({
        declarations: [NGL_DATATABLE_DIRECTIVES, NglInternalDatatableHeadCell, NglInternalDatatableCell],
        exports: [NGL_DATATABLE_DIRECTIVES],
        imports: [CommonModule, NglIconsModule, NglInternalOutletModule],
    })
], NglDatatablesModule);

let NglClickOutsideDirective = class NglClickOutsideDirective {
    constructor(document, element) {
        this.document = document;
        this.element = element;
        this.clickOutside = new EventEmitter();
    }
    ngAfterViewInit() {
        this.subscription = fromEvent(this.document, 'click').subscribe((e) => {
            if (this.shouldClose(e)) {
                this.clickOutside.emit();
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    shouldClose(event) {
        const element = event.target;
        if ((event instanceof MouseEvent && event.button === 2) || isContainedIn(element, this.ignore)) {
            return false;
        }
        return !isContainedIn(element, this.element.nativeElement);
    }
};
NglClickOutsideDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef }
];
__decorate([
    Output('nglClickOutside'),
    __metadata("design:type", EventEmitter)
], NglClickOutsideDirective.prototype, "clickOutside", void 0);
__decorate([
    Input('nglClickOutsideIgnore'),
    __metadata("design:type", Object)
], NglClickOutsideDirective.prototype, "ignore", void 0);
NglClickOutsideDirective = __decorate([
    Directive({
        selector: '[nglClickOutside]'
    }),
    __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object, ElementRef])
], NglClickOutsideDirective);
function isContainedIn(el, container) {
    if (!container) {
        return false;
    }
    return Array.isArray(container) ? container.some(c => c.contains(el)) : container.contains(el);
}

const DIRECTIVES$7 = [NglClickOutsideDirective];
let NglClickOutsideModule = class NglClickOutsideModule {
};
NglClickOutsideModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: DIRECTIVES$7,
        exports: DIRECTIVES$7,
    })
], NglClickOutsideModule);

class NglDateAdapterBase {
}

const PATTERNS = {
    'big-endian': 'yyyy/MM/dd',
    'little-endian': 'dd/MM/yyyy',
    'middle-endian': 'MM/dd/yyyy',
};
let NglDateAdapter = class NglDateAdapter extends NglDateAdapterBase {
    parse(value, format) {
        const date = parse(value, format, new Date());
        return this.isValidDate(date) ? date : null;
    }
    format(date, format$1) {
        return format(date, format$1);
    }
    pattern(name, delimiter) {
        const pattern = PATTERNS[name];
        return (delimiter && delimiter !== '/') ? pattern.replace(/\//g, delimiter) : pattern;
    }
    isValidDate(value) {
        const dateWrapper = new Date(value);
        return !isNaN(dateWrapper.getDate());
    }
};
NglDateAdapter = __decorate([
    Injectable()
], NglDateAdapter);

/** Injection token that can be used to specify default options. */
const NGL_DATEPICKER_CONFIG = new InjectionToken('ngl-datepicker-config');
class NglDatepickerConfig {
    constructor(locale) {
        this.format = 'big-endian';
        this.delimiter = '/';
        this.dropdownAlign = 'left';
        this.showToday = true;
        this.relativeYearFrom = -100;
        this.relativeYearTo = 10;
        this.openOnInputClick = true;
        this.todayLabel = 'Today';
        this.previousMonthLabel = 'Previous Month';
        this.nextMonthLabel = 'Next Month';
        this.monthNames = getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.dayNamesShort = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        this.dayNamesLong = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
        this.firstDayOfWeek = getLocaleFirstDayOfWeek(locale);
    }
}

function parseDate(date) {
    if (!date) {
        return null;
    }
    return { year: date.getFullYear(), month: date.getMonth(), day: date.getDate() };
}
function isEqualDate(d1, d2) {
    return d1 && d2 && d1.day === d2.day && d1.month === d2.month && d1.year === d2.year;
}
function getToday() {
    const today = new Date();
    return { year: today.getFullYear(), month: today.getMonth(), day: today.getDate() };
}
function numberOfDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}
// Split array into smaller arrays
function split(arr, size = 7) {
    const arrays = [];
    while (arr.length > 0) {
        arrays.push(arr.splice(0, size));
    }
    return arrays;
}
function isDisabled(d, disabledCallback, min, max) {
    const date = new Date(d.year, d.month, d.day);
    return (disabledCallback && disabledCallback(date)) ||
        (min && compareDate(d, min) < 0) ||
        (max && compareDate(d, max) > 0);
}
function compareDate(d1, d2) {
    if (isEqualDate(d1, d2)) {
        return 0;
    }
    const keys = ['year', 'month', 'day'];
    for (let i = 0; i < 3; i++) {
        const key = keys[i];
        const diff = d1[key] - d2[key];
        if (diff !== 0) {
            return diff > 0 ? 1 : -1;
        }
    }
}
function isSameMonth(d1, d2) {
    return d1.year === d2.year && d1.month === d2.month;
}

const NGL_DATEPICKER_INPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
const NGL_DATEPICKER_INPUT_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NglDatepickerInput),
    multi: true
};
let NglDatepickerInput = class NglDatepickerInput {
    constructor(defaultConfig, locale, element, renderer, cd, hostService, ngZone, focusTrapFactory, adapter) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        this.hostService = hostService;
        this.ngZone = ngZone;
        this.focusTrapFactory = focusTrapFactory;
        this.adapter = adapter;
        /**
         * Placeholder of input.
         */
        this.placeholder = '';
        /**
         * Whether input is readonly and calendar is available for date selection.
         */
        this.readonlyInput = false;
        /**
         * Emits when selected date changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * Text for button to open calendar.
         */
        this.selectDateLabel = 'Select a date';
        this.dateDisabled = null;
        this.uid = uniqueId('datepicker-input');
        this._open = new BehaviorSubject(false);
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger');
        this.renderer.addClass(this.element.nativeElement, 'slds-dropdown-trigger_click');
        this.config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.format = this.config.format;
        this.delimiter = this.config.delimiter;
        this.setPositions(this.config.dropdownAlign);
        this.monthNames = this.config.monthNames;
        this.dayNamesShort = this.config.dayNamesShort;
        this.dayNamesLong = this.config.dayNamesLong;
        this.firstDayOfWeek = this.config.firstDayOfWeek;
        this.showToday = this.config.showToday;
        this.relativeYearFrom = this.config.relativeYearFrom;
        this.relativeYearTo = this.config.relativeYearTo;
        this.openOnInputClick = this.config.openOnInputClick;
        this.todayLabel = this.config.todayLabel;
        this.previousMonthLabel = this.config.previousMonthLabel;
        this.nextMonthLabel = this.config.nextMonthLabel;
    }
    /**
     * The date value.
     */
    set value(value) {
        if (value === this._value) {
            return;
        }
        this._value = value;
        if (this.value instanceof Date) {
            this.date = this.value;
            this.formatInputValue();
        }
        else {
            this.updateInputValue(value || '');
        }
    }
    get value() {
        return this._value;
    }
    set open(open) {
        this._open.next(open);
    }
    get open() {
        return this._open.value;
    }
    validate(c) {
        const value = c.value;
        if (!value) {
            return null;
        }
        if (!(this.value instanceof Date)) {
            return { 'nglDatepickerInput': { invalid: c.value } };
        }
        const date = parseDate(value);
        if (isDisabled(date, this.dateDisabled, parseDate(this.min), parseDate(this.max))) {
            return { 'nglDatepickerInput': { disabled: c.value } };
        }
        return null;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(disabled) { this.disabled = disabled; }
    onBlur() {
        if (this.value instanceof Date) {
            this.updateInputValue();
        }
        this.onTouched();
    }
    ngOnInit() {
        this._open.subscribe(() => {
            this.setHostClass();
            this.cd.markForCheck();
        });
    }
    ngOnChanges(changes) {
        if (changes.format || changes.delimiter) {
            this.setPattern();
            if (this.value instanceof Date) {
                this.updateInputValue();
            }
        }
        if (changes.dropdownAlign) {
            this.setPositions(this.dropdownAlign);
        }
        if (changes.min || changes.max) {
            this.validatorChange();
        }
    }
    ngOnDestroy() {
        this.closeCalendar(false);
    }
    onKeyboardInput(evt) {
        const keyCode = evt.keyCode;
        if (!this.open && (keyCode === DOWN_ARROW || keyCode === UP_ARROW)) {
            this.openCalendar();
        }
    }
    onInputChange(value) {
        const date = this.dateParse(value);
        this.emitSelection(date || value);
    }
    openCalendar() {
        this.open = true;
    }
    onAttach() {
        this.focusTrap = this.focusTrapFactory.create(this.cdkOverlay.overlayRef.overlayElement);
    }
    onDetach() {
        if (this.open) {
            this.closeCalendar();
        }
    }
    closeCalendar(focusInput = true) {
        this.open = false;
        if (this.focusTrap) {
            this.focusTrap.destroy();
            this.focusTrap = null;
        }
        if (focusInput) {
            this.inputEl.nativeElement.focus();
        }
    }
    onTriggerClick(origin) {
        if (origin === 'input' && !this.openOnInputClick) {
            return;
        }
        if (!this.open) {
            this.openCalendar();
        }
        else {
            this.closeCalendar(false);
        }
    }
    pickerSelection(date) {
        this.emitSelection(date);
        this.closeCalendar();
    }
    updateDatepickerSize(width, height) {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            overlayRef.updateSize({
                minWidth: width,
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
    setPositions(align) {
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS[align]];
    }
    formatInputValue() {
        const inputValue = this.inputEl.nativeElement.value;
        if (!inputValue) {
            this.updateInputValue();
        }
        else {
            const date = this.value;
            const dateNow = this.dateParse(inputValue);
            if (!dateNow || dateNow.getFullYear() !== date.getFullYear() || dateNow.getMonth() !== date.getMonth() || dateNow.getDate() !== date.getDate()) {
                this.updateInputValue();
            }
        }
    }
    updateInputValue(value = this.dateFormat(this.value)) {
        this.renderer.setProperty(this.inputEl.nativeElement, 'value', value || '');
    }
    dateParse(value) {
        return this.adapter.parse(value, this.getPattern());
    }
    dateFormat(date) {
        return this.adapter.format(date, this.getPattern());
    }
    getPattern() {
        if (!this.pattern) {
            this.setPattern();
        }
        return this.pattern;
    }
    setPattern() {
        this.pattern = this.adapter.pattern(this.format || this.config.format, this.delimiter || this.config.delimiter);
    }
    emitSelection(value) {
        this.valueChange.emit(value);
        if (this.onChange) {
            this.value = value;
            this.onChange(value);
        }
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-is-open`]: this.open,
        });
    }
};
NglDatepickerInput.ctorParameters = () => [
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: HostService },
    { type: NgZone },
    { type: FocusTrapFactory },
    { type: NglDateAdapter }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "delimiter", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "disabled", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "readonlyInput", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "dropdownAlign", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglDatepickerInput.prototype, "value", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "openOnInputClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "valueChange", void 0);
__decorate([
    ViewChild('inputEl', { static: true }),
    __metadata("design:type", ElementRef)
], NglDatepickerInput.prototype, "inputEl", void 0);
__decorate([
    ViewChild('cdkOverlay'),
    __metadata("design:type", CdkConnectedOverlay)
], NglDatepickerInput.prototype, "cdkOverlay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepickerInput.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepickerInput.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerInput.prototype, "selectDateLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "monthNames", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerInput.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepickerInput.prototype, "showToday", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepickerInput.prototype, "dateDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "relativeYearFrom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerInput.prototype, "relativeYearTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "todayLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "previousMonthLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepickerInput.prototype, "nextMonthLabel", void 0);
NglDatepickerInput = __decorate([
    Component({
        selector: 'ngl-datepicker-input',
        template: "\n<label class=\"slds-form-element__label\" *ngIf=\"label\" [attr.for]=\"uid\" [nglInternalOutlet]=\"label\"></label>\n<div class=\"slds-form-element__control slds-input-has-icon slds-input-has-icon_right\" #formEl>\n  <input class=\"slds-input\" #inputEl cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [id]=\"uid\" type=\"text\" autocomplete=\"off\" [placeholder]=\"placeholder\" [disabled]=\"disabled\" [readOnly]=\"readonlyInput\" (click)=\"onTriggerClick('input')\" (keydown)=\"onKeyboardInput($event)\" (input)=\"onInputChange($event.target.value)\" (blur)=\"onBlur()\">\n  <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" type=\"button\" [title]=\"selectDateLabel\" [disabled]=\"disabled\" (click)=\"onTriggerClick('button')\">\n    <svg class=\"slds-button__icon\" nglIconName=\"utility:event\"></svg><span class=\"slds-assistive-text\">{{ selectDateLabel }}</span>\n  </button>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"closeCalendar(false)\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <ngl-datepicker class=\"slds-dropdown\" [attr.aria-hidden]=\"!open\" [date]=\"date\" [monthNames]=\"monthNames\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\" [firstDayOfWeek]=\"firstDayOfWeek\" [showToday]=\"showToday\" [min]=\"min\" [max]=\"max\" [relativeYearFrom]=\"relativeYearFrom\" [relativeYearTo]=\"relativeYearTo\" [todayLabel]=\"todayLabel\" [previousMonthLabel]=\"previousMonthLabel\" [nextMonthLabel]=\"nextMonthLabel\" [dateDisabled]=\"dateDisabled\" (dateChange)=\"pickerSelection($event)\" (nglClickOutside)=\"closeCalendar(false)\" [nglClickOutsideIgnore]=\"formEl\"></ngl-datepicker>\n</ng-template>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [NGL_DATEPICKER_INPUT_VALUE_ACCESSOR, NGL_DATEPICKER_INPUT_VALIDATOR, HostService]
    }),
    __param(0, Optional()), __param(0, Inject(NGL_DATEPICKER_CONFIG)),
    __param(1, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [NglDatepickerConfig, String, ElementRef,
        Renderer2,
        ChangeDetectorRef,
        HostService,
        NgZone,
        FocusTrapFactory,
        NglDateAdapter])
], NglDatepickerInput);

let NglDay = class NglDay {
    constructor(el) {
        this.el = el;
    }
    get tabindex() {
        return this.isActive ? 0 : -1;
    }
    focus() {
        this.el.nativeElement.focus();
    }
};
NglDay.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('nglDay'),
    __metadata("design:type", Object)
], NglDay.prototype, "date", void 0);
__decorate([
    HostBinding('class.slds-disabled-text'),
    HostBinding('attr.aria-disabled'),
    Input(),
    __metadata("design:type", Boolean)
], NglDay.prototype, "nglDayDisabled", void 0);
__decorate([
    HostBinding('class.slds-is-selected'),
    HostBinding('attr.aria-selected'),
    Input(),
    __metadata("design:type", Boolean)
], NglDay.prototype, "nglDaySelected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDay.prototype, "isActive", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglDay.prototype, "tabindex", null);
NglDay = __decorate([
    Directive({
        selector: 'td[nglDay]',
    }),
    __metadata("design:paramtypes", [ElementRef])
], NglDay);

let NglDatepickerMonth = class NglDatepickerMonth {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.dateDisabled = null;
        this.selectDate = new EventEmitter();
    }
    indexTrackBy(index) {
        return index;
    }
    dateTrackBy(index, { year, month, day }) {
        return `${day}-${month}-${year}`;
    }
    onSelect(date) {
        if (date.disabled)
            return;
        this.selectDate.emit(date);
    }
    ngOnChanges(changes) {
        if (changes.year || changes.month || changes.firstDayOfWeek) {
            this.renderView();
            return;
        }
        if (changes.day) {
            this.updateActive();
        }
        if (changes.selected) {
            this.updateSelected();
        }
        if (changes.minDate || changes.maxDate || changes.dateDisabled) {
            this.updateDisabled();
        }
    }
    focusActiveDay() {
        this.ngZone.runOutsideAngular(() => {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const active = this.days.find((d) => d.isActive);
                if (active) {
                    active.focus();
                }
            });
        });
    }
    renderView() {
        const days = this.daysInMonth(this.year, this.month);
        Array.prototype.unshift.apply(days, this.daysInPreviousMonth(this.year, this.month));
        const nextMonth = this.daysInNextMonth(this.year, this.month + 1, days.length);
        if (nextMonth) {
            Array.prototype.push.apply(days, nextMonth);
        }
        this.weeks = split(days);
    }
    daysInMonth(year, month) {
        const last = numberOfDaysInMonth(year, month);
        return this.getDayObjects(year, month, 1, last);
    }
    daysInPreviousMonth(year, month) {
        const firstIndex = (new Date(year, month, 1)).getDay();
        const last = new Date(year, month, 0).getDate();
        const numDays = (7 + firstIndex - this.firstDayOfWeek) % 7;
        return this.getDayObjects(year, month - 1, last - numDays + 1, last, false);
    }
    daysInNextMonth(year, month, numOfDays) {
        if (numOfDays % 7 === 0) {
            return;
        }
        return this.getDayObjects(year, month, 1, 7 - (numOfDays % 7), false);
    }
    getDayObjects(year, month, from, to, isCurrentMonth = true) {
        const today = getToday();
        const days = [];
        for (let day = from; day <= to; day++) {
            const d = {
                year,
                month,
                day,
                isCurrentMonth,
                today: isEqualDate(today, { year, month, day }),
            };
            d.active = this.isActive(d);
            d.selected = this.isSelected(d);
            d.disabled = this.isDisabled(d);
            days.push(d);
        }
        return days;
    }
    updateActive() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.active = this.isActive(day);
            });
        });
    }
    isActive(day) {
        return day.isCurrentMonth && day.day === this.day;
    }
    updateSelected() {
        this.weeks.forEach((days) => {
            days.forEach((day) => {
                day.selected = this.isSelected(day);
            });
        });
    }
    isSelected(day) {
        return isEqualDate(this.selected, day);
    }
    updateDisabled() {
        this.weeks.forEach((days) => {
            days.forEach(day => {
                day.disabled = this.isDisabled(day);
            });
        });
    }
    /** Date filter for the month */
    isDisabled(d) {
        return !d.isCurrentMonth || isDisabled(d, this.dateDisabled, this.minDate, this.maxDate);
    }
};
NglDatepickerMonth.ctorParameters = () => [
    { type: NgZone }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "selected", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "year", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "month", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "day", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerMonth.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "minDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "maxDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepickerMonth.prototype, "dateDisabled", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerMonth.prototype, "selectDate", void 0);
__decorate([
    ViewChildren(NglDay),
    __metadata("design:type", QueryList)
], NglDatepickerMonth.prototype, "days", void 0);
NglDatepickerMonth = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: '[nglDatepickerMonth]',
        template: "\n<tr *ngFor=\"let week of weeks; trackBy:indexTrackBy\">\n  <td *ngFor=\"let date of week; trackBy:dateTrackBy\" [class.slds-is-today]=\"date.today\" [isActive]=\"date.active\" [nglDay]=\"date\" [nglDaySelected]=\"date.selected\" [nglDayDisabled]=\"date.disabled\" (click)=\"onSelect(date)\" role=\"gridcell\"><span class=\"slds-day\">{{ date.day }}</span></td>\n</tr>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [NgZone])
], NglDatepickerMonth);

const KEYBOARD_MOVES = {
    [UP_ARROW]: ['Move', -7],
    [LEFT_ARROW]: ['Move', -1],
    [DOWN_ARROW]: ['Move', 7],
    [RIGHT_ARROW]: ['Move', 1],
    [PAGE_UP]: ['MoveMonth', -1],
    [PAGE_DOWN]: ['MoveMonth', 1],
    [HOME]: ['MoveTo', 1],
    [END]: ['MoveTo', 31],
};
let NglDatepicker = class NglDatepicker {
    constructor(dtInput, defaultConfig, locale, element) {
        this.dtInput = dtInput;
        this.element = element;
        this.dateDisabled = null;
        this.dateChange = new EventEmitter();
        this.uid = uniqueId('datepicker');
        const config = Object.assign(Object.assign({}, new NglDatepickerConfig(locale)), defaultConfig);
        this.monthNames = config.monthNames;
        this.dayNamesShort = config.dayNamesShort;
        this.dayNamesLong = config.dayNamesLong;
        this.firstDayOfWeek = config.firstDayOfWeek;
        this.showToday = config.showToday;
        this.relativeYearFrom = config.relativeYearFrom;
        this.relativeYearTo = config.relativeYearTo;
        this.todayLabel = config.todayLabel;
        this.previousMonthLabel = config.previousMonthLabel;
        this.nextMonthLabel = config.nextMonthLabel;
    }
    set date(date) {
        this._date = parseDate(date);
    }
    ngOnInit() {
        this.setMinMaxDates();
        this.setCurrent(this._date || getToday());
    }
    ngOnChanges(changes) {
        if ((changes.date && changes.date.isFirstChange()) ||
            changes.relativeYearFrom || changes.relativeYearTo ||
            changes.min || changes.max) {
            this.setMinMaxDates();
        }
        if (changes.date) {
            this.setCurrent(this._date);
        }
    }
    moveYear(year) {
        this.setCurrent({ year: +year });
    }
    moveMonth(diff) {
        this.moveCalendar('MoveMonth', diff);
    }
    keyboardHandler(evt) {
        const keyCode = evt.keyCode;
        if (keyCode === ENTER) {
            trapEvent(evt);
            if (!this.isDisabledDate(this.current)) {
                this.select(this.current);
            }
            return;
        }
        const move = KEYBOARD_MOVES[keyCode];
        if (!move) {
            return;
        }
        // Handle keyboard event inside datepicker
        trapEvent(evt);
        const [code, param] = move;
        this.moveCalendar(code, param);
        this.focusActiveDay();
    }
    select(date) {
        if (date.disabled) {
            return;
        }
        const { year, month, day } = date;
        this.dateChange.emit(new Date(year, month, day));
    }
    selectToday() {
        const today = getToday();
        if (this.isDisabledDate(today)) {
            this.setCurrent(today);
        }
        else {
            this.dateChange.emit(new Date());
        }
    }
    ngAfterViewInit() {
        if (this.dtInput) {
            const el = this.element.nativeElement;
            this.dtInput.updateDatepickerSize(el.offsetWidth, el.offsetHeight);
            this.focusActiveDay();
        }
    }
    /** Whether the previous period button is disabled. */
    previousDisabled() {
        return this.minDate && isSameMonth(this.current, this.minDate);
    }
    /** Whether the next period button is disabled. */
    nextDisabled() {
        return this.maxDate && isSameMonth(this.current, this.maxDate);
    }
    focusActiveDay() {
        this.monthView.focusActiveDay();
    }
    moveCalendar(code, param) {
        const { year, month, day } = this.current;
        const date = new Date(year, month, day, 12);
        if (code === 'Move') {
            date.setDate(day + (+param));
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day: date.getDate() });
        }
        else if (code === 'MoveMonth') {
            date.setMonth(month + (+param), 1);
            this.setCurrent({ year: date.getFullYear(), month: date.getMonth(), day });
        }
        else if (code === 'MoveTo') {
            this.setCurrent({ day: +param });
        }
    }
    setCurrent(d, doRender = true) {
        this.current = Object.assign(Object.assign({}, this.current), d);
        // Keep current inside minimum/maximum range
        if (compareDate(this.current, this.minDate) < 0) {
            this.current = this.minDate;
        }
        else if (compareDate(this.current, this.maxDate) > 0) {
            this.current = this.maxDate;
        }
        if (doRender) {
            this.render();
        }
    }
    render() {
        const { year, month, day } = this.current;
        this.monthLabel = this.monthNames[month];
        // Keep current day inside limits of this month
        this.setCurrent({ day: Math.min(day, numberOfDaysInMonth(year, month)) }, false);
    }
    /** Date filter for the month */
    isDisabledDate(date) {
        return isDisabled(date, this.dateDisabled, this.minDate, this.maxDate);
    }
    setMinMaxDates() {
        const { year } = getToday();
        this.minDate = this.min ? parseDate(this.min) : { year: year + this.relativeYearFrom, month: 0, day: 1 };
        this.maxDate = this.max ? parseDate(this.max) : { year: year + this.relativeYearTo, month: 11, day: 31 };
    }
};
NglDatepicker.ctorParameters = () => [
    { type: NglDatepickerInput, decorators: [{ type: Optional }, { type: Inject, args: [NglDatepickerInput,] }] },
    { type: NglDatepickerConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_DATEPICKER_CONFIG,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "monthNames", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepicker.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], NglDatepicker.prototype, "dateDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date),
    __metadata("design:paramtypes", [Date])
], NglDatepicker.prototype, "date", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepicker.prototype, "dateChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglDatepicker.prototype, "showToday", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "firstDayOfWeek", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "relativeYearFrom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepicker.prototype, "relativeYearTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepicker.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NglDatepicker.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "todayLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "previousMonthLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDatepicker.prototype, "nextMonthLabel", void 0);
__decorate([
    ViewChild(NglDatepickerMonth),
    __metadata("design:type", NglDatepickerMonth)
], NglDatepicker.prototype, "monthView", void 0);
NglDatepicker = __decorate([
    Component({
        selector: 'ngl-datepicker',
        template: "\n<div class=\"slds-datepicker__filter slds-grid\">\n  <div class=\"slds-datepicker__filter_month slds-grid slds-grid_align-spread slds-grow\">\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(-1)\" [disabled]=\"previousDisabled()\" [title]=\"previousMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"left\"></svg><span class=\"slds-assistive-text\">{{ previousMonthLabel }}</span>\n      </button>\n    </div>\n    <h2 class=\"slds-align-middle\" [id]=\"uid + '_month'\" aria-live=\"assertive\" aria-atomic=\"true\">{{ monthLabel }}</h2>\n    <div class=\"slds-align-middle\">\n      <button class=\"slds-button slds-button_icon-container\" type=\"button\" (click)=\"moveMonth(1)\" [disabled]=\"nextDisabled()\" [title]=\"nextMonthLabel\">\n        <svg class=\"slds-button__icon\" nglIconName=\"right\"></svg><span class=\"slds-assistive-text\">{{ nextMonthLabel }}</span>\n      </button>\n    </div>\n  </div>\n  <ngl-date-year class=\"slds-shrink-none\" [year]=\"current.year\" [from]=\"minDate\" [to]=\"maxDate\" (yearChange)=\"moveYear($event)\"></ngl-date-year>\n</div>\n<table class=\"datepicker__month\" role=\"grid\" [attr.aria-labelledby]=\"uid + '_month'\" (keydown)=\"keyboardHandler($event)\">\n  <thead>\n    <tr nglWeekdays [firstDayOfWeek]=\"firstDayOfWeek\" [dayNamesShort]=\"dayNamesShort\" [dayNamesLong]=\"dayNamesLong\"></tr>\n  </thead>\n  <tbody *ngIf=\"current\" nglDatepickerMonth [year]=\"current.year\" [month]=\"current.month\" [day]=\"current.day\" [selected]=\"_date\" [firstDayOfWeek]=\"firstDayOfWeek\" [minDate]=\"minDate\" [maxDate]=\"maxDate\" [dateDisabled]=\"dateDisabled\" (selectDate)=\"select($event)\"></tbody>\n</table>\n<button class=\"slds-button slds-align_absolute-center slds-text-link\" *ngIf=\"showToday\" (click)=\"selectToday()\">{{ todayLabel }}</button>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-datepicker]': 'true',
        },
        styles: [`:host { display: block; }`]
    }),
    __param(0, Optional()), __param(0, Inject(NglDatepickerInput)),
    __param(1, Optional()), __param(1, Inject(NGL_DATEPICKER_CONFIG)),
    __param(2, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [NglDatepickerInput,
        NglDatepickerConfig, String, ElementRef])
], NglDatepicker);

let NglDatepickerWeekdays = class NglDatepickerWeekdays {
    constructor() {
        this.weekdays = [];
    }
    ngOnChanges(changes) {
        this.weekdays = [];
        for (let i = 0; i < 7; i++) {
            const offset = (this.firstDayOfWeek + i) % 7;
            this.weekdays.push({
                id: `weekday-${i}`,
                label: this.dayNamesShort[offset],
                title: this.dayNamesLong[offset],
            });
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerWeekdays.prototype, "dayNamesShort", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NglDatepickerWeekdays.prototype, "dayNamesLong", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NglDatepickerWeekdays.prototype, "firstDayOfWeek", void 0);
NglDatepickerWeekdays = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'tr[nglWeekdays]',
        template: "\n<th *ngFor=\"let day of weekdays\" [id]=\"day.id\" scope=\"col\"><abbr [title]=\"day.title\">{{day.label}}</abbr></th>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDatepickerWeekdays);

let NglDatepickerYear = class NglDatepickerYear {
    constructor() {
        this.uid = uniqueId('datepicker_year');
        this.yearChange = new EventEmitter();
    }
    change($event) {
        this.yearChange.emit($event);
    }
    ngOnChanges() {
        this.range = this.getRange();
    }
    getRange() {
        const minYear = Math.min(this.from.year, this.year);
        const maxYear = Math.max(this.to.year, this.year);
        const size = maxYear - minYear;
        return Array.apply(null, { length: size + 1 }).map((value, index) => minYear + index);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "to", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglDatepickerYear.prototype, "year", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglDatepickerYear.prototype, "yearChange", void 0);
NglDatepickerYear = __decorate([
    Component({
        selector: 'ngl-date-year',
        template: "\n<label class=\"slds-assistive-text\" [attr.for]=\"uid\">Pick a Year</label>\n<div class=\"slds-select_container\">\n  <select class=\"slds-select\" [id]=\"uid\" [ngModel]=\"year\" (ngModelChange)=\"change($event)\">\n    <option *ngFor=\"let yr of range\" [value]=\"yr\">{{yr}}</option>\n  </select>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDatepickerYear);

const EXPORTS = [
    NglDatepicker, NglDatepickerInput
];
let NglDatepickersModule = class NglDatepickersModule {
};
NglDatepickersModule = __decorate([
    NgModule({
        declarations: [...EXPORTS, NglDay, NglDatepickerWeekdays, NglDatepickerYear, NglDatepickerMonth],
        exports: EXPORTS,
        imports: [
            CommonModule,
            FormsModule,
            NglIconsModule,
            NglInternalOutletModule,
            OverlayModule,
            NglClickOutsideModule,
            NglOverlayModule,
        ],
        providers: [NglDateAdapter],
    })
], NglDatepickersModule);

class BaseDynamicIconComponent {
}
__decorate([
    Input(),
    __metadata("design:type", String)
], BaseDynamicIconComponent.prototype, "alternativeText", void 0);

let NglDynamicIcon = class NglDynamicIcon extends BaseDynamicIconComponent {
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDynamicIcon.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglDynamicIcon.prototype, "option", void 0);
NglDynamicIcon = __decorate([
    Component({
        selector: 'ngl-dynamic-icon',
        template: "\n<ng-container [ngSwitch]=\"type\">\n  <ngl-dynamic-icon-ellie *ngSwitchCase=\"'ellie'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-ellie>\n  <ngl-dynamic-icon-eq *ngSwitchCase=\"'eq'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-eq>\n  <ngl-dynamic-icon-score *ngSwitchCase=\"'score'\" [option]=\"option\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-score>\n  <ngl-dynamic-icon-waffle *ngSwitchCase=\"'waffle'\" [alternativeText]=\"alternativeText\"></ngl-dynamic-icon-waffle>\n</ng-container>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDynamicIcon);

let NglDynamicIconEllie = class NglDynamicIconEllie extends BaseDynamicIconComponent {
};
NglDynamicIconEllie = __decorate([
    Component({
        selector: 'ngl-dynamic-icon-ellie',
        template: "<span class=\"slds-icon-ellie slds-is-animated\">\n  <svg viewbox=\"0 0 280 14\" aria-hidden=\"true\">\n    <circle cx=\"7\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"7\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"21\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"35\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"49\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"63\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"77\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"91\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"105\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"119\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"133\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"147\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"161\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"175\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"189\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"203\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"217\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"231\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"245\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"259\" cy=\"7\" r=\"3\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"4\"></circle>\n    <circle cx=\"273\" cy=\"7\" r=\"3\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDynamicIconEllie);

let NglDynamicIconEq = class NglDynamicIconEq extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'play';
    }
    get option() {
        return this._option;
    }
    isAnimated() {
        return this.option !== 'stop';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglDynamicIconEq.prototype, "option", null);
NglDynamicIconEq = __decorate([
    Component({
        selector: 'ngl-dynamic-icon-eq',
        template: "\n<div class=\"slds-icon-eq\" [class.slds-is-animated]=\"isAnimated()\">\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div>\n  <div class=\"slds-icon-eq__bar\"></div><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDynamicIconEq);

let NglDynamicIconScore = class NglDynamicIconScore extends BaseDynamicIconComponent {
    set option(option) {
        this._option = option || 'positive';
    }
    get option() {
        return this._option;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglDynamicIconScore.prototype, "option", null);
NglDynamicIconScore = __decorate([
    Component({
        selector: 'ngl-dynamic-icon-score',
        template: "<span class=\"slds-icon-score\" [attr.data-slds-state]=\"option\">\n  <svg class=\"slds-icon-score__positive\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg>\n  <svg class=\"slds-icon-score__negative\" viewBox=\"0 0 5 5\" aria-hidden=\"true\">\n    <circle cx=\"50%\" cy=\"50%\" r=\"1.875\"></circle>\n  </svg><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></span>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDynamicIconScore);

let NglDynamicIconWaffle = class NglDynamicIconWaffle extends BaseDynamicIconComponent {
};
NglDynamicIconWaffle = __decorate([
    Component({
        selector: 'ngl-dynamic-icon-waffle',
        template: "\n<button class=\"slds-button slds-icon-waffle_container\" type=\"button\"><span class=\"slds-icon-waffle\"><span class=\"slds-r1\"></span><span class=\"slds-r2\"></span><span class=\"slds-r3\"></span><span class=\"slds-r4\"></span><span class=\"slds-r5\"></span><span class=\"slds-r6\"></span><span class=\"slds-r7\"></span><span class=\"slds-r8\"></span><span class=\"slds-r9\"></span></span><span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{alternativeText}}</span></button>",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], NglDynamicIconWaffle);

const NGL_DYNAMIC_ICON_DIRECTIVES = [
    NglDynamicIcon,
    NglDynamicIconEllie,
    NglDynamicIconEq,
    NglDynamicIconScore,
    NglDynamicIconWaffle,
];
let NglDynamicIconsModule = class NglDynamicIconsModule {
};
NglDynamicIconsModule = __decorate([
    NgModule({
        declarations: NGL_DYNAMIC_ICON_DIRECTIVES,
        exports: NGL_DYNAMIC_ICON_DIRECTIVES,
        imports: [CommonModule],
    })
], NglDynamicIconsModule);

let NglFile = class NglFile {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.renderer.addClass(this.element.nativeElement, 'slds-file');
        this.renderer.addClass(this.element.nativeElement, 'slds-file_card');
    }
};
NglFile.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('class.slds-has-title'),
    Input(),
    __metadata("design:type", Object)
], NglFile.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglFile.prototype, "iconName", void 0);
NglFile = __decorate([
    Component({
        selector: 'ngl-file',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<figure>\n  <ng-content></ng-content>\n  <figcaption class=\"slds-file__title slds-file__title_card\" *ngIf=\"text\">\n    <div class=\"slds-media slds-media_small slds-media_center\">\n      <div class=\"slds-media__figure slds-line-height_reset\" *ngIf=\"iconName\">\n        <ngl-icon [iconName]=\"iconName\"></ngl-icon>\n      </div>\n      <div class=\"slds-media__body\"><span class=\"slds-file__text slds-truncate\" [title]=\"text\" [nglInternalOutlet]=\"text\"></span></div>\n    </div>\n  </figcaption>\n</figure>"
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFile);

let NglFileCrop = class NglFileCrop {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.cropClass = 'slds-file__crop';
        // this.renderer.addClass(this.element.nativeElement, this.cropClass);
    }
    set nglFileCrop(ratio) {
        const nativeElement = this.element.nativeElement;
        if (this.currentRatio) {
            this.renderer.removeClass(nativeElement, `${this.cropClass}`);
            this.renderer.removeClass(nativeElement, `${this.cropClass}_${this.currentRatio}`);
        }
        if (ratio) {
            this.renderer.addClass(nativeElement, `${this.cropClass}`);
            this.renderer.addClass(nativeElement, `${this.cropClass}_${ratio}`);
        }
        this.currentRatio = ratio;
    }
};
NglFileCrop.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglFileCrop.prototype, "nglFileCrop", null);
NglFileCrop = __decorate([
    Directive({
        selector: '[nglFileCrop]',
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFileCrop);

let NglFilesModule = class NglFilesModule {
};
NglFilesModule = __decorate([
    NgModule({
        declarations: [NglFile, NglFileCrop],
        exports: [NglFile, NglFileCrop],
        imports: [CommonModule, NglIconsModule, NglInternalOutletModule],
    })
], NglFilesModule);

const FILE_EXT_REG = /(^[.]\w*)$/m;
function isFileTypeAccepted(accept, file) {
    if (typeof accept === 'string') {
        accept = accept.split(',');
    }
    return accept.some((acc) => {
        if (FILE_EXT_REG.test(acc)) {
            return acc === `.${file.name.split('.').pop()}`;
        }
        else {
            return (new RegExp(acc.replace('*', '.\*'))).test(file.type);
        }
    });
}

var NglFileUpload_1;
let NglFileUpload = NglFileUpload_1 = class NglFileUpload {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * File types that can be accepted. See [input accept Attribute](https://www.w3schools.com/tags/att_input_accept.asp).
         */
        this.accept = null;
        /**
         * Whether file selection is disabled.
         */
        this.disabled = false;
        /**
          * How many files can be selected simultaneously. `0` means unlimited.
          */
        this.maxFiles = 1;
        /**
         * File size limit in bytes. `0` means unlimited.
         */
        this.maxFilesize = 0;
        /**
         * Message to display when there is in an error state.
         */
        this.error = null;
        /**
         * Text for button to open file selector.
         */
        this.uploadButtonLabel = 'Upload Files';
        /**
         * Text to display inside drop zone.
         */
        this.dropZoneLabel = 'or Drop Files';
        this.uid = uniqueId('file-upload');
        this.isDragOver = false;
        this.files = [];
        this.onChange = null;
        this.onTouched = () => { };
        this.validatorChange = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    writeValue(value) {
        this.files = value;
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    registerOnValidatorChange(fn) { this.validatorChange = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    validate(c) {
        const files = c.value;
        if (!files || files.length === 0) {
            return null;
        }
        if (this.maxFiles > 0 && files.length > this.maxFiles) {
            return { nglFileUpload: { maxFiles: files.length } };
        }
        for (let i = 0, n = files.length; i < n; i++) {
            const file = files[i];
            if (this.accept && !isFileTypeAccepted(this.accept, file)) {
                return { nglFileUpload: { invalidType: file } };
            }
            if (this.maxFilesize && file.size > this.maxFilesize) {
                return { nglFileUpload: { maxFilesize: file } };
            }
        }
        return null;
    }
    ngOnChanges(changes) {
        if (changes['maxFiles'] || changes['maxFilesize'] || changes['accept']) {
            this.validatorChange();
        }
    }
    onDropZone(evt) {
        trapEvent(evt);
        if (this.disabled) {
            return;
        }
        this.isDragOver = evt.type === 'dragover';
        if (evt.type === 'drop' && evt.dataTransfer) {
            this.select(evt.dataTransfer.files);
        }
    }
    onInputChange(files) {
        this.select(files);
    }
    select(files) {
        this.onChange(Array.from(files));
    }
};
NglFileUpload.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "accept", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "disabled", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "maxFiles", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "maxFilesize", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "error", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "uploadButtonLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglFileUpload.prototype, "dropZoneLabel", void 0);
NglFileUpload = NglFileUpload_1 = __decorate([
    Component({
        selector: 'ngl-file-upload',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "<span class=\"slds-form-element__label\" *ngIf=\"label\" [id]=\"uid + '-primary-label'\" [nglInternalOutlet]=\"label\"></span>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-file-selector slds-file-selector_files\">\n    <div class=\"slds-file-selector__dropzone\" [class.slds-has-drag-over]=\"isDragOver\" (dragover)=\"onDropZone($event)\" (dragleave)=\"onDropZone($event)\" (drop)=\"onDropZone($event)\">\n      <input class=\"slds-file-selector__input slds-assistive-text\" type=\"file\" [id]=\"uid\" [attr.accept]=\"accept\" [disabled]=\"disabled\" [multiple]=\"maxFiles !== 1\" [attr.aria-describedby]=\"error ? uid + '-error' : null\" [attr.aria-labelledby]=\"uid + '-primary-label ' + uid + '-secondary-label'\" (change)=\"onInputChange($event.target.files)\">\n      <label class=\"slds-file-selector__body\" [attr.for]=\"uid\" [id]=\"uid + '-secondary-label'\"><span class=\"slds-file-selector__button slds-button slds-button_neutral\">\n          <svg class=\"slds-button__icon slds-button__icon_left\" nglIconName=\"utility:upload\"></svg>{{ uploadButtonLabel }}</span><span class=\"slds-file-selector__text slds-medium-show\">{{ dropZoneLabel }}</span></label>\n    </div>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>",
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NglFileUpload_1,
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: NglFileUpload_1,
                multi: true
            }
        ]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglFileUpload);

let NglFileUploadModule = class NglFileUploadModule {
};
NglFileUploadModule = __decorate([
    NgModule({
        declarations: [NglFileUpload],
        exports: [NglFileUpload],
        imports: [CommonModule, NglIconsModule, NglInternalOutletModule],
    })
], NglFileUploadModule);

let NglInputElement = class NglInputElement {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.RequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('input'));
        }
    }
    set required(required) {
        this.RequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglInputElement.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglInputElement.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglInputElement.prototype, "required", null);
NglInputElement = __decorate([
    Directive({
        selector: 'input[ngl]:not([type=checkbox]):not([type=radio])',
        host: {
            '[class.slds-input]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglInputElement);

let NglInput = class NglInput {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <input> with [ngl] attribute inside NglInput`);
        }
        this.RequiredSubscription = this.input.RequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.RequiredSubscription) {
            this.RequiredSubscription.unsubscribe();
            this.RequiredSubscription = null;
        }
    }
};
NglInput.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglInputElement, { static: true }),
    __metadata("design:type", NglInputElement)
], NglInput.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "error", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglInput.prototype, "stacked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglInput.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglInput.prototype, "hasError", null);
NglInput = __decorate([
    Component({
        selector: 'ngl-input,[ngl-input]',
        template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <ng-content></ng-content>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglInput);

const DIRECTIVES$8 = [
    NglInput,
    NglInputElement,
];
let NglInputModule = class NglInputModule {
};
NglInputModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$8,
        exports: DIRECTIVES$8,
        imports: [CommonModule, NglFormsModule, NglInternalOutletModule],
    })
], NglInputModule);

let NglDropdownItem = class NglDropdownItem {
    constructor(element) {
        this.element = element;
        this.isFocused = false;
    }
    onFocus() {
        this.isFocused = true;
    }
    onBlur() {
        this.isFocused = false;
    }
    hasFocus() {
        return this.isFocused;
    }
    focus() {
        this.element.nativeElement.focus();
    }
};
NglDropdownItem.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('focus'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownItem.prototype, "onFocus", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownItem.prototype, "onBlur", null);
NglDropdownItem = __decorate([
    Directive({
        selector: '[nglDropdownItem]',
        host: {
            'tabindex': '0',
        },
    }),
    __metadata("design:paramtypes", [ElementRef])
], NglDropdownItem);

const openEventEmitter = new EventEmitter();
let NglDropdown = class NglDropdown {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.handlePageEvents = true;
        this.isOpenChange = new EventEmitter();
        this.triggerFocusEventEmitter = new EventEmitter();
        this._isOpen = false;
        this.globalClickEventUnsubscriber = null;
        this.clickEventUnsubscriber = null;
    }
    set isOpen(isOpen) {
        this._isOpen = toBoolean(isOpen);
        if (this.isOpen) {
            this.clearGlobalClickTimeout();
            this.globalClickTimeout = setTimeout(() => {
                if (this.handlePageEvents) {
                    this._subscribeToClickEvents();
                }
            });
            this.renderer.addClass(this.element.nativeElement, 'slds-is-open');
        }
        else {
            this._unsubscribeFromClickEvents();
            this.renderer.removeClass(this.element.nativeElement, 'slds-is-open');
        }
        this.renderer.setAttribute(this.element.nativeElement, 'aria-expanded', `${this.isOpen}`);
    }
    get isOpen() {
        return this._isOpen;
    }
    onKeydownClose(eventName) {
        this.toggle(false);
        if (eventName === 'esc') {
            this.triggerFocusEventEmitter.emit(null);
        }
    }
    onKeydownFocusNext($event, direction) {
        $event.preventDefault();
        this.focusItem(direction);
    }
    ngOnInit() {
        this.openEventSubscription = openEventEmitter.subscribe(this.handleDropdownOpenEvent.bind(this));
    }
    ngOnDestroy() {
        this.clearGlobalClickTimeout();
        if (this.openEventSubscription) {
            this.openEventSubscription.unsubscribe();
        }
        this._unsubscribeFromClickEvents();
    }
    toggle(toggle = !this.isOpen, focus = false) {
        if (toggle === this.isOpen) {
            return;
        }
        this.isOpenChange.emit(toggle);
        if (toggle) {
            openEventEmitter.emit(this);
            if (focus) {
                this.focusItem('next');
            }
        }
    }
    handleGlobalClickEvent($event) {
        if (!this.handlePageEvents || $event.$nglStop) {
            return;
        }
        this.toggle(false);
    }
    _subscribeToClickEvents() {
        this._unsubscribeFromClickEvents();
        // Prevent document listener to close it, since click happened inside
        this.clickEventUnsubscriber = this.renderer.listen(this.element.nativeElement, 'click', ($event) => $event.$nglStop = true);
        this.globalClickEventUnsubscriber = this.renderer.listen('document', 'click', this.handleGlobalClickEvent.bind(this));
    }
    _unsubscribeFromClickEvents() {
        if (this.clickEventUnsubscriber) {
            this.clickEventUnsubscriber();
            this.clickEventUnsubscriber = null;
        }
        if (this.globalClickEventUnsubscriber) {
            this.globalClickEventUnsubscriber();
            this.globalClickEventUnsubscriber = null;
        }
    }
    clearGlobalClickTimeout() {
        clearTimeout(this.globalClickTimeout);
    }
    focusItem(direction) {
        if (!this.items.length) {
            return;
        }
        const items = this.items.toArray();
        const activeElementIndex = items.findIndex(item => item.hasFocus()) + (direction === 'next' ? 1 : -1);
        if (activeElementIndex === items.length || activeElementIndex < 0) {
            return;
        }
        items[activeElementIndex].focus();
    }
    handleDropdownOpenEvent(dropdown) {
        if (dropdown !== this) {
            this.toggle(false);
        }
    }
};
NglDropdown.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('open'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NglDropdown.prototype, "isOpen", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglDropdown.prototype, "handlePageEvents", void 0);
__decorate([
    ContentChildren(NglDropdownItem, { descendants: true }),
    __metadata("design:type", QueryList)
], NglDropdown.prototype, "items", void 0);
__decorate([
    Output('openChange'),
    __metadata("design:type", Object)
], NglDropdown.prototype, "isOpenChange", void 0);
__decorate([
    HostListener('keydown.esc', ['"esc"']),
    HostListener('keydown.tab', ['"tab"']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NglDropdown.prototype, "onKeydownClose", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event', '"next"']),
    HostListener('keydown.arrowup', ['$event', '"previous"']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event, String]),
    __metadata("design:returntype", void 0)
], NglDropdown.prototype, "onKeydownFocusNext", null);
NglDropdown = __decorate([
    Directive({
        selector: '[nglDropdown]',
        host: {
            '[class.slds-dropdown-trigger]': 'true',
            '[class.slds-dropdown-trigger_click]': 'true',
        },
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglDropdown);

let NglDropdownTrigger = class NglDropdownTrigger {
    constructor(element, dropdown) {
        this.element = element;
        this.dropdown = dropdown;
        this.parentFocusEventSubscription = this.dropdown.triggerFocusEventEmitter.subscribe(this.focus.bind(this));
    }
    ngOnDestroy() {
        this.parentFocusEventSubscription.unsubscribe();
    }
    toggleOpen() {
        this.dropdown.toggle();
    }
    onKeyDownOpen($event) {
        $event.preventDefault();
        this.dropdown.toggle(true);
    }
    focus() {
        this.element.nativeElement.focus();
    }
};
NglDropdownTrigger.ctorParameters = () => [
    { type: ElementRef },
    { type: NglDropdown }
];
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglDropdownTrigger.prototype, "toggleOpen", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglDropdownTrigger.prototype, "onKeyDownOpen", null);
NglDropdownTrigger = __decorate([
    Directive({
        selector: '[nglDropdownTrigger]',
        host: {
            'aria-haspopup': 'true',
        },
    }),
    __metadata("design:paramtypes", [ElementRef, NglDropdown])
], NglDropdownTrigger);

const NGL_DROPDOWN_DIRECTIVES = [
    NglDropdown,
    NglDropdownTrigger,
    NglDropdownItem,
];
let NglMenusModule = class NglMenusModule {
};
NglMenusModule = __decorate([
    NgModule({
        declarations: [NGL_DROPDOWN_DIRECTIVES],
        exports: [NGL_DROPDOWN_DIRECTIVES],
        imports: [CommonModule],
    })
], NglMenusModule);

let NglModalHeaderTemplate = class NglModalHeaderTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalHeaderTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalHeaderTemplate = __decorate([
    Directive({ selector: '[nglModalHeader]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglModalHeaderTemplate);
let NglModalTaglineTemplate = class NglModalTaglineTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalTaglineTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalTaglineTemplate = __decorate([
    Directive({ selector: '[nglModalTagline]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglModalTaglineTemplate);
let NglModalFooterTemplate = class NglModalFooterTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglModalFooterTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglModalFooterTemplate = __decorate([
    Directive({ selector: '[nglModalFooter]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglModalFooterTemplate);

let NglModal = class NglModal {
    constructor(focusTrapFactory, document, overlay, element) {
        this.focusTrapFactory = focusTrapFactory;
        this.document = document;
        this.overlay = overlay;
        this.element = element;
        this.header = '';
        this.directional = false;
        this.headingId = uniqueId('modal-heading');
        this.contentId = uniqueId('modal-content');
        this.open = true;
        this.closeButtonAssistiveText = 'Close';
        this.openChange = new EventEmitter();
        this.dismissOnClickOutside = true;
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this.elementFocusedBeforeDialogWasOpened = null;
        this.scrollStrategy = this.overlay.scrollStrategies.block();
    }
    get hasHeader() {
        return this.header || this.headerTpl;
    }
    close(evt) {
        if (evt) {
            evt.stopPropagation();
        }
        this.openChange.emit(false);
    }
    ngOnChanges(changes) {
        if ('open' in changes) {
            this.handleOpen();
        }
    }
    ngAfterContentInit() {
        this.handleOpen();
    }
    clickOutside(evt) {
        if (!this.dismissOnClickOutside) {
            return;
        }
        const { classList } = evt.target;
        if (classList.contains('slds-modal') || classList.contains('slds-modal__container')) {
            this.close();
        }
    }
    ngOnDestroy() {
        this.handleOpen(false);
        this.scrollStrategy = null;
    }
    modalClass() {
        return {
            [`slds-modal_${this.size}`]: !!this.size,
            [`slds-fade-in-open`]: this.open,
            [`slds-modal_prompt`]: !!this.prompt,
        };
    }
    modalHeaderClass() {
        return {
            [`slds-modal__header_empty`]: !this.hasHeader,
            [`slds-theme_${this.prompt}`]: !!this.prompt,
        };
    }
    modalFooterClass() {
        return {
            [`slds-modal__footer_directional`]: !!this.directional,
            [`slds-theme_default`]: !!this.prompt,
        };
    }
    handleOpen(open = this.open) {
        if (open) {
            if (this.document) {
                this.elementFocusedBeforeDialogWasOpened = this.document.activeElement;
            }
            this.container = this.overlay.create();
            // Attach the dom to overlay, the view container is not changed
            this.container.overlayElement.appendChild(this.element.nativeElement);
            this.focusTrap = this.focusTrapFactory.create(this.element.nativeElement);
            this.focusTrap.focusInitialElementWhenReady();
            this.scrollStrategy.enable();
        }
        else {
            if (this.elementFocusedBeforeDialogWasOpened && typeof this.elementFocusedBeforeDialogWasOpened.focus === 'function') {
                this.elementFocusedBeforeDialogWasOpened.focus();
            }
            if (this.container) {
                this.container.dispose();
                this.container = null;
            }
            if (this.focusTrap) {
                this.focusTrap.destroy();
            }
            this.scrollStrategy.disable();
        }
    }
};
NglModal.ctorParameters = () => [
    { type: FocusTrapFactory },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Overlay },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglModal.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglModal.prototype, "size", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "directional", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "open", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglModal.prototype, "closeButtonAssistiveText", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglModal.prototype, "openChange", void 0);
__decorate([
    ContentChild(NglModalHeaderTemplate),
    __metadata("design:type", NglModalHeaderTemplate)
], NglModal.prototype, "headerTpl", void 0);
__decorate([
    ContentChild(NglModalTaglineTemplate),
    __metadata("design:type", NglModalTaglineTemplate)
], NglModal.prototype, "taglineTpl", void 0);
__decorate([
    ContentChild(NglModalFooterTemplate),
    __metadata("design:type", NglModalFooterTemplate)
], NglModal.prototype, "footer", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglModal.prototype, "dismissOnClickOutside", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglModal.prototype, "prompt", void 0);
__decorate([
    hasObservers('openChange'),
    __metadata("design:type", Boolean)
], NglModal.prototype, "showClose", void 0);
__decorate([
    HostListener('keydown.esc', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglModal.prototype, "close", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NglModal.prototype, "clickOutside", null);
NglModal = __decorate([
    Component({
        selector: 'ngl-modal',
        template: "\n<section class=\"slds-modal\" [ngClass]=\"modalClass()\" [attr.aria-hidden]=\"!open\" [attr.aria-labelledby]=\"headingId\" [attr.aria-describedby]=\"contentId\" aria-modal=\"true\" [attr.role]=\"prompt ? 'alertdialog' : 'dialog'\" tabindex=\"-1\">\n  <div class=\"slds-modal__container\">\n    <header class=\"slds-modal__header\" [ngClass]=\"modalHeaderClass()\">\n      <button class=\"slds-button slds-button_icon slds-button_icon-inverse slds-modal__close\" *ngIf=\"showClose\" type=\"button\" (click)=\"close()\">\n        <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n      </button>\n      <ng-template #localHeader>\n        <h2 class=\"slds-text-heading_medium slds-hyphenate\" *ngIf=\"header\" [id]=\"headingId\">{{header}}</h2>\n      </ng-template>\n      <ng-template *ngIf=\"headerTpl; else localHeader\" [ngTemplateOutlet]=\"headerTpl.templateRef\" [ngTemplateOutletContext]=\"{id: headingId}\"></ng-template>\n      <p class=\"slds-m-top_x-small\" *ngIf=\"hasHeader &amp;&amp; taglineTpl\">\n        <ng-template [ngTemplateOutlet]=\"taglineTpl.templateRef\"></ng-template>\n      </p>\n    </header>\n    <div class=\"slds-modal__content\" [id]=\"contentId\" cdkScrollable>\n      <ng-content></ng-content>\n    </div>\n    <footer class=\"slds-modal__footer\" *ngIf=\"footer\" [ngClass]=\"modalFooterClass()\">\n      <ng-template [ngTemplateOutlet]=\"footer.templateRef\"></ng-template>\n    </footer>\n  </div>\n</section>\n<div class=\"slds-backdrop\" [class.slds-backdrop_open]=\"open\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(1, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [FocusTrapFactory, Object, Overlay,
        ElementRef])
], NglModal);

const NGL_MODAL_DIRECTIVES = [
    NglModal,
    NglModalFooterTemplate,
    NglModalHeaderTemplate,
    NglModalTaglineTemplate,
];
let NglModalsModule = class NglModalsModule {
};
NglModalsModule = __decorate([
    NgModule({
        declarations: [NGL_MODAL_DIRECTIVES],
        exports: [NGL_MODAL_DIRECTIVES],
        imports: [CommonModule, A11yModule, OverlayModule, NglIconsModule],
    })
], NglModalsModule);

let NglToast = class NglToast extends NglCommonNotify {
    constructor(element, renderer, cd) {
        super(element, renderer, cd, 'toast');
    }
};
NglToast.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NglToast = __decorate([
    Component({
        selector: 'ngl-toast',
        template: "<span class=\"slds-assistive-text\">{{assistiveText || variant}}</span>\n<ngl-icon class=\"slds-m-right_small slds-no-flex slds-align-top\" *ngIf=\"iconName\" [iconName]=\"iconName\" size=\"small\" variant=\"\"></ngl-icon>\n<div class=\"slds-notify__content\">\n  <ng-content></ng-content>\n</div>\n<button class=\"slds-button slds-button_icon slds-notify__close slds-button_icon-inverse\" *ngIf=\"dismissible\" type=\"button\" (click)=\"close('button', $event)\">\n  <svg class=\"slds-button__icon slds-button__icon_large\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"closeButtonAssistiveText\">{{closeButtonAssistiveText}}</span>\n</button>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        exportAs: 'nglToast'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglToast);

let NglToastClose = class NglToastClose extends NglCommonNotifyClose {
    constructor(toast) {
        super(toast);
    }
};
NglToastClose.ctorParameters = () => [
    { type: NglToast }
];
NglToastClose = __decorate([
    Directive({
        selector: 'ngl-toast[close],ngl-toast[nglClose]',
    }),
    __metadata("design:paramtypes", [NglToast])
], NglToastClose);

const NGL_TOAST_DIRECTIVES = [
    NglToast,
    NglToastClose,
];
let NglToastModule = class NglToastModule {
};
NglToastModule = __decorate([
    NgModule({
        declarations: [NGL_TOAST_DIRECTIVES],
        exports: [NGL_TOAST_DIRECTIVES],
        imports: [CommonModule, NglIconsModule],
    })
], NglToastModule);

let NglPagination = class NglPagination {
    constructor() {
        this.pages = [];
        this.pageChange = new EventEmitter();
        this.perPage = 10;
        this.limit = 0;
        this.boundaryNumbers = 0;
        this.firstText = 'First';
        this.previousText = 'Previous';
        this.nextText = 'Next';
        this.lastText = 'Last';
        this.boundaryLinks = false;
    }
    set page(page) {
        this.current = +page;
    }
    hasPrevious() {
        return this.current > 1;
    }
    hasNext() {
        return this.current < this.totalPages;
    }
    goto(page) {
        if (page === this.current) {
            return;
        }
        this.pageChange.emit(+page);
    }
    ngOnChanges() {
        this.totalPages = Math.ceil(+this.total / +this.perPage);
        const { start, end } = this.limits();
        this.pages = this.getPageArray(start, end);
        if (this.boundaryNumbers > 0) {
            if (start > 1) {
                const preGap = this.getPageArray(1, Math.min(start - 1, this.boundaryNumbers));
                const lastGapNumber = +preGap[preGap.length - 1].number;
                if (lastGapNumber < start - 1) {
                    this.pages.unshift(this.getGapPage(lastGapNumber, start));
                }
                this.pages.unshift(...preGap);
            }
            if (end < this.totalPages) {
                const postGap = this.getPageArray(Math.max(this.totalPages - this.boundaryNumbers + 1, end + 1), this.totalPages);
                const firstGapNumber = +postGap[0].number;
                if (firstGapNumber > end + 1) {
                    this.pages.push(this.getGapPage(end, firstGapNumber));
                }
                this.pages.push(...postGap);
            }
        }
        if (this.current > this.totalPages) {
            setTimeout(() => this.goto(this.totalPages));
        }
        else if (!this.current && this.totalPages > 0) {
            setTimeout(() => this.goto(1));
        }
    }
    pageTrackBy(index, page) {
        return page.number;
    }
    get start() {
        return Math.min(Math.max(1 + (+this.current - 1) * +this.perPage, 0), +this.total);
    }
    get end() {
        return Math.min(this.start + (+this.perPage - 1), +this.total);
    }
    getPageArray(start, end) {
        return Array.apply(null, { length: end - start + 1 }).map((value, index) => this.getPage(start + index));
    }
    getPage(number, disabled = false) {
        return { number, disabled };
    }
    getGapPage(before, after) {
        const isConsecutive = before + 1 === after - 1;
        return this.getPage(isConsecutive ? before + 1 : '...', !isConsecutive);
    }
    /**
     * Calculate first and last visible page numbers
     */
    limits() {
        let start = 1, end = this.totalPages;
        if (this.limit < 1) {
            return { start, end };
        }
        // Current page is displayed in the middle of the visible ones
        start = Math.max(+this.current - Math.floor(+this.limit / 2), 1);
        end = start + +this.limit - 1;
        // Adjust if limit is exceeded
        if (end > this.totalPages) {
            end = this.totalPages;
            start = Math.max(end - +this.limit + 1, 1);
        }
        return { start, end };
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPagination.prototype, "page", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPagination.prototype, "pageChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "perPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "limit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryNumbers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "firstText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "previousText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "nextText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPagination.prototype, "lastText", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglPagination.prototype, "boundaryLinks", void 0);
NglPagination = __decorate([
    Component({
        selector: 'ngl-pagination',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<div class=\"slds-button-group\" role=\"group\">\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasPrevious()\" (click)=\"goto(1)\">{{firstText}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasPrevious()\" (click)=\"goto(current - 1)\">{{previousText}}</button>\n  <button class=\"slds-button\" *ngFor=\"let page of pages; trackBy:pageTrackBy\" [ngClass]=\"'slds-button_' + (page.number === current ? 'brand' : 'neutral')\" (click)=\"goto(page.number)\" [disabled]=\"page.disabled\">{{page.number}}</button>\n  <button class=\"slds-button slds-button_neutral\" [disabled]=\"!hasNext()\" (click)=\"goto(current + 1)\">{{nextText}}</button>\n  <button class=\"slds-button slds-button_neutral\" *ngIf=\"boundaryLinks\" [disabled]=\"!hasNext()\" (click)=\"goto(totalPages)\">{{lastText}}</button>\n</div>",
        exportAs: 'nglPagination'
    })
], NglPagination);

let NglPaginationsModule = class NglPaginationsModule {
};
NglPaginationsModule = __decorate([
    NgModule({
        declarations: [NglPagination],
        exports: [NglPagination],
        imports: [CommonModule],
    })
], NglPaginationsModule);

let NglPick = class NglPick {
    constructor() {
        this.values = new BehaviorSubject(null);
        this.nglPickChange = new EventEmitter();
        this.nglOptionDestroyed = new EventEmitter();
        this.isMultiple = false;
    }
    set setSelected(selected) {
        this.selected = selected;
        this.ngAfterContentInit();
    }
    ngAfterContentInit() {
        this.values.next(this.selected);
    }
    selectOption(value) {
        let next;
        if (this.isMultiple) {
            if (Array.isArray(this.selected)) {
                // Remove if already there or add to selection
                const index = this.selected.indexOf(value);
                next = index > -1
                    ? [...this.selected.slice(0, index), ...this.selected.slice(index + 1)]
                    : [...this.selected, value];
            }
            else {
                next = Object.assign({}, this.selected, { [value]: !this.selected[value] });
            }
        }
        else {
            next = value;
        }
        this.nglPickChange.emit(next);
    }
    optionRemoved(value) {
        if (this.isMultiple && !this.selected) {
            return;
        }
        let emit;
        if (this.isMultiple) {
            emit = Array.isArray(this.selected) ? this.selected.indexOf(value) > -1 : !!this.selected[value];
        }
        else {
            emit = this.selected === value;
        }
        if (emit) {
            setTimeout(() => this.nglOptionDestroyed.emit(value));
        }
    }
};
__decorate([
    Input('nglPick'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], NglPick.prototype, "setSelected", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglPick.prototype, "nglPickActiveClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPick.prototype, "nglPickChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPick.prototype, "nglOptionDestroyed", void 0);
__decorate([
    Input('nglPickMultiple'), InputBoolean(),
    __metadata("design:type", Object)
], NglPick.prototype, "isMultiple", void 0);
NglPick = __decorate([
    Directive({
        selector: '[nglPick]',
    })
], NglPick);

let NglPickOption = class NglPickOption {
    constructor(element, renderer, nglPick) {
        this.element = element;
        this.renderer = renderer;
        this.nglPick = nglPick;
        this._active = false;
    }
    // Use a getter to prevent direct altering
    get active() {
        return this._active;
    }
    set setValue(value) {
        this._value = value;
    }
    pick(evt) {
        if (evt) {
            evt.preventDefault();
        }
        this.nglPick.selectOption(this._value);
    }
    ngOnInit() {
        this._subscription = this.nglPick.values.subscribe(value => {
            this._active = this._isActive(value);
            const activeClass = this.nglPickActiveClass || this.nglPick.nglPickActiveClass;
            if (activeClass) {
                if (this.active) {
                    this.renderer.addClass(this.element.nativeElement, activeClass);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, activeClass);
                }
            }
        });
    }
    ngOnDestroy() {
        this._subscription.unsubscribe();
        this.nglPick.optionRemoved(this._value);
    }
    _isActive(value) {
        if (this.nglPick.isMultiple) {
            if (!value) {
                return false;
            }
            return Array.isArray(value) ? value.indexOf(this._value) > -1 : !!value[this._value];
        }
        else {
            return this._value === value;
        }
    }
};
NglPickOption.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NglPick }
];
__decorate([
    Input('nglPickOption'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglPickOption.prototype, "setValue", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglPickOption.prototype, "nglPickActiveClass", void 0);
__decorate([
    HostListener('click'),
    HostListener('keydown.Space', ['$event']),
    HostListener('keydown.Enter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Event]),
    __metadata("design:returntype", void 0)
], NglPickOption.prototype, "pick", null);
NglPickOption = __decorate([
    Directive({
        selector: '[nglPickOption]',
        exportAs: 'nglPickOption',
        host: {
            'role': 'button',
        },
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, NglPick])
], NglPickOption);

const NGL_PICK_DIRECTIVES = [
    NglPick,
    NglPickOption,
];
let NglPickModule = class NglPickModule {
};
NglPickModule = __decorate([
    NgModule({
        declarations: [NGL_PICK_DIRECTIVES],
        exports: [NGL_PICK_DIRECTIVES],
        imports: [CommonModule],
    })
], NglPickModule);

let NglPill = class NglPill {
    constructor() {
        this.isTemplateRef = isTemplateRef;
        /**
           * Applies the error style to the component.
           */
        this.hasError = false;
        /**
           * Whether or not to override the remove button's visibility, if `remove` is set.
           */
        this.removable = true;
        /**
           * Remove button title (and assistive text).
           */
        this.removeTitle = 'Remove';
        /**
           * The event emitted when the remove button is clicked.
           */
        this.remove = new EventEmitter();
        this.linked = false;
    }
    ngOnInit() {
        this.canRemove = this.remove.observers.length > 0;
    }
    onRemove(e) {
        this.remove.emit(e);
    }
    get pillIcon() {
        return this.icon || this.avatar;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "avatar", void 0);
__decorate([
    Input(), InputBoolean(), HostBinding('class.slds-has-error'),
    __metadata("design:type", Object)
], NglPill.prototype, "hasError", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglPill.prototype, "removable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglPill.prototype, "removeTitle", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglPill.prototype, "remove", void 0);
__decorate([
    HostBinding('class.slds-pill_link'),
    __metadata("design:type", Object)
], NglPill.prototype, "linked", void 0);
NglPill = __decorate([
    Component({
        selector: 'ngl-pill',
        template: "<span class=\"slds-pill__icon_container\" *ngIf=\"pillIcon\">\n  <ng-container *ngIf=\"isTemplateRef(pillIcon); else defaultTpl\" [ngTemplateOutlet]=\"pillIcon\"></ng-container>\n  <ng-template #defaultTpl>\n    <ngl-icon *ngIf=\"icon; else avatarTpl\" [iconName]=\"icon\"></ngl-icon>\n    <ng-template #avatarTpl>\n      <ngl-avatar [src]=\"avatar\" variant=\"circle\"></ngl-avatar>\n    </ng-template>\n  </ng-template></span>\n<ng-container *ngIf=\"linked; else unlinked\">\n  <ng-content select=\"a\"></ng-content>\n</ng-container>\n<ng-template #unlinked><span class=\"slds-pill__label\">\n    <ng-content></ng-content></span></ng-template>\n<button class=\"slds-button slds-button_icon slds-pill__remove\" *ngIf=\"canRemove &amp;&amp; removable\" type=\"button\" [title]=\"removeTitle\" (click)=\"onRemove($event)\">\n  <svg class=\"slds-button__icon\" nglIconName=\"close\"></svg><span class=\"slds-assistive-text\" *ngIf=\"removeTitle\">{{removeTitle}}</span>\n</button>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-pill]': 'true',
        }
    })
], NglPill);

let NglPillLink = class NglPillLink {
    constructor(pill) {
        pill.linked = true;
    }
};
NglPillLink.ctorParameters = () => [
    { type: NglPill }
];
NglPillLink = __decorate([
    Component({
        //  tslint:disable-next-line:component-selector
        selector: 'a[nglPillAction]',
        template: "<span class=\"slds-pill__label\">\n  <ng-content></ng-content></span>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-pill__action]': 'true',
        }
    }),
    __metadata("design:paramtypes", [NglPill])
], NglPillLink);

const NGL_PILL_DIRECTIVES = [
    NglPill,
    NglPillLink,
];
let NglPillsModule = class NglPillsModule {
};
NglPillsModule = __decorate([
    NgModule({
        declarations: NGL_PILL_DIRECTIVES,
        exports: NGL_PILL_DIRECTIVES,
        imports: [CommonModule, NglIconsModule, NglAvatarModule],
    })
], NglPillsModule);

let NglProgressBar = class NglProgressBar {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-progress-bar');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'progressbar');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemin', '0');
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuemax', '100');
    }
    /**
     * The percentage value of the progress bar.
     */
    set value(value) {
        this._value = Math.max(0, Math.min(value, 100)); // Trap on [0, 100]
        this.renderer.setAttribute(this.element.nativeElement, 'aria-valuenow', `${this.value}`);
    }
    get value() {
        return this._value;
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-progress-bar_${this.size}`]: !!this.size,
            [`slds-progress-bar_${this.variant}`]: !!this.variant,
        });
    }
};
NglProgressBar.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglProgressBar.prototype, "value", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglProgressBar.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglProgressBar.prototype, "variant", void 0);
NglProgressBar = __decorate([
    Component({
        selector: 'ngl-progress-bar',
        template: "<span class=\"slds-progress-bar__value\" [style.width.%]=\"value\"><span class=\"slds-assistive-text\">Progress: {{value}}%</span></span>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglProgressBar);

let NglProgressBarModule = class NglProgressBarModule {
};
NglProgressBarModule = __decorate([
    NgModule({
        declarations: [NglProgressBar],
        exports: [NglProgressBar],
        imports: [CommonModule],
    })
], NglProgressBarModule);

let NglRadioGroup = class NglRadioGroup {
    constructor() {
        this.type = 'list';
        this.uid = uniqueId('radio-group');
        this.type$ = new BehaviorSubject(this.type);
        this.error$ = new BehaviorSubject(this.error);
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this.uid}`;
    }
    ngOnChanges(changes) {
        if (changes.type) {
            this.type$.next(this.type);
        }
        if (changes.error) {
            this.error$.next(this.hasError ? this.errorId : null);
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRadioGroup.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRadioGroup.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglRadioGroup.prototype, "hasError", null);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglRadioGroup.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRadioGroup.prototype, "type", void 0);
NglRadioGroup = __decorate([
    Component({
        selector: 'ngl-radio-group,[ngl-radio-group]',
        template: "\n<legend class=\"slds-form-element__legend slds-form-element__label\"><abbr class=\"slds-required\" *ngIf=\"required\" title=\"required\">*</abbr><span [nglInternalOutlet]=\"label\"></span></legend>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-radio_button-group\" *ngIf=\"type === 'button'; else contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl\"></ng-container>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>\n<ng-template #contentTpl>\n  <ng-content></ng-content>\n</ng-template>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    })
], NglRadioGroup);

let NglRadioInput = class NglRadioInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('radio'));
        }
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglRadioInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.name'),
    __metadata("design:type", String)
], NglRadioInput.prototype, "name", void 0);
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglRadioInput.prototype, "describedBy", void 0);
NglRadioInput = __decorate([
    Directive({
        selector: 'input[ngl][type=radio]',
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglRadioInput);

let NglRadioOption = class NglRadioOption {
    constructor(radioGroup, cd) {
        this.radioGroup = radioGroup;
        this.cd = cd;
        this.subscriptions = [];
    }
    get isTypeList() {
        return this.type === 'list';
    }
    get isTypeButton() {
        return this.type === 'button';
    }
    ngOnInit() {
        this.subscriptions.push(this.radioGroup.type$.subscribe((type) => {
            this.type = type;
            this.cd.detectChanges();
        }), this.radioGroup.error$.subscribe((errorId) => {
            this.input.describedBy = errorId;
        }));
    }
    ngAfterContentInit() {
        this.input.name = this.radioGroup.uid;
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
    }
};
NglRadioOption.ctorParameters = () => [
    { type: NglRadioGroup },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRadioOption.prototype, "label", void 0);
__decorate([
    ContentChild(NglRadioInput, { static: true }),
    __metadata("design:type", NglRadioInput)
], NglRadioOption.prototype, "input", void 0);
__decorate([
    HostBinding('class.slds-radio'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRadioOption.prototype, "isTypeList", null);
__decorate([
    HostBinding('class.slds-button'),
    HostBinding('class.slds-radio_button'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRadioOption.prototype, "isTypeButton", null);
NglRadioOption = __decorate([
    Component({
        selector: 'ngl-radio-option',
        template: "\n<ng-content></ng-content>\n<label class=\"slds-radio__label\" *ngIf=\"type === 'list'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\"></span><span class=\"slds-form-element__label\" [nglInternalOutlet]=\"label\"></span></label>\n<label class=\"slds-radio_button__label\" *ngIf=\"type === 'button'\" [attr.for]=\"input.id\"><span class=\"slds-radio_faux\" [nglInternalOutlet]=\"label\"></span></label>",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [NglRadioGroup, ChangeDetectorRef])
], NglRadioOption);

const DIRECTIVES$9 = [
    NglRadioGroup,
    NglRadioOption,
    NglRadioInput,
];
let NglRadiosModule = class NglRadiosModule {
};
NglRadiosModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$9,
        exports: DIRECTIVES$9,
        imports: [CommonModule, NglInternalOutletModule],
    })
], NglRadiosModule);

let NglRatingIconTemplate = class NglRatingIconTemplate {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
NglRatingIconTemplate.ctorParameters = () => [
    { type: TemplateRef }
];
NglRatingIconTemplate = __decorate([
    Directive({ selector: '[nglRatingIcon]' }),
    __metadata("design:paramtypes", [TemplateRef])
], NglRatingIconTemplate);

/** Injection token that can be used to specify default options. */
const NGL_RATING_CONFIG = new InjectionToken('ngl-rating-config');
/**
 * Configuration service for the NglRating component.
 */
class NglRatingConfig {
    constructor() {
        /**
         * The color of the icon when status is "on"
         */
        this.colorOn = '#FFB75D';
        /**
         * The color of the icon when status is "off"
         */
        this.colorOff = '54698D';
    }
}

let NglRating = class NglRating {
    constructor(defaultConfig) {
        this.range = [];
        this.icon = 'favorite';
        this.readonly = false;
        this.rateChange = new EventEmitter();
        this.hover = new EventEmitter();
        this._max = 5;
        const config = Object.assign(Object.assign({}, new NglRatingConfig()), defaultConfig);
        this.colorOn = config.colorOn;
        this.colorOff = config.colorOff;
    }
    set rate(rate) {
        this.inputRate = rate;
        this.currentRate = rate;
    }
    set max(max) {
        this._max = +max;
        this.setRange();
    }
    get max() {
        return this._max;
    }
    ngOnInit() {
        this.setRange();
    }
    ngAfterContentInit() {
        this._template = this.iconTemplate ? this.iconTemplate.templateRef : this.defaultTemplate;
    }
    update(value) {
        if (value < 1 || value > this.max || this.readonly || value === this.inputRate) {
            return;
        }
        this.rateChange.emit(value);
    }
    enter(value) {
        if (this.readonly) {
            return;
        }
        this.currentRate = value;
        this.hover.emit(value);
    }
    getFill(value) {
        if (value <= this.currentRate) {
            return 100;
        }
        if (Math.ceil(this.currentRate) < value) {
            return 0;
        }
        return Math.round(100 * (this.currentRate % 1));
    }
    reset() {
        this.currentRate = this.inputRate;
    }
    // Keyboard interactions
    keyboardIncrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate + 1);
    }
    keyboardDecrease(evt) {
        evt.preventDefault();
        this.update(this.inputRate - 1);
    }
    // ARIA
    get ariaValuenow() {
        return this.inputRate;
    }
    setRange() {
        this.range = Array.apply(null, { length: this.max }).map((value, index) => index + 1);
    }
};
NglRating.ctorParameters = () => [
    { type: NglRatingConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_RATING_CONFIG,] }] }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglRating.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "size", void 0);
__decorate([
    Input('isReadonly'), InputBoolean(),
    __metadata("design:type", Object)
], NglRating.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglRating.prototype, "rate", null);
__decorate([
    ViewChild('t', { static: true }),
    __metadata("design:type", TemplateRef)
], NglRating.prototype, "defaultTemplate", void 0);
__decorate([
    ContentChild(NglRatingIconTemplate),
    __metadata("design:type", NglRatingIconTemplate)
], NglRating.prototype, "iconTemplate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglRating.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOn", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglRating.prototype, "colorOff", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "rateChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglRating.prototype, "hover", void 0);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "reset", null);
__decorate([
    HostListener('keydown.ArrowUp', ['$event']),
    HostListener('keydown.ArrowRight', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardIncrease", null);
__decorate([
    HostListener('keydown.ArrowDown', ['$event']),
    HostListener('keydown.ArrowLeft', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], NglRating.prototype, "keyboardDecrease", null);
__decorate([
    HostBinding('attr.aria-valuenow'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglRating.prototype, "ariaValuenow", null);
NglRating = __decorate([
    Component({
        selector: 'ngl-rating',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<ng-template #t let-fill=\"fill\">\n  <svg class=\"slds-icon\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"fill === 100 ? colorOn : colorOff\"></svg>\n  <svg class=\"slds-icon\" *ngIf=\"fill &gt; 0 &amp;&amp; fill &lt; 100\" [nglIconName]=\"icon\" [ngClass]=\"size ? 'slds-icon_' + size : ''\" [style.fill]=\"colorOn\" style=\"position:absolute; bottom:0;\" [style.left.%]=\"fill - 100\" [xPos]=\"(100 - fill) + '%'\"></svg>\n</ng-template>\n<div class=\"slds-show_inline-block\" *ngFor=\"let r of range; let i = index\" (click)=\"update(r)\" (mouseenter)=\"enter(r)\" style=\"position: relative;\">\n  <ng-template [ngTemplateOutlet]=\"_template\" [ngTemplateOutletContext]=\"{$implicit: r &lt;= currentRate, index: i, fill: getFill(r)}\"></ng-template>\n</div>",
        host: {
            'style': 'white-space: nowrap;',
            'tabindex': '0',
            'aria-valuemin': '0',
            '[attr.aria-valuemax]': 'max',
        }
    }),
    __param(0, Optional()), __param(0, Inject(NGL_RATING_CONFIG)),
    __metadata("design:paramtypes", [NglRatingConfig])
], NglRating);

const DIRECTIVES$a = [
    NglRating,
    NglRatingIconTemplate,
];
let NglRatingsModule = class NglRatingsModule {
};
NglRatingsModule = __decorate([
    NgModule({
        imports: [CommonModule, NglIconsModule],
        declarations: [...DIRECTIVES$a],
        exports: [...DIRECTIVES$a],
    })
], NglRatingsModule);

let NglExpandableSection = class NglExpandableSection {
    constructor() {
        this.collapsable = true;
        this.open = false;
        this.openChange = new EventEmitter();
        this._uid = uniqueId('expandable-section');
    }
    get expanded() {
        return this.collapsable ? this.open : true;
    }
    get uid() {
        return this.collapsable ? this._uid : undefined;
    }
    toggle(event) {
        event.preventDefault();
        this.openChange.emit(!this.open);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NglExpandableSection.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "collapsable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglExpandableSection.prototype, "openChange", void 0);
__decorate([
    HostBinding('class.slds-is-open'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglExpandableSection.prototype, "expanded", null);
NglExpandableSection = __decorate([
    Component({
        selector: 'ngl-expandable-section',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<h3 class=\"slds-section__title\" [class.slds-theme_shade]=\"!collapsable\">\n  <button class=\"slds-button slds-section__title-action\" *ngIf=\"collapsable; else simple_title\" [attr.aria-controls]=\"uid\" [attr.aria-expanded]=\"expanded\" type=\"button\" (click)=\"toggle($event)\">\n    <svg class=\"slds-section__title-action-icon slds-button__icon slds-button__icon_left\" nglIconName=\"switch\"></svg><span class=\"slds-truncate\" [title]=\"title\">{{title}}</span>\n  </button>\n  <ng-template #simple_title><span class=\"slds-truncate slds-p-horizontal_small\" [title]=\"title\">{{title}}</span>\n  </ng-template>\n</h3>\n<div class=\"slds-section__content\" [attr.aria-hidden]=\"!expanded\" [attr.id]=\"uid\">\n  <ng-content></ng-content>\n</div>",
        host: {
            '[class.slds-section]': 'true',
        }
    })
], NglExpandableSection);

let NglSectionsModule = class NglSectionsModule {
};
NglSectionsModule = __decorate([
    NgModule({
        declarations: [NglExpandableSection],
        exports: [NglExpandableSection],
        imports: [CommonModule, NglIconsModule],
    })
], NglSectionsModule);

let NglSelectInput = class NglSelectInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.RequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('select'));
        }
    }
    set required(required) {
        this.RequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglSelectInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglSelectInput.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglSelectInput.prototype, "required", null);
NglSelectInput = __decorate([
    Directive({
        selector: 'select[ngl]',
        host: {
            '[class.slds-select]': 'true',
        },
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglSelectInput);

let NglSelect = class NglSelect {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <select> with [ngl] attribute inside ngl-select`);
        }
        this.RequiredSubscription = this.input.RequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.RequiredSubscription) {
            this.RequiredSubscription.unsubscribe();
            this.RequiredSubscription = null;
        }
    }
};
NglSelect.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglSelectInput, { static: true }),
    __metadata("design:type", NglSelectInput)
], NglSelect.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSelect.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglSelect.prototype, "hasError", null);
NglSelect = __decorate([
    Component({
        selector: 'ngl-select,[ngl-select]',
        template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-select_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"errorId\" [nglInternalOutlet]=\"error\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglSelect);

const DIRECTIVES$b = [
    NglSelect,
    NglSelectInput,
];
let NglSelectModule = class NglSelectModule {
};
NglSelectModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$b,
        exports: DIRECTIVES$b,
        imports: [CommonModule, NglFormsModule, NglInternalOutletModule],
    })
], NglSelectModule);

const NGL_SLIDER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NglSlider),
    multi: true
};
let NglSlider = class NglSlider {
    constructor(element, renderer, cd) {
        this.element = element;
        this.renderer = renderer;
        this.cd = cd;
        /**
         * The minimum value that the slider can have.
         */
        this.min = 0;
        /**
         * The maximum value that the slider can have.
         */
        this.max = 100;
        /**
         * The granularity the slider can step through values.
         */
        this.step = 1;
        /**
         * Whether the slider will be displayed vertically.
         */
        this.vertical = false;
        this.valueChange = new EventEmitter();
        this.uid = uniqueId('slider');
        this._value = null;
        this.onChange = null;
        this.onTouched = () => { };
        this.renderer.addClass(this.element.nativeElement, 'slds-form-element');
    }
    get hasError() {
        return !!this.error;
    }
    set value(value) {
        if (value !== this._value) {
            this._value = this.limit(coerceNumberProperty(value));
        }
    }
    get value() {
        // If the value needs to be read and it is still uninitialized, initialize it to the min.
        if (this._value === null) {
            this._value = this.min;
        }
        return this._value;
    }
    writeValue(value) {
        this.value = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    onInput(value) {
        // Make sure we always emit number
        this.valueChange.emit(coerceNumberProperty(value));
        if (this.onChange) {
            this.value = value;
            this.onChange(this.value);
        }
    }
    sliderClass() {
        return {
            [`slds-size_${this.size}`]: !!this.size,
            [`slds-slider_vertical`]: this.vertical,
        };
    }
    limit(value) {
        return Math.min(Math.max(value, this.min), this.max);
    }
};
NglSlider.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSlider.prototype, "label", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "min", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "max", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Object)
], NglSlider.prototype, "step", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglSlider.prototype, "vertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSlider.prototype, "size", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglSlider.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglSlider.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], NglSlider.prototype, "hasError", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], NglSlider.prototype, "value", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglSlider.prototype, "valueChange", void 0);
NglSlider = __decorate([
    Component({
        selector: 'ngl-slider',
        template: "\n<label class=\"slds-form-element__label\" [attr.for]=\"uid\"><span class=\"slds-slider-label\"><span class=\"slds-slider-label__label\" *ngIf=\"label\" [nglInternalOutlet]=\"label\"></span><span class=\"slds-slider-label__range\">{{min}} - {{max}}</span></span></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-slider\" [ngClass]=\"sliderClass()\">\n    <input class=\"slds-slider__range\" [id]=\"uid\" type=\"range\" [value]=\"value\" [min]=\"min\" [max]=\"max\" [step]=\"step\" [disabled]=\"disabled\" [attr.aria-describedby]=\"hasError ? uid + '-error' : null\" (input)=\"onInput($event.target.value)\"><span class=\"slds-slider__value\" aria-hidden=\"true\">{{value}}</span>\n  </div>\n  <div class=\"slds-form-element__help\" *ngIf=\"hasError\" [id]=\"uid + '-error'\" [nglInternalOutlet]=\"error\"></div>\n</div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [NGL_SLIDER_VALUE_ACCESSOR]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, ChangeDetectorRef])
], NglSlider);

let NglSliderModule = class NglSliderModule {
};
NglSliderModule = __decorate([
    NgModule({
        declarations: [NglSlider],
        exports: [NglSlider],
        imports: [CommonModule, NglInternalOutletModule],
    })
], NglSliderModule);

let NglSpinner = class NglSpinner {
    constructor(element, renderer, hostService) {
        this.element = element;
        this.renderer = renderer;
        this.hostService = hostService;
        this.renderer.addClass(this.element.nativeElement, 'slds-spinner');
        this.renderer.setAttribute(this.element.nativeElement, 'role', 'status');
    }
    ngOnInit() {
        this.setHostClass();
    }
    ngOnChanges() {
        this.setHostClass();
    }
    setHostClass() {
        this.hostService.updateClass(this.element, {
            [`slds-spinner_${this.size || 'medium'}`]: true,
            [`slds-spinner_${this.variant}`]: !!this.variant,
        });
    }
};
NglSpinner.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HostService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglSpinner.prototype, "alternativeText", void 0);
NglSpinner = __decorate([
    Component({
        selector: 'ngl-spinner',
        template: "<span class=\"slds-assistive-text\" *ngIf=\"alternativeText\">{{ alternativeText }}</span>\n<div class=\"slds-spinner__dot-a\"></div>\n<div class=\"slds-spinner__dot-b\"></div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [HostService]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, HostService])
], NglSpinner);

let NglSpinnersModule = class NglSpinnersModule {
};
NglSpinnersModule = __decorate([
    NgModule({
        declarations: [NglSpinner],
        exports: [NglSpinner],
        imports: [CommonModule],
    })
], NglSpinnersModule);

let NglTextareaInput = class NglTextareaInput {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.RequiredSubject = new BehaviorSubject(false);
        if (!this.el.nativeElement.id) {
            this.renderer.setAttribute(this.el.nativeElement, 'id', uniqueId('textarea'));
        }
    }
    set required(required) {
        this.RequiredSubject.next(toBoolean(required));
    }
    get id() {
        return this.el.nativeElement.id;
    }
};
NglTextareaInput.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    HostBinding('attr.aria-describedby'),
    __metadata("design:type", String)
], NglTextareaInput.prototype, "describedBy", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NglTextareaInput.prototype, "required", null);
NglTextareaInput = __decorate([
    Directive({
        selector: 'textarea[ngl]',
        host: {
            '[class.slds-textarea]': 'true',
        },
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], NglTextareaInput);

let NglTextarea = class NglTextarea {
    constructor(cd) {
        this.cd = cd;
    }
    get hasError() {
        return toBoolean(this.error);
    }
    get errorId() {
        return `error_${this._uid}`;
    }
    ngOnChanges() {
        this.input.describedBy = this.error ? this.errorId : null;
    }
    ngAfterContentInit() {
        if (!this.input) {
            throw Error(`[ng-lightning] Couldn't find an <textarea> with [ngl] attribute inside ngl-textarea`);
        }
        this.RequiredSubscription = this.input.RequiredSubject.subscribe((required) => {
            this.required = required;
            this.cd.detectChanges();
        });
        this._uid = this.input.id;
        this.cd.detectChanges();
    }
    ngOnDestroy() {
        if (this.RequiredSubscription) {
            this.RequiredSubscription.unsubscribe();
            this.RequiredSubscription = null;
        }
    }
};
NglTextarea.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ContentChild(NglTextareaInput, { static: true }),
    __metadata("design:type", NglTextareaInput)
], NglTextarea.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTextarea.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglTextarea.prototype, "fieldLevelHelpTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglTextarea.prototype, "error", void 0);
__decorate([
    HostBinding('class.slds-has-error'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], NglTextarea.prototype, "hasError", null);
NglTextarea = __decorate([
    Component({
        selector: 'ngl-textarea,[ngl-textarea]',
        template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"_uid\" [required]=\"required\"></label>\n<ngl-form-help *ngIf=\"fieldLevelHelpTooltip\" [content]=\"fieldLevelHelpTooltip\"></ngl-form-help>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-textarea_container\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"slds-form-element__help\" *ngIf=\"error\" [id]=\"errorId\">{{error}}</div>",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[class.slds-form-element]': 'true',
        }
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], NglTextarea);

const DIRECTIVES$c = [
    NglTextarea,
    NglTextareaInput,
];
let NglTextareaModule = class NglTextareaModule {
};
NglTextareaModule = __decorate([
    NgModule({
        declarations: DIRECTIVES$c,
        exports: DIRECTIVES$c,
        imports: [CommonModule, NglFormsModule],
    })
], NglTextareaModule);

const MODULES = [
    NglAccordionModule,
    NglAlertModule,
    NglAvatarModule,
    NglBadgesModule,
    NglBreadcrumbsModule,
    NglButtonIconsModule,
    NglButtonsModule,
    NglCarouselModule,
    NglCheckboxesModule,
    NglColorpickerModule,
    NglComboboxesModule,
    NglDatatablesModule,
    NglDatepickersModule,
    NglDynamicIconsModule,
    NglFilesModule,
    NglFileUploadModule,
    NglIconsModule,
    NglInputModule,
    NglMenusModule,
    NglModalsModule,
    NglToastModule,
    NglPaginationsModule,
    NglPickModule,
    NglPillsModule,
    NglPopoversModule,
    NglProgressBarModule,
    NglRadiosModule,
    NglRatingsModule,
    NglSectionsModule,
    NglSelectModule,
    NglSliderModule,
    NglSpinnersModule,
    NglTabsModule,
    NglTextareaModule,
    NglTooltipsModule,
];
let NglModule = class NglModule {
};
NglModule = __decorate([
    NgModule({
        exports: MODULES,
    })
], NglModule);

/*
 * Public API Surface of ng-lightning
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NGL_COLORPICKER_CONFIG, NGL_DATEPICKER_CONFIG, NGL_ICON_CONFIG, NGL_RATING_CONFIG, NGL_TOOLTIP_CONFIG, NglAccordion, NglAccordionModule, NglAccordionSection, NglAlert, NglAlertClose, NglAlertModule, NglAvatar, NglAvatarModule, NglBadge, NglBadgesModule, NglBreadcrumb, NglBreadcrumbs, NglBreadcrumbsModule, NglButton, NglButtonIcon, NglButtonIconStateful, NglButtonIconsModule, NglButtonStateHover, NglButtonStateOff, NglButtonStateOn, NglButtonStateful, NglButtonsModule, NglCarousel, NglCarouselImage, NglCarouselModule, NglCheckbox, NglCheckboxButton, NglCheckboxGroup, NglCheckboxInput, NglCheckboxOption, NglCheckboxToggle, NglCheckboxesModule, NglColorpicker, NglColorpickerConfig, NglColorpickerModule, NglCombobox, NglComboboxInput, NglComboboxOption, NglComboboxesModule, NglDatatable, NglDatatableCell, NglDatatableColumn, NglDatatableHeadingTemplate, NglDatatableLoadingOverlay, NglDatatableNoRowsOverlay, NglDatatablesModule, NglDatepicker, NglDatepickerConfig, NglDatepickerInput, NglDatepickersModule, NglDropdown, NglDropdownItem, NglDropdownTrigger, NglDynamicIcon, NglDynamicIconEllie, NglDynamicIconEq, NglDynamicIconScore, NglDynamicIconWaffle, NglDynamicIconsModule, NglExpandableSection, NglFile, NglFileCrop, NglFileUpload, NglFileUploadModule, NglFilesModule, NglIcon, NglIconConfig, NglIconSvg, NglIconsModule, NglInput, NglInputElement, NglInputModule, NglMenusModule, NglModal, NglModalFooterTemplate, NglModalHeaderTemplate, NglModalTaglineTemplate, NglModalsModule, NglModule, NglPagination, NglPaginationsModule, NglPick, NglPickModule, NglPickOption, NglPill, NglPillLink, NglPillsModule, NglPopover, NglPopoverTrigger, NglPopoversModule, NglProgressBar, NglProgressBarModule, NglRadioGroup, NglRadioInput, NglRadioOption, NglRadiosModule, NglRating, NglRatingConfig, NglRatingIconTemplate, NglRatingsModule, NglSectionsModule, NglSelect, NglSelectInput, NglSelectModule, NglSlider, NglSliderModule, NglSpinner, NglSpinnersModule, NglTab, NglTabContent, NglTabLabel, NglTabVerbose, NglTabs, NglTabsModule, NglTextarea, NglTextareaInput, NglTextareaModule, NglToast, NglToastClose, NglToastModule, NglTooltipConfig, NglTooltipTrigger, NglTooltipsModule, InputBoolean as a, InputNumber as b, NglDatepickerMonth as ba, NglDay as bb, NglDateAdapter as bc, NglDateAdapterBase as bd, NglDatepickerWeekdays as be, NglDatepickerYear as bf, NglClickOutsideModule as bg, NglClickOutsideDirective as bh, BaseDynamicIconComponent as bi, NglAccordionItem as c, HostService as d, NglInternalOutletModule as e, NglInternalOutlet as f, NglCommonNotify as g, NglCommonNotifyClose as h, NglCarouselIndicator as i, NglColorpickerSwatch as j, NglColorpickerCustom as k, NglColorpickerRange as l, NglColorpickerInputs as m, NglColorpickerSwatches as n, NglColorpickerSwatchTrigger as o, OnChange as p, hasObservers as q, NglFormsModule as r, NglFormLabel as s, NglFormHelp as t, NglTooltip as u, NglComboboxService as v, NglOverlayModule as w, NglOverlaynglOverlayScrolledOutsideViewDirective as x, NglInternalDatatableHeadCell as y, NglInternalDatatableCell as z };
//# sourceMappingURL=ng-lightning.js.map
